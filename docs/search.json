[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso: Análisis de datos con Tidyverse",
    "section": "",
    "text": "Date: Date and time\nLugar: Centro de Investigaciones Biológicas del Noroeste, S.C.\nInstructores: Miguel A. Tripp Valdez\n\n\n1 ¡Bienvenidos!\n\n\n\n\n\n\nObjetivos del curso\n\n\n\n\nQue el alumno tenga un panorama detallado sobre el uso de la herramientas dentro del conjunto de paquetes de Tidyverse para importar, manipular, extraer y visualizar información relevante a partir de bases de datos.\nQue el alumno adquiera habilidades prácticas para la manipulación y visualización de datos\nQue el alumno sea capaz de acoplar la experiencia adquirida en este curso para análisis estadísticos, datos genómicos, datos espaciales, etc.\n\n\n\n\nRequisitos\n\nEs deseable que el alumno tenga experiencia básica en el uso de R\nTener acceso internet\nTener instalado R y Rstudio en su computadora\n\n\n\n\n2 Horario del curso\n\n\n\n\n\n\n\n\nHorario\nLección\n\n\n\n\n\nxxxx - xxxxx\nIntroducción a Tidyvese, Rstuio y Posit Cloud\nImportar datos, limpiar etiquetas y exportar\n\n\n\nxxxx - xxxx\nData wrangling\ndplyr, tidyr, uso del pipe\n\n\nxxxx - xxxx"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About page\n\n\n\nThis page contains some elaborated background information about your workshop, or the instructors.\n\n\nFor example: A central problem in machine learning is how to make an algorithm perform well not just on the training data, but also on new inputs. Many strategies in machine learning are explicitly designed to reduce this test error, possibly at the expense of increased training error. These strategies are collectively known as regularisation and they are instrumental for good performance of any kind of prediction or classification model, especially in the context of small data (many features, few samples).\nIn the hands-on tutorial we will use R to perform an integrated analysis of multi-omics data with penalised regression.\n\nContact\nInstructor A: contact\nInstructor B: contact\nInstructor C: contact"
  },
  {
    "objectID": "part_1_prep.html",
    "href": "part_1_prep.html",
    "title": "Preparation",
    "section": "",
    "text": "Page without code\n\n\n\nThis page contains an example for some structured preparation information for a workshop. No code is executed here.\nHere are some preparation information for the participants."
  },
  {
    "objectID": "part_1_prep.html#software",
    "href": "part_1_prep.html#software",
    "title": "Preparation",
    "section": "1 Software",
    "text": "1 Software\nIn this workshop we will be using R. You can either\n\nhave R and Rstudio installed on your laptop\nor, use Posit cloud (formerly Rstudio Cloud).\n\nPosit cloud is free of charge for personal users, yet you need to sign up for a new user account and have internet connection.\nThe R package we are using is glmnet."
  },
  {
    "objectID": "part_1_prep.html#data",
    "href": "part_1_prep.html#data",
    "title": "Preparation",
    "section": "2 Data",
    "text": "2 Data\nThe datasets we use can be found here (insert link)."
  },
  {
    "objectID": "part_1_prep.html#code",
    "href": "part_1_prep.html#code",
    "title": "Preparation",
    "section": "3 Code",
    "text": "3 Code\nThe R scripts used in part 1 and part 2 can be found here (insert link)."
  },
  {
    "objectID": "part_1_prep.html#resources",
    "href": "part_1_prep.html#resources",
    "title": "Preparation",
    "section": "4 Resources",
    "text": "4 Resources\nLecture notes (insert link)\nLab notes (insert link)"
  },
  {
    "objectID": "part_2_eda.html",
    "href": "part_2_eda.html",
    "title": "Part I",
    "section": "",
    "text": "Page with R code\n\n\n\nThis page contains an example template for a lab session, where R code and results are displayed here.\nYou can find more information on how to include code in Quarto website here.\nYou can experiment with code-fold and code-tools in the yaml header above to change how the code cells look like."
  },
  {
    "objectID": "part_2_eda.html#a-cancer-modeling-example",
    "href": "part_2_eda.html#a-cancer-modeling-example",
    "title": "Part I",
    "section": "1 A Cancer Modeling Example",
    "text": "1 A Cancer Modeling Example\nExercise on analysis of miRNA, mRNA and protein data from the paper Aure et al, Integrated analysis reveals microRNA networks coordinately expressed with key proteins in breast cancer, Genome Medicine, 2015.\nPlease run the code provided to replicate some of the analyses. Make sure you can explain what all the analysis steps do and that you understand all the results.\nIn addition, there are some extra tasks (Task 1), where no R code is provided. Please do these tasks when you have time available at the end of the lab.\n\n1.1 Load the data\nRead the data, and convert to matrix format.\n\nmrna &lt;- read.table(\"data/data_example.txt\", header=T, sep=\"\\t\", dec=\".\")\n\n# Convert to matrix format\n\nmrna &lt;- as.matrix(mrna)\n\nPrint the data\n\nmrna[1:4, 1:4]\n\n      OSL2R.3002T4 OSL2R.3005T1 OSL2R.3013T1 OSL2R.3030T2\nACACA      1.60034     -0.49087     -0.26553     -0.27857\nANXA1     -2.42501     -0.05416     -0.46478     -2.18393\nAR         0.39615     -0.43348     -0.10232      0.58299\nBAK1       0.78627      0.39897      0.22598     -1.31202\n\n\nVisualise the overall distribution of expression levels by histogram\n\nhist(mrna, nclass=40, xlim=c(-5,5), col=\"lightblue\")\n\n\n\n\n\n\n\n\n\n\nTask 1\n\n\n\nThis is a callout-note, and it can be quite useful for exercises. You can find more about callout here.\nExample: Extend the above analysis to cover all genes."
  },
  {
    "objectID": "apoyo.html",
    "href": "apoyo.html",
    "title": "Recursos de apoyo",
    "section": "",
    "text": "A continuación encontrarás diversos materiales disponibles en la red con la que puedes ampliar tus conocimientos en R y ciencia de datos\n\nLibros en línea\n\nR para Ciencia de Datos - Versión en español de conocido libro R fo Data Science de Wickham y Grolemund\nThe Big Book of R - Extensa colección de libros y materiales en línea\nData Visualization with R - Libro para la creación de gráficos en ggplot\nFundamentals of Data Visualization - Guía para generar visualizaciones efectivas\nQuarto - Guia para generar reportes, páginas web y documentos PDF con Quarto\n\nA quien seguir\n\nPositPBC - Seminarios, tutoriales y comentarios sobre las últimas novedades de la comunidad de Rstudio (Posit)\nR ladies - R-Ladies es una organización mundial cuya misión es promover la diversidad de género en la comunidad R.\nCommunity of Bioinformatics Software Developers - Canal de bioinformática con númerosos tutoriales de R desde nivel principiante hasta análisis avanzados"
  },
  {
    "objectID": "1.Introduccion.html",
    "href": "1.Introduccion.html",
    "title": "Introducción al curso",
    "section": "",
    "text": "Tidyverse no es en si un paquete sino un conjunto de paquetes en el lenguaje de programación R, diseñado para facilitar la manipulación, visualización y análisis de datos. Desarrollado por Hadley Wickham y su equipo, Tidyverse busca proporcionar un enfoque coherente y eficiente para trabajar con datos, promoviendo la claridad, la reproducibilidad y la facilidad de uso en el análisis de datos.\nPodríamos decir que Tidyverse es una filosofía de trabajo que permite que diversos programas y funciones trabajen bajo esta misma filosofía.\n\n\n\n\n\n\n¿Realmente necesito aprender a usar Tidyverse?\n\n\n\nRealmente no. Todas las funciones y herramientas que veremos a lo largo de este curso pueden realizarse utilizando funciones de base de R. Sin embargo, Tidyverse tiene una estructura mas coherente, legible y comprensible."
  },
  {
    "objectID": "1.Introduccion.html#footnotes",
    "href": "1.Introduccion.html#footnotes",
    "title": "Introducción al curso",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nTidyverse↩︎"
  },
  {
    "objectID": "2.Proyectos.html",
    "href": "2.Proyectos.html",
    "title": "Leccion 1: Proyectos en Rstudio",
    "section": "",
    "text": "@allison_horst\n\n\nIndependientemente de si estás dando tus primeros pasos en R o si ya eres un experto, es frecuente que la primera línea de tu código sea algo como esto:\nsetwd(\"C:\\Users\\miguel\\ruta\\que\\solo\\yo\\tengo\")\nsetwd() toma una ruta absoluta y la establece como el directorio de trabajo activo. El utilizar una ruta absoluta como directorio de trabajo hace que sea difícil de reproducir o de mover ya que otra persona u otro equipo no tiene esa misma ruta absoluta.\n\n1 Proyectos en Rstudio\nLos proyectos de RStudio resuelven el problema de las rutas ‘frágiles’ al hacer que las rutas de archivo sean relativas. El archivo de proyecto de RStudio es un archivo que se encuentra en el directorio raíz, con la extensión .Rproj. Cuando tu sesión de RStudio está siendo ejecutada a través del archivo de proyecto (.Rproj), el directorio de trabajo actual apunta a la carpeta raíz donde se guarda ese archivo .Rproj.\nEste proyecto facilita importar y exportar archivos ya que todos están a la mano a partir de rutas relativas a la carpeta raíz.\n\n\n\n\n\n\nTip\n\n\n\nOtra gran ventaja de los proyectos de Rstudio, es que puedes compartirlo con otra persona manteniendo la estructura de las rutas relativas, de manera que no importa en donde se guarde el proyecto o si esta utilizando otro sistema operativo, las rutas relativas permanecen funcionales siempre y cuando abra la sesión utilizando el proyecto (.Rproj).\n\n\nUn ejemplo de como podemos estructurar un proyecto es el siguiente:\n\n\n\n\n\n\nDatos: Esta es la carpeta en la que se guardan los archivos que necesito leer en R para realizar mi análisis o visualización. Estos pueden ser CSV, TXT, TSV, etc. La idea principal de tener esta carpeta es que estos archivos crudos en ningún momento debería sobrescribir o editar para garantizar la reproducibilidad.\nScript: Aquí es donde puedes guardar los scripts de R y/o archivos RMarkdown o Quarto.\nSalida: En esta carpeta puedes guardar todas tus salidas, incluyendo gráficos, HTML y tablas, etc. Tener esta carpeta de Salida ayuda a otros a identificar qué archivos son resultados del código, en contraste con los archivos fuente que se utilizaron para producir el análisis.\n\n\n\n2 Como generar un proyecto nuevo\nPara crear un proyecto nuevo sigue estos passos:\n\nAbre Rstudio y selecciona Archivo -&gt; Nuevo Proyecto\n\n\n\n\n\n\n\nSelecciona Nueva Carpeta si estas empezando el proyecto desde cero o carpeta existente si deseas crear un proyecto dentro de alguna carpeta que ya tengas\n\n\n\n\n\n\n\nDa un nombre a tu proyecto y ¡listo! ya puedes empezar a trabajar.\n\nEl proyecto R que has creado estará en una carpeta que contiene un archivo .Rproj. Este archivo es un acceso directo y probablemente la forma más directa de abrir tu proyecto. También puedes abrir un proyecto seleccionando “Open Project” en el menú File. Alternativamente, en el extremo superior derecho de RStudio verás un icono de R projects y un menú desplegable de proyectos disponibles.\n\n\n\n\n\nPara salir de un proyecto R, abre un nuevo proyecto o cierra el proyecto actual (Archivo - Cerrar proyecto).\n\n\n\n\n\n\nEjercicio\n\n\n\nAhora prueba creando un proyecto dentro de una carpeta local en tu computadora y genera una estructura de carpetas como la indicada anteriormente\n\n\n\n\n\n\n\n\nPro tip: uso de here() para rutas relativas\n\n\n\nEl paquete here() se utiliza para construir rutas de archivos y directorios de manera relativa al directorio del proyecto actual. En lugar de utilizar rutas absolutas (que especifican la ruta completa desde la raíz del sistema de archivos) o rutas relativas estándar (que se basan en la ubicación del script en ejecución), here() crea rutas relativas desde el directorio del proyecto."
  },
  {
    "objectID": "3_Data_import.html",
    "href": "3_Data_import.html",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "La importación de archivos de texto es el primer paso y parte fundamental para la exploración de datos. Sin embargo, también puede llegar a ser una tarea complicada.\nLos tipos de archivos mas comunes con los que solemos trabajar son:\n\nComa-separated values (csv)\nTab-separated values (tsv)\nExcel (xls)\nArchivo de texto simple (txt)\n\n\n\nPara importar un archivo a nuestro ambiente podemos utilizar las funciones base read.table, read.csv, read.delim. Por ejemplo, para abrir un archivo txt separado por tabuladores utilizando la función:\n\ndf &lt;- read.table(\"data/palmer_penguins.txt\", header = TRUE, sep = \"\\t\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007\n\n\no usando read.csv\n\ndf &lt;- read.csv(\"data/palmer_penguins.csv\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007\n\n\n\n\n\nDentro del Tidyverse, la importación de datos rectangulares se realiza con el paquete readr el cual tiene funciones que van a sonar muy familiares:\n\nread_csv(): comma-separated values (CSV)\nread_tsv(): tab-separated values (TSV)\nread_csv2(): semicolon-separated values with , as the decimal mark\nread_delim(): delimited files (CSV and TSV are important special cases)\nread_table(): whitespace-separated files\n\n\n\n\n\n\n\n¿Has notado algo? 🧐\n\n\n\nComo ves, los nombres de las funciones son muy parecidas a las funciones base pero reemplazando el “.” por un “_”. Esta tendencia se repite en numerosas funciones que siguen la filosofía tidy. Por ejemplo, en lugar de la prueba shapiro.test, rstatix utiliza la función shapiro_test.\n\n\nHagamos la prueba…\n\nlibrary(tidyverse)\nlibrary(here)\n\n\ndf &lt;- read_table(\"data/palmer_penguins.txt\")\n\n\n── Column specification ────────────────────────────────────────────────────────\ncols(\n  species = col_character(),\n  island = col_character(),\n  bill_length_mm = col_double(),\n  bill_depth_mm = col_double(),\n  flipper_length_mm = col_double(),\n  body_mass_g = col_double(),\n  sex = col_character(),\n  year = col_double()\n)\n\n\nObserva como, aún antes de desplegar la tabla,read_table ya nos arroja información sobre la estructura de los datos y nos indica si cada columna es número, carácter o de otro tipo.\nAhora observa como se despliega la tabla\n\ndf\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\n\n\n\n¿double? ¿character? 😱\n\n\n\nEn caso de que no lo recuerdes, estos son los principales tipos de datos en R\n\n\n\nTipo\nDescripción\nEjemplo\n\n\nNumeric\ninterger números enteros\n0L, 1L\n\n\nNumeric\ndouble números reales\n1.0,\n\n\nLogic\nvalores booleanos\nTRUE, FALSE\n\n\nCharacter\ncadena de texto\n“Hola mundo”\n\n\nFactor\nrepresentan datos categóricos\nmacho, hembra\n\n\nDates\nFechas\n“2023-08-24”\n\n\n\n\n\n\n\n\nCon R base, la función read.table nos genera un data frame pero readr nos genera un tibble los cuales son una versión actualizada de un data frame.\nHay varias diferencias entre tibbles y data.frames. Puedes leer mas en la viñeta. Sin embargo, algunas de las diferencias mas notables son:\n\nEl tipo de entrada permanece inalterado: los data.frames son conocidos por tratar las cadenas de texto como factores; esto no sucederá con los tibbles.\nLos nombres de las variables permanecen inalterados: En R base, al crear data.frames se eliminan los espacios de los nombres, convirtiéndolos en puntos o agregando una “x” antes de los nombres de las columnas numéricas. Al crear tibbles, los nombres de las variables (columnas) no cambian.\nNo hay row.names() para un tibble: Los datos ordenados requieren que las variables se almacenen de manera consistente, eliminando la necesidad de nombres de filas. Los tibbles imprimen las primeras diez filas y columnas que caben en una pantalla: Imprimir un tibble en la pantalla nunca mostrará todo el enorme marco de datos. Por defecto, solo muestra lo que cabe en tu pantalla.\n\n\n\nSi tenemos datos rectangulares como data.frame podemos convertirlo facilmente a tibble con la función as_tibble()\nPor ejemplo, podemos:\n\nas_tibble(trees)\n\n# A tibble: 31 × 3\n   Girth Height Volume\n   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1   8.3     70   10.3\n 2   8.6     65   10.3\n 3   8.8     63   10.2\n 4  10.5     72   16.4\n 5  10.7     81   18.8\n 6  10.8     83   19.7\n 7  11       66   15.6\n 8  11       75   18.2\n 9  11.1     80   22.6\n10  11.2     75   19.9\n# ℹ 21 more rows\n\n\n\n\n\n\n\n\nWarning\n\n\n\nRecuerda que si solo ejecutamos el comando as_tibble(trees) R solo nos arrojará el resutlado en la consola pero no hizo ningún cambio al objeto trees. Para esto necesitamos renombrar o generar un nuevo objeto. Por ejemplo\n\ntrees_tbl &lt;- as_tibble(trees)\n\nahora si, tenemos un nuevo objetvo como tibble\n\nclass(trees)\n\n[1] \"data.frame\"\n\nclass(trees_tbl)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\nAl igual que como lo hariamos con un data.frame o una matriz, podemos acceder a las primeras o últimas filas de nuestro tibble con las funciones head() y tail()\n\nhead(df)\n\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\ntail(df)\n\n# A tibble: 6 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Chinstrap Dream            45.7          17                 195        3650\n2 Chinstrap Dream            55.8          19.8               207        4000\n3 Chinstrap Dream            43.5          18.1               202        3400\n4 Chinstrap Dream            49.6          18.2               193        3775\n5 Chinstrap Dream            50.8          19                 210        4100\n6 Chinstrap Dream            50.2          18.7               198        3775\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\nTambién es posible hacer tibble sobre la marcha utilizando la función tibble(). Por ejemplo:\n\nmi_tibl &lt;- tibble(\n  a = 1:5,\n  b = 6:10,\n  c = 1,\n  z = (a + b)^2 + c\n)\n\nmi_tibl\n\n# A tibble: 5 × 4\n      a     b     c     z\n  &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     6     1    50\n2     2     7     1    82\n3     3     8     1   122\n4     4     9     1   170\n5     5    10     1   226\n\n\nNota que al momento de generar este tibble, puedes hacer referencias a columnas del mismo tibble (columa z)\nOtro comportamiento de los tibbles es que es posible tener nombres de columnas con espacios u otros caracteres y estos estarán rodeados por ``\n\nmi_tibl &lt;- tibble(\n  `cinco números` = 1:5,\n  `12` = \"numeric\",\n  `:)` = \"smile\",\n)\n\nmi_tibl\n\n# A tibble: 5 × 3\n  `cinco números` `12`    `:)` \n            &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;\n1               1 numeric smile\n2               2 numeric smile\n3               3 numeric smile\n4               4 numeric smile\n5               5 numeric smile\n\n\n\n\n\n\nLas hojas de calculo de excel (formatos .xls o .xlsx) siguen siendo muy comunes y muy utilizados dentro de la comunidad académica.\nTidyverse no tiene dentro de su núcleo una función para importar este tipo de archivos, pero esto se soluciona fácilmente con el paquete readxl.\n\n\n\n\n\n\ninstall.packages(\"readxl\")\n\n\nlibrary(readxl)\n\nWarning: package 'readxl' was built under R version 4.3.1\n\n\nCon esto podemos usar la función read_excel() que no necesita ningún otro argumento mas que la ruta (path) donde se encuentra el archivo .xlsx\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\")\n\nexcel_df\n\n# A tibble: 405 × 9\n   `Sample ID` ExpNum TreatTemp Meas_Temp `WetWeight(g)` `buffer(ml)`\n   &lt;chr&gt;        &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;\n 1 Hf100U           3        24        18          0.093         0.93\n 2 Hf100U           3        24        18          0.093         0.93\n 3 Hf100U           3        24        32          0.093         0.93\n 4 Hf100U           3        24        32          0.093         0.93\n 5 Hf101U           3        30        18          0.114         1.14\n 6 Hf101U           3        30        18          0.114         1.14\n 7 Hf101U           3        30        32          0.114         1.14\n 8 Hf101U           3        30        32          0.114         1.14\n 9 Hf102U           3        30        18          0.092         0.92\n10 Hf102U           3        30        18          0.092         0.92\n# ℹ 395 more rows\n# ℹ 3 more variables: `MessVol(ul)` &lt;dbl&gt;, slopeTDH &lt;dbl&gt;, ActivityTDH &lt;dbl&gt;\n\n\nEn caso de que los datos de interes estén en una hoja en particular usamos el argumento sheet=\n\nexcel_df&lt;- read_excel(\"data/actividad_enzimas.xlsx\", sheet = \"hoja1\")\n\nUn caso mas complicado es cuando nuestro datos inician unas filas mas abajo y en un determinado intervalo de columnas. Otro caso común es que los nombres de las columnas tengan símbolos especiales o que estén repetidos\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", skip = 3, na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\nEn caso de que tengamos otra información que nos este generando conflicto podemos especificar el rango de datos de interés\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nHeterogeneidad en los nombres de las columna\n\n\n\nObserva como los tibbles permite que haya símbolos, espacios, acentos y alternancia de mayúsculas y minúsculas en los nombres de las columnas. Sin embargo, al momento de trabajar, esta heterogeneidad puede darnos problemas. Esto se puede solucionar con el paquete janitor.\n\n\n\n\n\n\n\n\n\n\nEl paquete Janitor es una herramienta pequeña pero increíblemente útil y conveniente cuando se trata de limpiar y mantener conjuntos de datos en RStudio. Además, es un paquete orientado a “tidyverse”, por lo que se integra perfectamente con los pipes.\nRegresemos a los nombres de las columnas de nuestro archivo excel antes de utilizar janitor\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\n\n\n [1] \"Número de muestra\"        \"Número de experimento\"   \n [3] \"Tratamiento\"              \"Temperatura\"             \n [5] \"peso húmedo (g)\"          \"buffer (ml)\"             \n [7] \"volumen de reaccion (ul)\" \"concentración g/ml\"      \n [9] \"pendiente...9\"            \"pendiente...10\"          \n\n\n\nNo hay consistencia entre el uso de mayúsculas y minúsculas en los nombres. Recuerda que R es sensible a mayúsculas, por lo que Temperatura no es lo mismo que temperatura.\nTenemos símbolos como acentos que nos pueden generar conflictos, sobre todo si tenemos símbolos en otros idiomas.\nLos espacios en blanco así como otros símbolos como / son reemplazados por un punto. Esto genera etiquetas complicadas.\n\nLo ideal es tener consistencia en el formato de las etiquetas. Algunos formatos conocidos son los siguientes:\n\n\n\n\n\nAhora utilicemos janitor para limpiar las etiquetas\n\nlibrary(janitor)\n\nWarning: package 'janitor' was built under R version 4.3.1\n\n\n\nAttaching package: 'janitor'\n\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\n\n\nexcel_clean &lt;- clean_names(excel_df)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente_9 &lt;dbl&gt;, pendiente_10 &lt;dbl&gt;\n\n\nlas opciones son:\n\n“snake”\n“small_camel”\n“big_camel”\n“screaming_snake”\n“parsed”\n“lower_upper”\n“upper_lower”\n\npor ejemplo:\n\nexcel_clean &lt;- clean_names(excel_df, case = \"screaming_snake\")\nexcel_clean\n\n# A tibble: 405 × 10\n   NUMERO_DE_MUESTRA NUMERO_DE_EXPERIMENTO TRATAMIENTO TEMPERATURA PESO_HUMEDO_G\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: BUFFER_ML &lt;dbl&gt;, VOLUMEN_DE_REACCION_UL &lt;dbl&gt;,\n#   CONCENTRACION_G_ML &lt;dbl&gt;, PENDIENTE_9 &lt;dbl&gt;, PENDIENTE_10 &lt;dbl&gt;\n\n\nCon janitor podemos integrar la función make_clean_name al momento de importar datos ya sea con readxl o con readr. Por ejemplo:\n\nexcel_clean &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\",\n                       .name_repair =  make_clean_names)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWarning\n\n\n\nObserva que tanto readxl como readr interpretan las columnas de número de experimento, tratamiento y temperatura como variables numéricas debido a que analizan la cantidad de datos para inferir el tipo de variable. No obstante, estas variables son en realidad factores, ya que representan categorías. Más adelante veremos cómo realizar este ajuste de manera manual.\n\n\n\n\n\nUn aspecto importante para el análisis de datos es tener una perspectiva rápida del tibble o datafram para entender las variables que tenemos, asi como los patrones generales de los datos.\nHay varias funciones que podemos utilizar. Ya mencionamos algunas herramienta como head() o tail() para echar un vistazo a las primeras o últimas filas de la tabla, respectivamente.\nOtra herramienta es la función glimpse() de dplyr que nos muestra algunos datos de cada columna de nuestro tibble para tener una idea de la estructura de la tabla.\n\nglimpse(excel_clean)\n\nRows: 405\nColumns: 10\n$ numero_de_muestra      &lt;chr&gt; \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf101U…\n$ numero_de_experimento  &lt;dbl&gt; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,…\n$ tratamiento            &lt;dbl&gt; 24, 24, 24, 24, 30, 30, 30, 30, 30, 30, 30, 30,…\n$ temperatura            &lt;dbl&gt; 18, 18, 32, 32, 18, 18, 32, 32, 18, 18, 32, 32,…\n$ peso_humedo_g          &lt;dbl&gt; 0.093, 0.093, 0.093, 0.093, 0.114, 0.114, 0.114…\n$ buffer_ml              &lt;dbl&gt; 0.93, 0.93, 0.93, 0.93, 1.14, 1.14, 1.14, 1.14,…\n$ volumen_de_reaccion_ul &lt;dbl&gt; 20, 10, 20, 10, 20, 10, 20, 10, 20, 10, 20, 10,…\n$ concentracion_g_ml     &lt;dbl&gt; 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.…\n$ pendiente              &lt;dbl&gt; 0.0331, 0.0145, 0.1431, 0.0653, 0.0354, 0.0155,…\n$ pendiente_2            &lt;dbl&gt; 2.660772, 2.331190, 11.503215, 10.498392, 2.845…\n\n\nLa función summary() es parte de las funciones base de R y es particularmente útil cuando tenemos datos continuos, ya que nos muestra, para cada columna, los valores mínimos, máximos, promedio, mediana y el 1er y 3er quartil.\n\nsummary(excel_clean)\n\n numero_de_muestra  numero_de_experimento  tratamiento     temperatura   \n Length:405         Min.   :1.000         Min.   :18.00   Min.   :18.00  \n Class :character   1st Qu.:2.000         1st Qu.:24.00   1st Qu.:18.00  \n Mode  :character   Median :3.000         Median :24.00   Median :18.00  \n                    Mean   :2.528         Mean   :26.04   Mean   :24.74  \n                    3rd Qu.:4.000         3rd Qu.:30.00   3rd Qu.:32.00  \n                    Max.   :4.000         Max.   :32.00   Max.   :32.00  \n                                                                         \n peso_humedo_g       buffer_ml      volumen_de_reaccion_ul concentracion_g_ml\n Min.   :0.02900   Min.   :0.2900   Min.   :10.00          Min.   :0.1       \n 1st Qu.:0.06700   1st Qu.:0.6700   1st Qu.:10.00          1st Qu.:0.1       \n Median :0.08500   Median :0.8500   Median :20.00          Median :0.1       \n Mean   :0.08387   Mean   :0.8387   Mean   :15.04          Mean   :0.1       \n 3rd Qu.:0.09900   3rd Qu.:0.9900   3rd Qu.:20.00          3rd Qu.:0.1       \n Max.   :0.18900   Max.   :1.8900   Max.   :20.00          Max.   :0.1       \n                                                                             \n   pendiente        pendiente_2    \n Min.   :0.00000   Min.   : 0.000  \n 1st Qu.:0.01480   1st Qu.: 1.632  \n Median :0.03500   Median : 4.594  \n Mean   :0.04949   Mean   : 5.205  \n 3rd Qu.:0.07290   3rd Qu.: 8.163  \n Max.   :0.31390   Max.   :25.233  \n                   NA's   :13      \n\n\nOtra herramienta un poco mas sofisticada pero bastante útil es la función gt_plt_summary() del paquete gtExtras, la cual nos permite gráficar cada una de las variables, nos muestra los valores promedio, mediana y desvicación, y ádemas nos muestra el % de valores faltantes (missing).\nPara utilizar esta herramienta, primero necesitamos instalar el paquete gtExtras y posteriormente cargar la librería.\n\ninstall.packages(\"gtExtras\")\n\n\nlibrary(gtExtras)\n\nWarning: package 'gtExtras' was built under R version 4.3.1\n\ngt_plt_summary(excel_clean)\n\nWarning: Computation failed in `stat_bin()`\nCaused by error in `bin_breaks_width()`:\n! The number of histogram bins must be less than 1,000,000.\nℹ Did you make `binwidth` too small?\n\n\n\n\n\n\n  \n    \n      excel_clean\n    \n    \n      405 rows x 10 cols\n    \n    \n      \n      Column\n      Plot Overview\n      Missing\n      Mean\n      Median\n      SD\n    \n  \n  \n    \nnumero_de_muestra\n                  96 categories\n0.0%\n—\n—\n—\n    \nnumero_de_experimento\n                  14\n0.0%\n2.5\n3.0\n1.1\n    \ntratamiento\n                  1832\n0.0%\n26.0\n24.0\n5.4\n    \ntemperatura\n                  1832\n0.0%\n24.7\n18.0\n7.0\n    \npeso_humedo_g\n                  0.030.19\n0.0%\n0.1\n0.1\n0.0\n    \nbuffer_ml\n                  0.31.9\n0.0%\n0.8\n0.8\n0.3\n    \nvolumen_de_reaccion_ul\n                  1020\n0.0%\n15.0\n20.0\n5.0\n    \nconcentracion_g_ml\n                  00\n0.0%\n0.1\n0.1\n0.0\n    \npendiente\n                  0.000.31\n0.0%\n0.0\n0.0\n0.0\n    \npendiente_2\n                  025\n3.2%\n5.2\n4.6\n4.2\n  \n  \n  \n\n\n\n\n\n\n\nUna vez terminado nuestro análisis debemos guardarlo. Siguiendo la recomendación que vimos anteriormente, lo ideal es guardar los datos ya procesados (ya sea que se haya realizado algún tipo de filtrado o transformación) en una carpeta diferente a la carpeta donde están los datos crudos, los cuales se recomienda que se preserven sin alteraciones.\nPodemos crear una nueva carpeta con Archivos &gt; Nuevo directorio o desde la línea de comando usando la función dir.create()\n\ndir.create(\"resultados/tablas\", recursive = TRUE)\n\nWarning in dir.create(\"resultados/tablas\", recursive = TRUE):\n'resultados\\tablas' already exists\n\n\nPara guardar nuestros datos, las funciones que utilizaremos mas frecuentemente son write.table y write_csv()\nPor ejemplo, vamos a tomar las primeras filas de nuestro objeto excel_clean con la función head()\n\nexcel_subset &lt;- head(excel_clean)\nexcel_subset\n\n# A tibble: 6 × 10\n  numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n  &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n1 Hf100U                                3          24          18         0.093\n2 Hf100U                                3          24          18         0.093\n3 Hf100U                                3          24          32         0.093\n4 Hf100U                                3          24          32         0.093\n5 Hf101U                                3          30          18         0.114\n6 Hf101U                                3          30          18         0.114\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\nAhora lo guardamos en la carpeta que acabamos de crear usando la función write_csv()\n\nwrite_csv(excel_subset, file = \"resultados/tablas/excel_subset.csv\")\n\no con write.table() la cual nos permite usar una mayor diversidad de formatos\n\nwrite.table(excel_subset, file = \"resultados/tablas/excel_subset.txt\", sep = \"\\t\")"
  },
  {
    "objectID": "3_Data_import.html#funciones-base-para-importar-archivos",
    "href": "3_Data_import.html#funciones-base-para-importar-archivos",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "Para importar un archivo a nuestro ambiente podemos utilizar las funciones base read.table, read.csv, read.delim. Por ejemplo, para abrir un archivo txt separado por tabuladores utilizando la función:\n\ndf &lt;- read.table(\"data/palmer_penguins.txt\", header = TRUE, sep = \"\\t\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007\n\n\no usando read.csv\n\ndf &lt;- read.csv(\"data/palmer_penguins.csv\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007"
  },
  {
    "objectID": "3_Data_import.html#importar-datos-a-lá-tidyverse",
    "href": "3_Data_import.html#importar-datos-a-lá-tidyverse",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "Dentro del Tidyverse, la importación de datos rectangulares se realiza con el paquete readr el cual tiene funciones que van a sonar muy familiares:\n\nread_csv(): comma-separated values (CSV)\nread_tsv(): tab-separated values (TSV)\nread_csv2(): semicolon-separated values with , as the decimal mark\nread_delim(): delimited files (CSV and TSV are important special cases)\nread_table(): whitespace-separated files\n\n\n\n\n\n\n\n¿Has notado algo? 🧐\n\n\n\nComo ves, los nombres de las funciones son muy parecidas a las funciones base pero reemplazando el “.” por un “_”. Esta tendencia se repite en numerosas funciones que siguen la filosofía tidy. Por ejemplo, en lugar de la prueba shapiro.test, rstatix utiliza la función shapiro_test.\n\n\nHagamos la prueba…\n\nlibrary(tidyverse)\nlibrary(here)\n\n\ndf &lt;- read_table(\"data/palmer_penguins.txt\")\n\n\n── Column specification ────────────────────────────────────────────────────────\ncols(\n  species = col_character(),\n  island = col_character(),\n  bill_length_mm = col_double(),\n  bill_depth_mm = col_double(),\n  flipper_length_mm = col_double(),\n  body_mass_g = col_double(),\n  sex = col_character(),\n  year = col_double()\n)\n\n\nObserva como, aún antes de desplegar la tabla,read_table ya nos arroja información sobre la estructura de los datos y nos indica si cada columna es número, carácter o de otro tipo.\nAhora observa como se despliega la tabla\n\ndf\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\n\n\n\n¿double? ¿character? 😱\n\n\n\nEn caso de que no lo recuerdes, estos son los principales tipos de datos en R\n\n\n\nTipo\nDescripción\nEjemplo\n\n\nNumeric\ninterger números enteros\n0L, 1L\n\n\nNumeric\ndouble números reales\n1.0,\n\n\nLogic\nvalores booleanos\nTRUE, FALSE\n\n\nCharacter\ncadena de texto\n“Hola mundo”\n\n\nFactor\nrepresentan datos categóricos\nmacho, hembra\n\n\nDates\nFechas\n“2023-08-24”"
  },
  {
    "objectID": "3_Data_import.html#tibbles",
    "href": "3_Data_import.html#tibbles",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "Con R base, la función read.table nos genera un data frame pero readr nos genera un tibble los cuales son una versión actualizada de un data frame.\nHay varias diferencias entre tibbles y data.frames. Puedes leer mas en la viñeta. Sin embargo, algunas de las diferencias mas notables son:\n\nEl tipo de entrada permanece inalterado: los data.frames son conocidos por tratar las cadenas de texto como factores; esto no sucederá con los tibbles.\nLos nombres de las variables permanecen inalterados: En R base, al crear data.frames se eliminan los espacios de los nombres, convirtiéndolos en puntos o agregando una “x” antes de los nombres de las columnas numéricas. Al crear tibbles, los nombres de las variables (columnas) no cambian.\nNo hay row.names() para un tibble: Los datos ordenados requieren que las variables se almacenen de manera consistente, eliminando la necesidad de nombres de filas. Los tibbles imprimen las primeras diez filas y columnas que caben en una pantalla: Imprimir un tibble en la pantalla nunca mostrará todo el enorme marco de datos. Por defecto, solo muestra lo que cabe en tu pantalla.\n\n\n\nSi tenemos datos rectangulares como data.frame podemos convertirlo facilmente a tibble con la función as_tibble()\nPor ejemplo, podemos:\n\nas_tibble(trees)\n\n# A tibble: 31 × 3\n   Girth Height Volume\n   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1   8.3     70   10.3\n 2   8.6     65   10.3\n 3   8.8     63   10.2\n 4  10.5     72   16.4\n 5  10.7     81   18.8\n 6  10.8     83   19.7\n 7  11       66   15.6\n 8  11       75   18.2\n 9  11.1     80   22.6\n10  11.2     75   19.9\n# ℹ 21 more rows\n\n\n\n\n\n\n\n\nWarning\n\n\n\nRecuerda que si solo ejecutamos el comando as_tibble(trees) R solo nos arrojará el resutlado en la consola pero no hizo ningún cambio al objeto trees. Para esto necesitamos renombrar o generar un nuevo objeto. Por ejemplo\n\ntrees_tbl &lt;- as_tibble(trees)\n\nahora si, tenemos un nuevo objetvo como tibble\n\nclass(trees)\n\n[1] \"data.frame\"\n\nclass(trees_tbl)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\nAl igual que como lo hariamos con un data.frame o una matriz, podemos acceder a las primeras o últimas filas de nuestro tibble con las funciones head() y tail()\n\nhead(df)\n\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\ntail(df)\n\n# A tibble: 6 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Chinstrap Dream            45.7          17                 195        3650\n2 Chinstrap Dream            55.8          19.8               207        4000\n3 Chinstrap Dream            43.5          18.1               202        3400\n4 Chinstrap Dream            49.6          18.2               193        3775\n5 Chinstrap Dream            50.8          19                 210        4100\n6 Chinstrap Dream            50.2          18.7               198        3775\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\nTambién es posible hacer tibble sobre la marcha utilizando la función tibble(). Por ejemplo:\n\nmi_tibl &lt;- tibble(\n  a = 1:5,\n  b = 6:10,\n  c = 1,\n  z = (a + b)^2 + c\n)\n\nmi_tibl\n\n# A tibble: 5 × 4\n      a     b     c     z\n  &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     6     1    50\n2     2     7     1    82\n3     3     8     1   122\n4     4     9     1   170\n5     5    10     1   226\n\n\nNota que al momento de generar este tibble, puedes hacer referencias a columnas del mismo tibble (columa z)\nOtro comportamiento de los tibbles es que es posible tener nombres de columnas con espacios u otros caracteres y estos estarán rodeados por ``\n\nmi_tibl &lt;- tibble(\n  `cinco números` = 1:5,\n  `12` = \"numeric\",\n  `:)` = \"smile\",\n)\n\nmi_tibl\n\n# A tibble: 5 × 3\n  `cinco números` `12`    `:)` \n            &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;\n1               1 numeric smile\n2               2 numeric smile\n3               3 numeric smile\n4               4 numeric smile\n5               5 numeric smile"
  },
  {
    "objectID": "3_Data_import.html#importar-desde-excel",
    "href": "3_Data_import.html#importar-desde-excel",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "Las hojas de calculo de excel (formatos .xls o .xlsx) siguen siendo muy comunes y muy utilizados dentro de la comunidad académica.\nTidyverse no tiene dentro de su núcleo una función para importar este tipo de archivos, pero esto se soluciona fácilmente con el paquete readxl.\n\n\n\n\n\n\ninstall.packages(\"readxl\")\n\n\nlibrary(readxl)\n\nWarning: package 'readxl' was built under R version 4.3.1\n\n\nCon esto podemos usar la función read_excel() que no necesita ningún otro argumento mas que la ruta (path) donde se encuentra el archivo .xlsx\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\")\n\nexcel_df\n\n# A tibble: 405 × 9\n   `Sample ID` ExpNum TreatTemp Meas_Temp `WetWeight(g)` `buffer(ml)`\n   &lt;chr&gt;        &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;\n 1 Hf100U           3        24        18          0.093         0.93\n 2 Hf100U           3        24        18          0.093         0.93\n 3 Hf100U           3        24        32          0.093         0.93\n 4 Hf100U           3        24        32          0.093         0.93\n 5 Hf101U           3        30        18          0.114         1.14\n 6 Hf101U           3        30        18          0.114         1.14\n 7 Hf101U           3        30        32          0.114         1.14\n 8 Hf101U           3        30        32          0.114         1.14\n 9 Hf102U           3        30        18          0.092         0.92\n10 Hf102U           3        30        18          0.092         0.92\n# ℹ 395 more rows\n# ℹ 3 more variables: `MessVol(ul)` &lt;dbl&gt;, slopeTDH &lt;dbl&gt;, ActivityTDH &lt;dbl&gt;\n\n\nEn caso de que los datos de interes estén en una hoja en particular usamos el argumento sheet=\n\nexcel_df&lt;- read_excel(\"data/actividad_enzimas.xlsx\", sheet = \"hoja1\")\n\nUn caso mas complicado es cuando nuestro datos inician unas filas mas abajo y en un determinado intervalo de columnas. Otro caso común es que los nombres de las columnas tengan símbolos especiales o que estén repetidos\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", skip = 3, na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\nEn caso de que tengamos otra información que nos este generando conflicto podemos especificar el rango de datos de interés\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nHeterogeneidad en los nombres de las columna\n\n\n\nObserva como los tibbles permite que haya símbolos, espacios, acentos y alternancia de mayúsculas y minúsculas en los nombres de las columnas. Sin embargo, al momento de trabajar, esta heterogeneidad puede darnos problemas. Esto se puede solucionar con el paquete janitor."
  },
  {
    "objectID": "3_Data_import.html#limpiar-etiquetas-con-janitor",
    "href": "3_Data_import.html#limpiar-etiquetas-con-janitor",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "El paquete Janitor es una herramienta pequeña pero increíblemente útil y conveniente cuando se trata de limpiar y mantener conjuntos de datos en RStudio. Además, es un paquete orientado a “tidyverse”, por lo que se integra perfectamente con los pipes.\nRegresemos a los nombres de las columnas de nuestro archivo excel antes de utilizar janitor\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\n\n\n [1] \"Número de muestra\"        \"Número de experimento\"   \n [3] \"Tratamiento\"              \"Temperatura\"             \n [5] \"peso húmedo (g)\"          \"buffer (ml)\"             \n [7] \"volumen de reaccion (ul)\" \"concentración g/ml\"      \n [9] \"pendiente...9\"            \"pendiente...10\"          \n\n\n\nNo hay consistencia entre el uso de mayúsculas y minúsculas en los nombres. Recuerda que R es sensible a mayúsculas, por lo que Temperatura no es lo mismo que temperatura.\nTenemos símbolos como acentos que nos pueden generar conflictos, sobre todo si tenemos símbolos en otros idiomas.\nLos espacios en blanco así como otros símbolos como / son reemplazados por un punto. Esto genera etiquetas complicadas.\n\nLo ideal es tener consistencia en el formato de las etiquetas. Algunos formatos conocidos son los siguientes:\n\n\n\n\n\nAhora utilicemos janitor para limpiar las etiquetas\n\nlibrary(janitor)\n\nWarning: package 'janitor' was built under R version 4.3.1\n\n\n\nAttaching package: 'janitor'\n\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\n\n\nexcel_clean &lt;- clean_names(excel_df)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente_9 &lt;dbl&gt;, pendiente_10 &lt;dbl&gt;\n\n\nlas opciones son:\n\n“snake”\n“small_camel”\n“big_camel”\n“screaming_snake”\n“parsed”\n“lower_upper”\n“upper_lower”\n\npor ejemplo:\n\nexcel_clean &lt;- clean_names(excel_df, case = \"screaming_snake\")\nexcel_clean\n\n# A tibble: 405 × 10\n   NUMERO_DE_MUESTRA NUMERO_DE_EXPERIMENTO TRATAMIENTO TEMPERATURA PESO_HUMEDO_G\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: BUFFER_ML &lt;dbl&gt;, VOLUMEN_DE_REACCION_UL &lt;dbl&gt;,\n#   CONCENTRACION_G_ML &lt;dbl&gt;, PENDIENTE_9 &lt;dbl&gt;, PENDIENTE_10 &lt;dbl&gt;\n\n\nCon janitor podemos integrar la función make_clean_name al momento de importar datos ya sea con readxl o con readr. Por ejemplo:\n\nexcel_clean &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\",\n                       .name_repair =  make_clean_names)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWarning\n\n\n\nObserva que tanto readxl como readr interpretan las columnas de número de experimento, tratamiento y temperatura como variables numéricas debido a que analizan la cantidad de datos para inferir el tipo de variable. No obstante, estas variables son en realidad factores, ya que representan categorías. Más adelante veremos cómo realizar este ajuste de manera manual."
  },
  {
    "objectID": "3_Data_import.html#echando-un-vistado-a-los-datos",
    "href": "3_Data_import.html#echando-un-vistado-a-los-datos",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "Un aspecto importante para el análisis de datos es tener una perspectiva rápida del tibble o datafram para entender las variables que tenemos, asi como los patrones generales de los datos.\nHay varias funciones que podemos utilizar. Ya mencionamos algunas herramienta como head() o tail() para echar un vistazo a las primeras o últimas filas de la tabla, respectivamente.\nOtra herramienta es la función glimpse() de dplyr que nos muestra algunos datos de cada columna de nuestro tibble para tener una idea de la estructura de la tabla.\n\nglimpse(excel_clean)\n\nRows: 405\nColumns: 10\n$ numero_de_muestra      &lt;chr&gt; \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf101U…\n$ numero_de_experimento  &lt;dbl&gt; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,…\n$ tratamiento            &lt;dbl&gt; 24, 24, 24, 24, 30, 30, 30, 30, 30, 30, 30, 30,…\n$ temperatura            &lt;dbl&gt; 18, 18, 32, 32, 18, 18, 32, 32, 18, 18, 32, 32,…\n$ peso_humedo_g          &lt;dbl&gt; 0.093, 0.093, 0.093, 0.093, 0.114, 0.114, 0.114…\n$ buffer_ml              &lt;dbl&gt; 0.93, 0.93, 0.93, 0.93, 1.14, 1.14, 1.14, 1.14,…\n$ volumen_de_reaccion_ul &lt;dbl&gt; 20, 10, 20, 10, 20, 10, 20, 10, 20, 10, 20, 10,…\n$ concentracion_g_ml     &lt;dbl&gt; 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.…\n$ pendiente              &lt;dbl&gt; 0.0331, 0.0145, 0.1431, 0.0653, 0.0354, 0.0155,…\n$ pendiente_2            &lt;dbl&gt; 2.660772, 2.331190, 11.503215, 10.498392, 2.845…\n\n\nLa función summary() es parte de las funciones base de R y es particularmente útil cuando tenemos datos continuos, ya que nos muestra, para cada columna, los valores mínimos, máximos, promedio, mediana y el 1er y 3er quartil.\n\nsummary(excel_clean)\n\n numero_de_muestra  numero_de_experimento  tratamiento     temperatura   \n Length:405         Min.   :1.000         Min.   :18.00   Min.   :18.00  \n Class :character   1st Qu.:2.000         1st Qu.:24.00   1st Qu.:18.00  \n Mode  :character   Median :3.000         Median :24.00   Median :18.00  \n                    Mean   :2.528         Mean   :26.04   Mean   :24.74  \n                    3rd Qu.:4.000         3rd Qu.:30.00   3rd Qu.:32.00  \n                    Max.   :4.000         Max.   :32.00   Max.   :32.00  \n                                                                         \n peso_humedo_g       buffer_ml      volumen_de_reaccion_ul concentracion_g_ml\n Min.   :0.02900   Min.   :0.2900   Min.   :10.00          Min.   :0.1       \n 1st Qu.:0.06700   1st Qu.:0.6700   1st Qu.:10.00          1st Qu.:0.1       \n Median :0.08500   Median :0.8500   Median :20.00          Median :0.1       \n Mean   :0.08387   Mean   :0.8387   Mean   :15.04          Mean   :0.1       \n 3rd Qu.:0.09900   3rd Qu.:0.9900   3rd Qu.:20.00          3rd Qu.:0.1       \n Max.   :0.18900   Max.   :1.8900   Max.   :20.00          Max.   :0.1       \n                                                                             \n   pendiente        pendiente_2    \n Min.   :0.00000   Min.   : 0.000  \n 1st Qu.:0.01480   1st Qu.: 1.632  \n Median :0.03500   Median : 4.594  \n Mean   :0.04949   Mean   : 5.205  \n 3rd Qu.:0.07290   3rd Qu.: 8.163  \n Max.   :0.31390   Max.   :25.233  \n                   NA's   :13      \n\n\nOtra herramienta un poco mas sofisticada pero bastante útil es la función gt_plt_summary() del paquete gtExtras, la cual nos permite gráficar cada una de las variables, nos muestra los valores promedio, mediana y desvicación, y ádemas nos muestra el % de valores faltantes (missing).\nPara utilizar esta herramienta, primero necesitamos instalar el paquete gtExtras y posteriormente cargar la librería.\n\ninstall.packages(\"gtExtras\")\n\n\nlibrary(gtExtras)\n\nWarning: package 'gtExtras' was built under R version 4.3.1\n\ngt_plt_summary(excel_clean)\n\nWarning: Computation failed in `stat_bin()`\nCaused by error in `bin_breaks_width()`:\n! The number of histogram bins must be less than 1,000,000.\nℹ Did you make `binwidth` too small?\n\n\n\n\n\n\n  \n    \n      excel_clean\n    \n    \n      405 rows x 10 cols\n    \n    \n      \n      Column\n      Plot Overview\n      Missing\n      Mean\n      Median\n      SD\n    \n  \n  \n    \nnumero_de_muestra\n                  96 categories\n0.0%\n—\n—\n—\n    \nnumero_de_experimento\n                  14\n0.0%\n2.5\n3.0\n1.1\n    \ntratamiento\n                  1832\n0.0%\n26.0\n24.0\n5.4\n    \ntemperatura\n                  1832\n0.0%\n24.7\n18.0\n7.0\n    \npeso_humedo_g\n                  0.030.19\n0.0%\n0.1\n0.1\n0.0\n    \nbuffer_ml\n                  0.31.9\n0.0%\n0.8\n0.8\n0.3\n    \nvolumen_de_reaccion_ul\n                  1020\n0.0%\n15.0\n20.0\n5.0\n    \nconcentracion_g_ml\n                  00\n0.0%\n0.1\n0.1\n0.0\n    \npendiente\n                  0.000.31\n0.0%\n0.0\n0.0\n0.0\n    \npendiente_2\n                  025\n3.2%\n5.2\n4.6\n4.2"
  },
  {
    "objectID": "3_Data_import.html#exportar-datos",
    "href": "3_Data_import.html#exportar-datos",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "Una vez terminado nuestro análisis debemos guardarlo. Siguiendo la recomendación que vimos anteriormente, lo ideal es guardar los datos ya procesados (ya sea que se haya realizado algún tipo de filtrado o transformación) en una carpeta diferente a la carpeta donde están los datos crudos, los cuales se recomienda que se preserven sin alteraciones.\nPodemos crear una nueva carpeta con Archivos &gt; Nuevo directorio o desde la línea de comando usando la función dir.create()\n\ndir.create(\"resultados/tablas\", recursive = TRUE)\n\nWarning in dir.create(\"resultados/tablas\", recursive = TRUE):\n'resultados\\tablas' already exists\n\n\nPara guardar nuestros datos, las funciones que utilizaremos mas frecuentemente son write.table y write_csv()\nPor ejemplo, vamos a tomar las primeras filas de nuestro objeto excel_clean con la función head()\n\nexcel_subset &lt;- head(excel_clean)\nexcel_subset\n\n# A tibble: 6 × 10\n  numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n  &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n1 Hf100U                                3          24          18         0.093\n2 Hf100U                                3          24          18         0.093\n3 Hf100U                                3          24          32         0.093\n4 Hf100U                                3          24          32         0.093\n5 Hf101U                                3          30          18         0.114\n6 Hf101U                                3          30          18         0.114\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\nAhora lo guardamos en la carpeta que acabamos de crear usando la función write_csv()\n\nwrite_csv(excel_subset, file = \"resultados/tablas/excel_subset.csv\")\n\no con write.table() la cual nos permite usar una mayor diversidad de formatos\n\nwrite.table(excel_subset, file = \"resultados/tablas/excel_subset.txt\", sep = \"\\t\")"
  },
  {
    "objectID": "4_data_wrangling.html",
    "href": "4_data_wrangling.html",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "",
    "text": "Tidy Data es un concepto fundamental dentro del ecosistema Tidyverse en R que se centra en la organización y manipulación eficiente de datos para análisis y visualización.\nEn el contexto de Tidy Data, se busca estructurar los conjuntos de datos de manera que cada observación sea una fila, cada variable sea una columna y cada valor tenga su propia celda. Esto permite que los datos estén organizados en un formato uniforme y consistente, lo que facilita su manipulación y análisis. En resumen, los principios de Tidy Data son:\nEn resumen, un tidy data sigue las siguientes características:\n\nCada variable debe tener su propia columna\nCada observación debe tener su propia fila\nCada valor debe tener su propia celda"
  },
  {
    "objectID": "4_data_wrangling.html#seleccinar-columnas-con-select",
    "href": "4_data_wrangling.html#seleccinar-columnas-con-select",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "Seleccinar columnas con select()",
    "text": "Seleccinar columnas con select()\nPermite seleccionar una o varias columnas de un tibble o data.frame.\nPor ejemplo, si queremos seleccionar solamente las columnas Name, y Attack\n\nselect(pokemon, name, attack)\n\n# A tibble: 801 × 2\n   name       attack\n   &lt;chr&gt;       &lt;dbl&gt;\n 1 Bulbasaur      49\n 2 Ivysaur        62\n 3 Venusaur      100\n 4 Charmander     52\n 5 Charmeleon     64\n 6 Charizard     104\n 7 Squirtle       48\n 8 Wartortle      63\n 9 Blastoise     103\n10 Caterpie       30\n# ℹ 791 more rows\n\n\nRecuerda que si queremos generar un nuevo objeto con ese subset de datos tenemos que asignarlo a otro objeto.\n\npokemon_sub &lt;- select(pokemon, name, attack)\npokemon_sub\n\n# A tibble: 801 × 2\n   name       attack\n   &lt;chr&gt;       &lt;dbl&gt;\n 1 Bulbasaur      49\n 2 Ivysaur        62\n 3 Venusaur      100\n 4 Charmander     52\n 5 Charmeleon     64\n 6 Charizard     104\n 7 Squirtle       48\n 8 Wartortle      63\n 9 Blastoise     103\n10 Caterpie       30\n# ℹ 791 more rows\n\n\nCon select() tambien podemos seleccionar todo menos una columna especifica con el operador -\n\npokemon_sub &lt;- select(pokemon, -attack)\npokemon_sub\n\n# A tibble: 801 × 12\n   pokedex_number name  defense    hp percentage_male sp_attack sp_defense speed\n            &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n 1              1 Bulb…      49    45            88.1        65         65    45\n 2              2 Ivys…      63    60            88.1        80         80    60\n 3              3 Venu…     123    80            88.1       122        120    80\n 4              4 Char…      43    39            88.1        60         50    65\n 5              5 Char…      58    58            88.1        80         65    80\n 6              6 Char…      78    78            88.1       159        115   100\n 7              7 Squi…      65    44            88.1        50         64    43\n 8              8 Wart…      80    59            88.1        65         80    58\n 9              9 Blas…     120    79            88.1       135        115    78\n10             10 Cate…      35    45            50          20         20    45\n# ℹ 791 more rows\n# ℹ 4 more variables: type1 &lt;chr&gt;, weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;,\n#   is_legendary &lt;dbl&gt;\n\n\no podemos seleccionar un intervalo de columnas\n\npokemon_sub &lt;- select(pokemon, name, attack:hp)\n\no lo inverso para descargar un intervalo de columnas\n\npokemon_sub &lt;- select(pokemon, -(attack:hp))"
  },
  {
    "objectID": "4_data_wrangling.html#seleccionar-columnas-con-select",
    "href": "4_data_wrangling.html#seleccionar-columnas-con-select",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "2.1 Seleccionar columnas con select()",
    "text": "2.1 Seleccionar columnas con select()\nPermite seleccionar una o varias columnas de un tibble o data.frame.\nPor ejemplo, si queremos seleccionar solamente las columnas Name, y Attack\n\nselect(pokemon, name, attack)\n\n# A tibble: 801 × 2\n   name       attack\n   &lt;chr&gt;       &lt;dbl&gt;\n 1 Bulbasaur      49\n 2 Ivysaur        62\n 3 Venusaur      100\n 4 Charmander     52\n 5 Charmeleon     64\n 6 Charizard     104\n 7 Squirtle       48\n 8 Wartortle      63\n 9 Blastoise     103\n10 Caterpie       30\n# ℹ 791 more rows\n\n\nRecuerda que si queremos generar un nuevo objeto con ese subset de datos tenemos que asignarlo a otro objeto.\n\npokemon_sub &lt;- select(pokemon, name, attack)\npokemon_sub\n\n# A tibble: 801 × 2\n   name       attack\n   &lt;chr&gt;       &lt;dbl&gt;\n 1 Bulbasaur      49\n 2 Ivysaur        62\n 3 Venusaur      100\n 4 Charmander     52\n 5 Charmeleon     64\n 6 Charizard     104\n 7 Squirtle       48\n 8 Wartortle      63\n 9 Blastoise     103\n10 Caterpie       30\n# ℹ 791 more rows\n\n\nCon select() tambien podemos seleccionar todo menos una columna especifica con el operador -\n\npokemon_sub &lt;- select(pokemon, -attack)\npokemon_sub\n\n# A tibble: 801 × 12\n   pokedex_number name  defense    hp percentage_male sp_attack sp_defense speed\n            &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n 1              1 Bulb…      49    45            88.1        65         65    45\n 2              2 Ivys…      63    60            88.1        80         80    60\n 3              3 Venu…     123    80            88.1       122        120    80\n 4              4 Char…      43    39            88.1        60         50    65\n 5              5 Char…      58    58            88.1        80         65    80\n 6              6 Char…      78    78            88.1       159        115   100\n 7              7 Squi…      65    44            88.1        50         64    43\n 8              8 Wart…      80    59            88.1        65         80    58\n 9              9 Blas…     120    79            88.1       135        115    78\n10             10 Cate…      35    45            50          20         20    45\n# ℹ 791 more rows\n# ℹ 4 more variables: type1 &lt;chr&gt;, weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;,\n#   is_legendary &lt;dbl&gt;\n\n\no podemos seleccionar un intervalo de columnas\n\npokemon_sub &lt;- select(pokemon, name, attack:hp)\npokemon_sub\n\n# A tibble: 801 × 4\n   name       attack defense    hp\n   &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n 1 Bulbasaur      49      49    45\n 2 Ivysaur        62      63    60\n 3 Venusaur      100     123    80\n 4 Charmander     52      43    39\n 5 Charmeleon     64      58    58\n 6 Charizard     104      78    78\n 7 Squirtle       48      65    44\n 8 Wartortle      63      80    59\n 9 Blastoise     103     120    79\n10 Caterpie       30      35    45\n# ℹ 791 more rows\n\n\no lo inverso para descargar un intervalo de columnas\n\npokemon_sub &lt;- select(pokemon, -(attack:hp))\npokemon_sub\n\n# A tibble: 801 × 10\n   pokedex_number name       percentage_male sp_attack sp_defense speed type1\n            &lt;dbl&gt; &lt;chr&gt;                &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n 1              1 Bulbasaur             88.1        65         65    45 grass\n 2              2 Ivysaur               88.1        80         80    60 grass\n 3              3 Venusaur              88.1       122        120    80 grass\n 4              4 Charmander            88.1        60         50    65 fire \n 5              5 Charmeleon            88.1        80         65    80 fire \n 6              6 Charizard             88.1       159        115   100 fire \n 7              7 Squirtle              88.1        50         64    43 water\n 8              8 Wartortle             88.1        65         80    58 water\n 9              9 Blastoise             88.1       135        115    78 water\n10             10 Caterpie              50          20         20    45 bug  \n# ℹ 791 more rows\n# ℹ 3 more variables: weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\nLa función everything() se puede seleccionar todo, y con esto es factible combiar el orden de las columnas. Por ejemplo, si queremos que la primera columna sea type ejecutamos:\n\nselect(pokemon, type1, everything())\n\n# A tibble: 801 × 13\n   type1 pokedex_number name      attack defense    hp percentage_male sp_attack\n   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1 grass              1 Bulbasaur     49      49    45            88.1        65\n 2 grass              2 Ivysaur       62      63    60            88.1        80\n 3 grass              3 Venusaur     100     123    80            88.1       122\n 4 fire               4 Charmand…     52      43    39            88.1        60\n 5 fire               5 Charmele…     64      58    58            88.1        80\n 6 fire               6 Charizard    104      78    78            88.1       159\n 7 water              7 Squirtle      48      65    44            88.1        50\n 8 water              8 Wartortle     63      80    59            88.1        65\n 9 water              9 Blastoise    103     120    79            88.1       135\n10 bug               10 Caterpie      30      35    45            50          20\n# ℹ 791 more rows\n# ℹ 5 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, weight_kg &lt;dbl&gt;,\n#   generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n2.1.1 Seleccionar variables con un patrón\nEstas funcionen ayudad a seleccionar variables según un patrón determinado\n\nstarts_with(): Inicia con un prefijo exacto\nends_with(): Finaliza con un sufijo exacto\ncontains(): Contiene una cadena literal\n\nPor ejemplo, podemos seleccionar las columnas de Sp attack y Sp deffense utilizando el prefijo sp\n\nselect(pokemon, name, starts_with(\"sp_\"))\n\n# A tibble: 801 × 3\n   name       sp_attack sp_defense\n   &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt;\n 1 Bulbasaur         65         65\n 2 Ivysaur           80         80\n 3 Venusaur         122        120\n 4 Charmander        60         50\n 5 Charmeleon        80         65\n 6 Charizard        159        115\n 7 Squirtle          50         64\n 8 Wartortle         65         80\n 9 Blastoise        135        115\n10 Caterpie          20         20\n# ℹ 791 more rows\n\n\nO podemos seleccionar las variables relacionadas con ataque (attack)\n\nselect(pokemon, name, contains(\"attack\"))\n\n# A tibble: 801 × 3\n   name       attack sp_attack\n   &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n 1 Bulbasaur      49        65\n 2 Ivysaur        62        80\n 3 Venusaur      100       122\n 4 Charmander     52        60\n 5 Charmeleon     64        80\n 6 Charizard     104       159\n 7 Squirtle       48        50\n 8 Wartortle      63        65\n 9 Blastoise     103       135\n10 Caterpie       30        20\n# ℹ 791 more rows"
  },
  {
    "objectID": "4_data_wrangling.html#seleccionar-variables-con-un-patrón",
    "href": "4_data_wrangling.html#seleccionar-variables-con-un-patrón",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "2.2 Seleccionar variables con un patrón",
    "text": "2.2 Seleccionar variables con un patrón\nEstas funcionen ayudad a seleccionar variables según un patrón determinado\n\nstarts_with(): Inicia con un prefijo exacto\nends_with(): Finaliza con un sufijo exacto\ncontains(): Contiene una cadena literal"
  },
  {
    "objectID": "4_data_wrangling.html#filtrar-variables-con-filter",
    "href": "4_data_wrangling.html#filtrar-variables-con-filter",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "2.2 Filtrar variables con filter()",
    "text": "2.2 Filtrar variables con filter()\n\nLa función filter() nos permite filtrar los elementos de una variable (columna) que cumplan con una condición especifica.\nPor ejemplo, para filtrar pokemon que tengan un nivel de ataque (Attack) superior a 100 usariamos\n\nfilter(pokemon, attack &gt; 100)\n\n# A tibble: 169 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              6 Charizard     104      78    78            88.1       159\n 2              9 Blastoise     103     120    79            88.1       135\n 3             15 Beedrill      150      40    65            50          15\n 4             34 Nidoking      102      77    81           100          85\n 5             57 Primeape      105      60    65            50          60\n 6             59 Arcanine      110      80    90            75.4       100\n 7             68 Machamp       130      80    90            75.4        65\n 8             71 Victreebel    105      65    80            50         100\n 9             76 Golem         120     130    80            50          55\n10             85 Dodrio        110      70    60            50          60\n# ℹ 159 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\nPara establecer varios condiciones, simplemente las podemos separar por una ,. Por ejemplo, si queremos filtrar a los pokemon que tengan un nivel de ataque mayor a 100 y que sea de tipo fuego (fire)\n\nfilter(pokemon, attack &gt; 100, type1 == \"fire\")\n\n# A tibble: 11 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              6 Charizard     104      78    78            88.1       159\n 2             59 Arcanine      110      80    90            75.4       100\n 3            136 Flareon       130      60    65            88.1        95\n 4            244 Entei         115      85   115            NA          90\n 5            250 Ho-Oh         130      90   106            NA         110\n 6            257 Blaziken      160      80    80            88.1       130\n 7            323 Camerupt      120     100    70            50         145\n 8            392 Infernape     104      71    76            88.1       104\n 9            500 Emboar        123      65   110            88.1       100\n10            721 Volcanion     110     120    80            NA         130\n11            727 Incineroar    115      90    95            88.1        80\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\nTip\n\n\n\nSi tienes muchas condiciones, puedes escribir cada condición en una línea diferente para evitar líneas de código muy largas\n\nfilter(pokemon, attack &gt; 100,\n       type1 == \"fire\",\n       generation == 1, \n       speed &gt; 50)\n\n\n\nSi queremos filtrar distintas condiciones de una misma variable (columna) podemos usar el operador %in%.\nPor ejemplo, para filtar los pokemon que sean de tipo fuego y agua\n\nfilter(pokemon, type1 %in% c(\"fire\", \"water\"))\n\n# A tibble: 166 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              4 Charmander     52      43    39            88.1        60\n 2              5 Charmeleon     64      58    58            88.1        80\n 3              6 Charizard     104      78    78            88.1       159\n 4              7 Squirtle       48      65    44            88.1        50\n 5              8 Wartortle      63      80    59            88.1        65\n 6              9 Blastoise     103     120    79            88.1       135\n 7             37 Vulpix         41      40    38            24.6        50\n 8             38 Ninetales      67      75    73            24.6        81\n 9             54 Psyduck        52      48    50            50          65\n10             55 Golduck        82      78    80            50          95\n# ℹ 156 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\nNota\n\n\n\nSi tienes muchas condiciones o si tienes las mismas condiciones que quieres filtrar en distintos sets de datos, puedes hacer un vector y despues incorporarlo en la funcion filter. Por ejemplo\n\ntipos &lt;- c(\"fire\", \"normal\", \"water\")\n\nfilter(pokemon, type1 %in% tipos)\n\n# A tibble: 271 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              4 Charmander     52      43    39            88.1        60\n 2              5 Charmeleon     64      58    58            88.1        80\n 3              6 Charizard     104      78    78            88.1       159\n 4              7 Squirtle       48      65    44            88.1        50\n 5              8 Wartortle      63      80    59            88.1        65\n 6              9 Blastoise     103     120    79            88.1       135\n 7             16 Pidgey         45      40    40            50          35\n 8             17 Pidgeotto      60      55    63            50          50\n 9             18 Pidgeot        80      80    83            50         135\n10             19 Rattata        56      35    30            50          25\n# ℹ 261 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\nEs posbile filtrar un intervalo de valores utilizando la función between(). Esta función requiere como argumentos el nombre de la variable que queremos filtrar, el límite inferior y el límite superior.\nPor ejemplo, si queremos filtrar los pokemon que tengan un nivel de ataque (attack) mayor a 100 pero menor a 150\n\nfilter(pokemon, between(attack, 100, 150))\n\n# A tibble: 191 × 13\n   pokedex_number name      attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              3 Venusaur     100     123    80            88.1       122\n 2              6 Charizard    104      78    78            88.1       159\n 3              9 Blastoise    103     120    79            88.1       135\n 4             15 Beedrill     150      40    65            50          15\n 5             28 Sandslash    100     120    75            50          25\n 6             34 Nidoking     102      77    81           100          85\n 7             51 Dugtrio      100      60    35            50          50\n 8             57 Primeape     105      60    65            50          60\n 9             59 Arcanine     110      80    90            75.4       100\n10             67 Machoke      100      70    80            75.4        50\n# ℹ 181 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\nPodemos usar la operación opuesta utilizando el operado !\n\nfilter(pokemon, !between(attack, 100, 150))\n\n# A tibble: 610 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              1 Bulbasaur      49      49    45            88.1        65\n 2              2 Ivysaur        62      63    60            88.1        80\n 3              4 Charmander     52      43    39            88.1        60\n 4              5 Charmeleon     64      58    58            88.1        80\n 5              7 Squirtle       48      65    44            88.1        50\n 6              8 Wartortle      63      80    59            88.1        65\n 7             10 Caterpie       30      35    45            50          20\n 8             11 Metapod        20      55    50            50          25\n 9             12 Butterfree     45      50    60            50          90\n10             13 Weedle         35      50    40            50          20\n# ℹ 600 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\nEjercicio: ¿¡QUIEN ES ESE POKEMON!? 📣\n\n\n\n\n\n\n\n\nNuestro pokémon tiene un valor de HP entre 100 y 200; valor de velocidad menor a 50; es del tipo1 Normal; tiene un valor de defensa menor a 40 y pertenece a la primera generación\n\n\nver codigo\nfilter(pokemon, between(hp, 100, 200),\n       speed &lt; 50,\n       type1 == \"normal\",\n       defense &lt; 40,\n       generation == 1)\n\n\n\n\n\n2.2.1 Filtrar variables con un patrón\nTambien es posible filtrar una variable a partir de un caracter en especifico usando la función str_detect().\n\nfilter(pokemon, str_detect(name, \"eon\"))\n\n# A tibble: 13 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              5 Charmeleon     64      58    58            88.1        80\n 2            134 Vaporeon       65      60   130            88.1       110\n 3            135 Jolteon        65      60    65            88.1       110\n 4            136 Flareon       130      60    65            88.1        95\n 5            196 Espeon         65      60    65            88.1       130\n 6            197 Umbreon        65     110    95            88.1        60\n 7            352 Kecleon        90      70    60            50          60\n 8            395 Empoleon       86      88    84            88.1       111\n 9            456 Finneon        49      56    49            50          49\n10            457 Lumineon       69      76    69            50          69\n11            470 Leafeon       110     130    65            88.1        60\n12            471 Glaceon        60     110    65            88.1       130\n13            700 Sylveon        65      65    95            88.1       110\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\nEjercicio: Una galaxía muy lejana…\n\n\n\nAbre la tabla starwars que se encuentra en el directorio de databases y genera los siguientes objetos:\n\nUna tabla que incluya solamente el nombre del personaje y todas las variables relacionadas con colores.\nUna tabla que incluya solamente los personajes femeninos del planeta Naboo.\nUna tabla con los personajes que hayan aparecido en Attack of the Clones."
  },
  {
    "objectID": "4_data_wrangling.html#ejercicio-1-quien-es-ese-pokemon",
    "href": "4_data_wrangling.html#ejercicio-1-quien-es-ese-pokemon",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "2.3 Ejercicio 1: ¿¡QUIEN ES ESE POKEMON!? 📣",
    "text": "2.3 Ejercicio 1: ¿¡QUIEN ES ESE POKEMON!? 📣\n\n\n\n\n\nNuestro pokemon tiene un valor de HP entre 100 y 200; valor de velocidad menor a 50; es del tipo1 Normal; tiene un valor de defensa menor a 40 y pertenece a la primera generación\n\nfilter(pokemon, between(hp, 100, 200),\n       speed &lt; 50,\n       type1 == \"normal\",\n       defense &lt; 40,\n       generation == 1)\n\n# A tibble: 1 × 13\n  pokedex_number name  attack defense    hp percentage_male sp_attack sp_defense\n           &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n1             39 Jigg…     45      20   115            24.6        45         25\n# ℹ 5 more variables: speed &lt;dbl&gt;, type1 &lt;chr&gt;, weight_kg &lt;dbl&gt;,\n#   generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;"
  },
  {
    "objectID": "4_data_wrangling.html#ejercicio",
    "href": "4_data_wrangling.html#ejercicio",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "2.3 Ejercicio",
    "text": "2.3 Ejercicio\nAbre la tabla starwars que se encuentra en el directorio de databases y genera los siguientes objetos:\n\ntabla que incluya solamente el nombre del personaje y todas las variables relacionadas con colores.\nUna tabla ue incluya solamente los personajes femeninos del planeta Naboo.\nUna tabla con los personajes que hayan aparecido en Attack of the Clones."
  },
  {
    "objectID": "4_data_wrangling.html#transformar-o-crear-columnas-con-mutate",
    "href": "4_data_wrangling.html#transformar-o-crear-columnas-con-mutate",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "2.3 Transformar o crear columnas con mutate()",
    "text": "2.3 Transformar o crear columnas con mutate()\n\n\n\n\n\nLa función mutate() es una función versatil en el sentido que nos permite crear nuevas variables que contengan alguna operación a partir de las que ya tenemos, añadir una nueva variable o transformar una variable ya existente\nPor ejemplo, podemos generar una nueva columna llamada “at_df_ratio” con la propoción de los valores de Ataque sobre Defensa\n\npokemon_mutate &lt;- mutate(pokemon, at_df_ratio = attack/defense )\n\nhead(pokemon_mutate$at_df_ratio)\n\n[1] 1.0000000 0.9841270 0.8130081 1.2093023 1.1034483 1.3333333\n\n\nDe igual manera, se pueden generar diversas nuevas columnas en una misma función separadas por comas.\n\npokemon_mutate &lt;- mutate(pokemon, \n                         at_df_ratio = attack/defense,\n                         at_df_per = at_df_ratio * 100,\n                         nueva_col = \"nueva columna\")\n\npokemon_mutate\n\n# A tibble: 801 × 16\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              1 Bulbasaur      49      49    45            88.1        65\n 2              2 Ivysaur        62      63    60            88.1        80\n 3              3 Venusaur      100     123    80            88.1       122\n 4              4 Charmander     52      43    39            88.1        60\n 5              5 Charmeleon     64      58    58            88.1        80\n 6              6 Charizard     104      78    78            88.1       159\n 7              7 Squirtle       48      65    44            88.1        50\n 8              8 Wartortle      63      80    59            88.1        65\n 9              9 Blastoise     103     120    79            88.1       135\n10             10 Caterpie       30      35    45            50          20\n# ℹ 791 more rows\n# ℹ 9 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;, at_df_ratio &lt;dbl&gt;,\n#   at_df_per &lt;dbl&gt;, nueva_col &lt;chr&gt;\n\n\nCon mutate(), también es posible cambiar el tipo de dato de cada columna. Por ejemplo, cambiar la columna “Type1” de carácter a factor:\n\npokemon_mutate &lt;- mutate(pokemon, type1 = factor(type1))\npokemon_mutate\n\n# A tibble: 801 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              1 Bulbasaur      49      49    45            88.1        65\n 2              2 Ivysaur        62      63    60            88.1        80\n 3              3 Venusaur      100     123    80            88.1       122\n 4              4 Charmander     52      43    39            88.1        60\n 5              5 Charmeleon     64      58    58            88.1        80\n 6              6 Charizard     104      78    78            88.1       159\n 7              7 Squirtle       48      65    44            88.1        50\n 8              8 Wartortle      63      80    59            88.1        65\n 9              9 Blastoise     103     120    79            88.1       135\n10             10 Caterpie       30      35    45            50          20\n# ℹ 791 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;fct&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;"
  },
  {
    "objectID": "4_data_wrangling.html#operaciones-agrupadas",
    "href": "4_data_wrangling.html#operaciones-agrupadas",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "4.1 Operaciones agrupadas",
    "text": "4.1 Operaciones agrupadas\nConsiderando la base de datos, seria mas informativo obtener el promedio por especie o por isla. La función group_by() permite agrupar los datos de acuerdo a alguna variable (factor).\nPor ejemplo, para obtener el peso promedio por especie:\n\npenguins %&gt;% \n  group_by(species) %&gt;% \n  summarise(promedio_peso = mean(body_mass_g, na.rm = TRUE))\n\n# A tibble: 3 × 2\n  species   promedio_peso\n  &lt;chr&gt;             &lt;dbl&gt;\n1 Adelie            3701.\n2 Chinstrap         3733.\n3 Gentoo            5076.\n\n\nPodemos agrupar utilizando mas variables separadas por una coma:\n\npenguins %&gt;% \n  group_by(island, species, sex) %&gt;% \n  summarise(promedio_peso = mean(body_mass_g, na.rm = TRUE),\n            desviacion = sd(body_mass_g, na.rm = TRUE),\n            N = n())\n\n`summarise()` has grouped output by 'island', 'species'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 13 × 6\n# Groups:   island, species [5]\n   island    species   sex    promedio_peso desviacion     N\n   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt;\n 1 Biscoe    Adelie    female         3369.       343.    22\n 2 Biscoe    Adelie    male           4050        356.    22\n 3 Biscoe    Gentoo    female         4680.       282.    58\n 4 Biscoe    Gentoo    male           5485.       313.    61\n 5 Biscoe    Gentoo    &lt;NA&gt;           4588.       338.     5\n 6 Dream     Adelie    female         3344.       212.    27\n 7 Dream     Adelie    male           4046.       331.    28\n 8 Dream     Adelie    &lt;NA&gt;           2975         NA      1\n 9 Dream     Chinstrap female         3527.       285.    34\n10 Dream     Chinstrap male           3939.       362.    34\n11 Torgersen Adelie    female         3396.       259.    24\n12 Torgersen Adelie    male           4035.       372.    23\n13 Torgersen Adelie    &lt;NA&gt;           3681.       413.     5\n\n\nExisten otras funciones útiles por las que nos podría interesar agrupar\n\ncount()\nmean()\nmedian()\nmin()\nmax()\nquantile(x, 0.25)\nIQR()\n\nEl uso de la función group_by() tambien nos permite transformar una variable e incluirla en una columna en conjunto con la función mutate()\n\npenguins %&gt;% \n  group_by(species, island,sex) %&gt;% \n  mutate(promedio_peso_grupo = mean(body_mass_g, na.rm = TRUE)) %&gt;% \n  select(promedio_peso_grupo, everything())\n\n# A tibble: 344 × 9\n# Groups:   species, island, sex [13]\n   promedio_peso_grupo species island    bill_length_mm bill_depth_mm\n                 &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;\n 1               4035. Adelie  Torgersen           39.1          18.7\n 2               3396. Adelie  Torgersen           39.5          17.4\n 3               3396. Adelie  Torgersen           40.3          18  \n 4               3681. Adelie  Torgersen           NA            NA  \n 5               3396. Adelie  Torgersen           36.7          19.3\n 6               4035. Adelie  Torgersen           39.3          20.6\n 7               3396. Adelie  Torgersen           38.9          17.8\n 8               4035. Adelie  Torgersen           39.2          19.6\n 9               3681. Adelie  Torgersen           34.1          18.1\n10               3681. Adelie  Torgersen           42            20.2\n# ℹ 334 more rows\n# ℹ 4 more variables: flipper_length_mm &lt;dbl&gt;, body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;,\n#   year &lt;dbl&gt;"
  },
  {
    "objectID": "4_data_wrangling.html#resumir-todas-las-variables-con-summarise_all",
    "href": "4_data_wrangling.html#resumir-todas-las-variables-con-summarise_all",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "4.2 Resumir todas las variables con summarise_all()",
    "text": "4.2 Resumir todas las variables con summarise_all()\nLa función summarise_all() requiere una función como argumento, la cual aplica a todas las columnas de la tabla. En este ejemplo se agrego el argumento na.rm = TRUE el cual ignora los NAs\n\npenguins %&gt;% \n  group_by(species, island, sex) %&gt;% \n  summarise_all(mean, na.rm = TRUE) \n\n# A tibble: 13 × 8\n# Groups:   species, island [5]\n   species   island    sex    bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1 Adelie    Biscoe    female           37.4          17.7              187.\n 2 Adelie    Biscoe    male             40.6          19.0              190.\n 3 Adelie    Dream     female           36.9          17.6              188.\n 4 Adelie    Dream     male             40.1          18.8              192.\n 5 Adelie    Dream     &lt;NA&gt;             37.5          18.9              179 \n 6 Adelie    Torgersen female           37.6          17.6              188.\n 7 Adelie    Torgersen male             40.6          19.4              195.\n 8 Adelie    Torgersen &lt;NA&gt;             37.9          18.2              187.\n 9 Chinstrap Dream     female           46.6          17.6              192.\n10 Chinstrap Dream     male             51.1          19.3              200.\n11 Gentoo    Biscoe    female           45.6          14.2              213.\n12 Gentoo    Biscoe    male             49.5          15.7              222.\n13 Gentoo    Biscoe    &lt;NA&gt;             45.6          14.6              216.\n# ℹ 2 more variables: body_mass_g &lt;dbl&gt;, year &lt;dbl&gt;"
  },
  {
    "objectID": "3.Data_import.html",
    "href": "3.Data_import.html",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "La importación de archivos de texto es el primer paso y parte fundamental para la exploración de datos. Sin embargo, también puede llegar a ser una tarea complicada.\nLos tipos de archivos mas comunes con los que solemos trabajar son:\n\nComa-separated values (csv)\nTab-separated values (tsv)\nExcel (xls)\nArchivo de texto simple (txt)\n\n\n\nPara importar un archivo a nuestro ambiente podemos utilizar las funciones base read.table, read.csv, read.delim. Por ejemplo, para abrir un archivo txt separado por tabuladores utilizando la función:\n\ndf &lt;- read.table(\"data/palmer_penguins.txt\", header = TRUE, sep = \"\\t\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007\n\n\no usando read.csv\n\ndf &lt;- read.csv(\"data/palmer_penguins.csv\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007\n\n\n\n\n\nDentro del Tidyverse, la importación de datos rectangulares se realiza con el paquete readr el cual tiene funciones que van a sonar muy familiares:\n\nread_csv(): comma-separated values (CSV)\nread_tsv(): tab-separated values (TSV)\nread_csv2(): semicolon-separated values with , as the decimal mark\nread_delim(): delimited files (CSV and TSV are important special cases)\nread_table(): whitespace-separated files\n\n\n\n\n\n\n\n¿Has notado algo? 🧐\n\n\n\nComo ves, los nombres de las funciones son muy parecidas a las funciones base pero reemplazando el “.” por un “_”. Esta tendencia se repite en numerosas funciones que siguen la filosofía tidy. Por ejemplo, en lugar de la prueba shapiro.test, rstatix utiliza la función shapiro_test.\n\n\nHagamos la prueba…\n\nlibrary(tidyverse)\nlibrary(here)\n\n\ndf &lt;- read_table(\"data/palmer_penguins.txt\")\n\n\n── Column specification ────────────────────────────────────────────────────────\ncols(\n  species = col_character(),\n  island = col_character(),\n  bill_length_mm = col_double(),\n  bill_depth_mm = col_double(),\n  flipper_length_mm = col_double(),\n  body_mass_g = col_double(),\n  sex = col_character(),\n  year = col_double()\n)\n\n\nObserva como, aún antes de desplegar la tabla,read_table ya nos arroja información sobre la estructura de los datos y nos indica si cada columna es número, carácter o de otro tipo.\nAhora observa como se despliega la tabla\n\ndf\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\n\n\n\n¿double? ¿character? 😱\n\n\n\nEn caso de que no lo recuerdes, estos son los principales tipos de datos en R\n\n\n\nTipo\nDescripción\nEjemplo\n\n\nNumeric\ninterger números enteros\n0L, 1L\n\n\nNumeric\ndouble números reales\n1.0,\n\n\nLogic\nvalores booleanos\nTRUE, FALSE\n\n\nCharacter\ncadena de texto\n“Hola mundo”\n\n\nFactor\nrepresentan datos categóricos\nmacho, hembra\n\n\nDates\nFechas\n“2023-08-24”\n\n\n\n\n\n\n\n\nCon R base, la función read.table nos genera un data frame pero readr nos genera un tibble los cuales son una versión actualizada de un data frame.\nHay varias diferencias entre tibbles y data.frames. Puedes leer mas en la viñeta. Sin embargo, algunas de las diferencias mas notables son:\n\nEl tipo de entrada permanece inalterado: los data.frames son conocidos por tratar las cadenas de texto como factores; esto no sucederá con los tibbles.\nLos nombres de las variables permanecen inalterados: En R base, al crear data.frames se eliminan los espacios de los nombres, convirtiéndolos en puntos o agregando una “x” antes de los nombres de las columnas numéricas. Al crear tibbles, los nombres de las variables (columnas) no cambian.\nNo hay row.names() para un tibble: Los datos ordenados requieren que las variables se almacenen de manera consistente, eliminando la necesidad de nombres de filas. Los tibbles imprimen las primeras diez filas y columnas que caben en una pantalla: Imprimir un tibble en la pantalla nunca mostrará todo el enorme marco de datos. Por defecto, solo muestra lo que cabe en tu pantalla.\n\n\n\nSi tenemos datos rectangulares como data.frame podemos convertirlo facilmente a tibble con la función as_tibble()\nPor ejemplo, podemos:\n\nas_tibble(trees)\n\n# A tibble: 31 × 3\n   Girth Height Volume\n   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1   8.3     70   10.3\n 2   8.6     65   10.3\n 3   8.8     63   10.2\n 4  10.5     72   16.4\n 5  10.7     81   18.8\n 6  10.8     83   19.7\n 7  11       66   15.6\n 8  11       75   18.2\n 9  11.1     80   22.6\n10  11.2     75   19.9\n# ℹ 21 more rows\n\n\n\n\n\n\n\n\nWarning\n\n\n\nRecuerda que si solo ejecutamos el comando as_tibble(trees) R solo nos arrojará el resutlado en la consola pero no hizo ningún cambio al objeto trees. Para esto necesitamos renombrar o generar un nuevo objeto. Por ejemplo\n\ntrees_tbl &lt;- as_tibble(trees)\n\nahora si, tenemos un nuevo objetvo como tibble\n\nclass(trees)\n\n[1] \"data.frame\"\n\nclass(trees_tbl)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\nAl igual que como lo hariamos con un data.frame o una matriz, podemos acceder a las primeras o últimas filas de nuestro tibble con las funciones head() y tail()\n\nhead(df)\n\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\ntail(df)\n\n# A tibble: 6 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Chinstrap Dream            45.7          17                 195        3650\n2 Chinstrap Dream            55.8          19.8               207        4000\n3 Chinstrap Dream            43.5          18.1               202        3400\n4 Chinstrap Dream            49.6          18.2               193        3775\n5 Chinstrap Dream            50.8          19                 210        4100\n6 Chinstrap Dream            50.2          18.7               198        3775\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\nTambién es posible hacer tibble sobre la marcha utilizando la función tibble(). Por ejemplo:\n\nmi_tibl &lt;- tibble(\n  a = 1:5,\n  b = 6:10,\n  c = 1,\n  z = (a + b)^2 + c\n)\n\nmi_tibl\n\n# A tibble: 5 × 4\n      a     b     c     z\n  &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     6     1    50\n2     2     7     1    82\n3     3     8     1   122\n4     4     9     1   170\n5     5    10     1   226\n\n\nNota que al momento de generar este tibble, puedes hacer referencias a columnas del mismo tibble (columa z)\nOtro comportamiento de los tibbles es que es posible tener nombres de columnas con espacios u otros caracteres y estos estarán rodeados por ``\n\nmi_tibl &lt;- tibble(\n  `cinco números` = 1:5,\n  `12` = \"numeric\",\n  `:)` = \"smile\",\n)\n\nmi_tibl\n\n# A tibble: 5 × 3\n  `cinco números` `12`    `:)` \n            &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;\n1               1 numeric smile\n2               2 numeric smile\n3               3 numeric smile\n4               4 numeric smile\n5               5 numeric smile\n\n\n\n\n\n\nLas hojas de calculo de excel (formatos .xls o .xlsx) siguen siendo muy comunes y muy utilizados dentro de la comunidad académica.\nTidyverse no tiene dentro de su núcleo una función para importar este tipo de archivos, pero esto se soluciona fácilmente con el paquete readxl.\n\n\n\n\n\n\ninstall.packages(\"readxl\")\n\n\nlibrary(readxl)\n\nWarning: package 'readxl' was built under R version 4.3.1\n\n\nCon esto podemos usar la función read_excel() que no necesita ningún otro argumento mas que la ruta (path) donde se encuentra el archivo .xlsx\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\")\n\nexcel_df\n\n# A tibble: 405 × 9\n   `Sample ID` ExpNum TreatTemp Meas_Temp `WetWeight(g)` `buffer(ml)`\n   &lt;chr&gt;        &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;\n 1 Hf100U           3        24        18          0.093         0.93\n 2 Hf100U           3        24        18          0.093         0.93\n 3 Hf100U           3        24        32          0.093         0.93\n 4 Hf100U           3        24        32          0.093         0.93\n 5 Hf101U           3        30        18          0.114         1.14\n 6 Hf101U           3        30        18          0.114         1.14\n 7 Hf101U           3        30        32          0.114         1.14\n 8 Hf101U           3        30        32          0.114         1.14\n 9 Hf102U           3        30        18          0.092         0.92\n10 Hf102U           3        30        18          0.092         0.92\n# ℹ 395 more rows\n# ℹ 3 more variables: `MessVol(ul)` &lt;dbl&gt;, slopeTDH &lt;dbl&gt;, ActivityTDH &lt;dbl&gt;\n\n\nEn caso de que los datos de interes estén en una hoja en particular usamos el argumento sheet=\n\nexcel_df&lt;- read_excel(\"data/actividad_enzimas.xlsx\", sheet = \"hoja1\")\n\nUn caso mas complicado es cuando nuestro datos inician unas filas mas abajo y en un determinado intervalo de columnas. Otro caso común es que los nombres de las columnas tengan símbolos especiales o que estén repetidos\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", skip = 3, na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\nEn caso de que tengamos otra información que nos este generando conflicto podemos especificar el rango de datos de interés\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nHeterogeneidad en los nombres de las columna\n\n\n\nObserva como los tibbles permite que haya símbolos, espacios, acentos y alternancia de mayúsculas y minúsculas en los nombres de las columnas. Sin embargo, al momento de trabajar, esta heterogeneidad puede darnos problemas. Esto se puede solucionar con el paquete janitor.\n\n\n\n\n\n\n\n\n\n\nEl paquete Janitor es una herramienta pequeña pero increíblemente útil y conveniente cuando se trata de limpiar y mantener conjuntos de datos en RStudio. Además, es un paquete orientado a “tidyverse”, por lo que se integra perfectamente con los pipes.\nRegresemos a los nombres de las columnas de nuestro archivo excel antes de utilizar janitor\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\n\n\n [1] \"Número de muestra\"        \"Número de experimento\"   \n [3] \"Tratamiento\"              \"Temperatura\"             \n [5] \"peso húmedo (g)\"          \"buffer (ml)\"             \n [7] \"volumen de reaccion (ul)\" \"concentración g/ml\"      \n [9] \"pendiente...9\"            \"pendiente...10\"          \n\n\n\nNo hay consistencia entre el uso de mayúsculas y minúsculas en los nombres. Recuerda que R es sensible a mayúsculas, por lo que Temperatura no es lo mismo que temperatura.\nTenemos símbolos como acentos que nos pueden generar conflictos, sobre todo si tenemos símbolos en otros idiomas.\nLos espacios en blanco así como otros símbolos como / son reemplazados por un punto. Esto genera etiquetas complicadas.\n\nLo ideal es tener consistencia en el formato de las etiquetas. Algunos formatos conocidos son los siguientes:\n\n\n\n\n\nAhora utilicemos janitor para limpiar las etiquetas\n\nlibrary(janitor)\n\nWarning: package 'janitor' was built under R version 4.3.1\n\n\n\nAttaching package: 'janitor'\n\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\n\n\nexcel_clean &lt;- clean_names(excel_df)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente_9 &lt;dbl&gt;, pendiente_10 &lt;dbl&gt;\n\n\nlas opciones son:\n\n“snake”\n“small_camel”\n“big_camel”\n“screaming_snake”\n“parsed”\n“lower_upper”\n“upper_lower”\n\npor ejemplo:\n\nexcel_clean &lt;- clean_names(excel_df, case = \"screaming_snake\")\nexcel_clean\n\n# A tibble: 405 × 10\n   NUMERO_DE_MUESTRA NUMERO_DE_EXPERIMENTO TRATAMIENTO TEMPERATURA PESO_HUMEDO_G\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: BUFFER_ML &lt;dbl&gt;, VOLUMEN_DE_REACCION_UL &lt;dbl&gt;,\n#   CONCENTRACION_G_ML &lt;dbl&gt;, PENDIENTE_9 &lt;dbl&gt;, PENDIENTE_10 &lt;dbl&gt;\n\n\nCon janitor podemos integrar la función make_clean_name al momento de importar datos ya sea con readxl o con readr. Por ejemplo:\n\nexcel_clean &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\",\n                       .name_repair =  make_clean_names)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWarning\n\n\n\nObserva que tanto readxl como readr interpretan las columnas de número de experimento, tratamiento y temperatura como variables numéricas debido a que analizan la cantidad de datos para inferir el tipo de variable. No obstante, estas variables son en realidad factores, ya que representan categorías. Más adelante veremos cómo realizar este ajuste de manera manual.\n\n\n\n\n\nUn aspecto importante para el análisis de datos es tener una perspectiva rápida del tibble o datafram para entender las variables que tenemos, asi como los patrones generales de los datos.\nHay varias funciones que podemos utilizar. Ya mencionamos algunas herramienta como head() o tail() para echar un vistazo a las primeras o últimas filas de la tabla, respectivamente.\nOtra herramienta es la función glimpse() de dplyr que nos muestra algunos datos de cada columna de nuestro tibble para tener una idea de la estructura de la tabla.\n\nglimpse(excel_clean)\n\nRows: 405\nColumns: 10\n$ numero_de_muestra      &lt;chr&gt; \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf101U…\n$ numero_de_experimento  &lt;dbl&gt; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,…\n$ tratamiento            &lt;dbl&gt; 24, 24, 24, 24, 30, 30, 30, 30, 30, 30, 30, 30,…\n$ temperatura            &lt;dbl&gt; 18, 18, 32, 32, 18, 18, 32, 32, 18, 18, 32, 32,…\n$ peso_humedo_g          &lt;dbl&gt; 0.093, 0.093, 0.093, 0.093, 0.114, 0.114, 0.114…\n$ buffer_ml              &lt;dbl&gt; 0.93, 0.93, 0.93, 0.93, 1.14, 1.14, 1.14, 1.14,…\n$ volumen_de_reaccion_ul &lt;dbl&gt; 20, 10, 20, 10, 20, 10, 20, 10, 20, 10, 20, 10,…\n$ concentracion_g_ml     &lt;dbl&gt; 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.…\n$ pendiente              &lt;dbl&gt; 0.0331, 0.0145, 0.1431, 0.0653, 0.0354, 0.0155,…\n$ pendiente_2            &lt;dbl&gt; 2.660772, 2.331190, 11.503215, 10.498392, 2.845…\n\n\nLa función summary() es parte de las funciones base de R y es particularmente útil cuando tenemos datos continuos, ya que nos muestra, para cada columna, los valores mínimos, máximos, promedio, mediana y el 1er y 3er quartil.\n\nsummary(excel_clean)\n\n numero_de_muestra  numero_de_experimento  tratamiento     temperatura   \n Length:405         Min.   :1.000         Min.   :18.00   Min.   :18.00  \n Class :character   1st Qu.:2.000         1st Qu.:24.00   1st Qu.:18.00  \n Mode  :character   Median :3.000         Median :24.00   Median :18.00  \n                    Mean   :2.528         Mean   :26.04   Mean   :24.74  \n                    3rd Qu.:4.000         3rd Qu.:30.00   3rd Qu.:32.00  \n                    Max.   :4.000         Max.   :32.00   Max.   :32.00  \n                                                                         \n peso_humedo_g       buffer_ml      volumen_de_reaccion_ul concentracion_g_ml\n Min.   :0.02900   Min.   :0.2900   Min.   :10.00          Min.   :0.1       \n 1st Qu.:0.06700   1st Qu.:0.6700   1st Qu.:10.00          1st Qu.:0.1       \n Median :0.08500   Median :0.8500   Median :20.00          Median :0.1       \n Mean   :0.08387   Mean   :0.8387   Mean   :15.04          Mean   :0.1       \n 3rd Qu.:0.09900   3rd Qu.:0.9900   3rd Qu.:20.00          3rd Qu.:0.1       \n Max.   :0.18900   Max.   :1.8900   Max.   :20.00          Max.   :0.1       \n                                                                             \n   pendiente        pendiente_2    \n Min.   :0.00000   Min.   : 0.000  \n 1st Qu.:0.01480   1st Qu.: 1.632  \n Median :0.03500   Median : 4.594  \n Mean   :0.04949   Mean   : 5.205  \n 3rd Qu.:0.07290   3rd Qu.: 8.163  \n Max.   :0.31390   Max.   :25.233  \n                   NA's   :13      \n\n\nOtra herramienta un poco mas sofisticada pero bastante útil es la función gt_plt_summary() del paquete gtExtras, la cual nos permite gráficar cada una de las variables, nos muestra los valores promedio, mediana y desvicación, y ádemas nos muestra el % de valores faltantes (missing).\nPara utilizar esta herramienta, primero necesitamos instalar el paquete gtExtras y posteriormente cargar la librería.\n\ninstall.packages(\"gtExtras\")\n\n\nlibrary(gtExtras)\n\nWarning: package 'gtExtras' was built under R version 4.3.1\n\ngt_plt_summary(excel_clean)\n\nWarning: Computation failed in `stat_bin()`\nCaused by error in `bin_breaks_width()`:\n! The number of histogram bins must be less than 1,000,000.\nℹ Did you make `binwidth` too small?\n\n\n\n\n\n\n  \n    \n      excel_clean\n    \n    \n      405 rows x 10 cols\n    \n    \n      \n      Column\n      Plot Overview\n      Missing\n      Mean\n      Median\n      SD\n    \n  \n  \n    \nnumero_de_muestra\n                  96 categories\n0.0%\n—\n—\n—\n    \nnumero_de_experimento\n                  14\n0.0%\n2.5\n3.0\n1.1\n    \ntratamiento\n                  1832\n0.0%\n26.0\n24.0\n5.4\n    \ntemperatura\n                  1832\n0.0%\n24.7\n18.0\n7.0\n    \npeso_humedo_g\n                  0.030.19\n0.0%\n0.1\n0.1\n0.0\n    \nbuffer_ml\n                  0.31.9\n0.0%\n0.8\n0.8\n0.3\n    \nvolumen_de_reaccion_ul\n                  1020\n0.0%\n15.0\n20.0\n5.0\n    \nconcentracion_g_ml\n                  00\n0.0%\n0.1\n0.1\n0.0\n    \npendiente\n                  0.000.31\n0.0%\n0.0\n0.0\n0.0\n    \npendiente_2\n                  025\n3.2%\n5.2\n4.6\n4.2\n  \n  \n  \n\n\n\n\n\n\n\nUna vez terminado nuestro análisis debemos guardarlo. Siguiendo la recomendación que vimos anteriormente, lo ideal es guardar los datos ya procesados (ya sea que se haya realizado algún tipo de filtrado o transformación) en una carpeta diferente a la carpeta donde están los datos crudos, los cuales se recomienda que se preserven sin alteraciones.\nPodemos crear una nueva carpeta con Archivos &gt; Nuevo directorio o desde la línea de comando usando la función dir.create()\n\ndir.create(\"resultados/tablas\", recursive = TRUE)\n\nWarning in dir.create(\"resultados/tablas\", recursive = TRUE):\n'resultados\\tablas' already exists\n\n\nPara guardar nuestros datos, las funciones que utilizaremos mas frecuentemente son write.table y write_csv()\nPor ejemplo, vamos a tomar las primeras filas de nuestro objeto excel_clean con la función head()\n\nexcel_subset &lt;- head(excel_clean)\nexcel_subset\n\n# A tibble: 6 × 10\n  numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n  &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n1 Hf100U                                3          24          18         0.093\n2 Hf100U                                3          24          18         0.093\n3 Hf100U                                3          24          32         0.093\n4 Hf100U                                3          24          32         0.093\n5 Hf101U                                3          30          18         0.114\n6 Hf101U                                3          30          18         0.114\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\nAhora lo guardamos en la carpeta que acabamos de crear usando la función write_csv()\n\nwrite_csv(excel_subset, file = \"resultados/tablas/excel_subset.csv\")\n\no con write.table() la cual nos permite usar una mayor diversidad de formatos\n\nwrite.table(excel_subset, file = \"resultados/tablas/excel_subset.txt\", sep = \"\\t\")"
  },
  {
    "objectID": "3.Data_import.html#funciones-base-para-importar-archivos",
    "href": "3.Data_import.html#funciones-base-para-importar-archivos",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "Para importar un archivo a nuestro ambiente podemos utilizar las funciones base read.table, read.csv, read.delim. Por ejemplo, para abrir un archivo txt separado por tabuladores utilizando la función:\n\ndf &lt;- read.table(\"data/palmer_penguins.txt\", header = TRUE, sep = \"\\t\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007\n\n\no usando read.csv\n\ndf &lt;- read.csv(\"data/palmer_penguins.csv\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007"
  },
  {
    "objectID": "3.Data_import.html#importar-datos-a-lá-tidyverse",
    "href": "3.Data_import.html#importar-datos-a-lá-tidyverse",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "Dentro del Tidyverse, la importación de datos rectangulares se realiza con el paquete readr el cual tiene funciones que van a sonar muy familiares:\n\nread_csv(): comma-separated values (CSV)\nread_tsv(): tab-separated values (TSV)\nread_csv2(): semicolon-separated values with , as the decimal mark\nread_delim(): delimited files (CSV and TSV are important special cases)\nread_table(): whitespace-separated files\n\n\n\n\n\n\n\n¿Has notado algo? 🧐\n\n\n\nComo ves, los nombres de las funciones son muy parecidas a las funciones base pero reemplazando el “.” por un “_”. Esta tendencia se repite en numerosas funciones que siguen la filosofía tidy. Por ejemplo, en lugar de la prueba shapiro.test, rstatix utiliza la función shapiro_test.\n\n\nHagamos la prueba…\n\nlibrary(tidyverse)\nlibrary(here)\n\n\ndf &lt;- read_table(\"data/palmer_penguins.txt\")\n\n\n── Column specification ────────────────────────────────────────────────────────\ncols(\n  species = col_character(),\n  island = col_character(),\n  bill_length_mm = col_double(),\n  bill_depth_mm = col_double(),\n  flipper_length_mm = col_double(),\n  body_mass_g = col_double(),\n  sex = col_character(),\n  year = col_double()\n)\n\n\nObserva como, aún antes de desplegar la tabla,read_table ya nos arroja información sobre la estructura de los datos y nos indica si cada columna es número, carácter o de otro tipo.\nAhora observa como se despliega la tabla\n\ndf\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\n\n\n\n¿double? ¿character? 😱\n\n\n\nEn caso de que no lo recuerdes, estos son los principales tipos de datos en R\n\n\n\nTipo\nDescripción\nEjemplo\n\n\nNumeric\ninterger números enteros\n0L, 1L\n\n\nNumeric\ndouble números reales\n1.0,\n\n\nLogic\nvalores booleanos\nTRUE, FALSE\n\n\nCharacter\ncadena de texto\n“Hola mundo”\n\n\nFactor\nrepresentan datos categóricos\nmacho, hembra\n\n\nDates\nFechas\n“2023-08-24”"
  },
  {
    "objectID": "3.Data_import.html#tibbles",
    "href": "3.Data_import.html#tibbles",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "Con R base, la función read.table nos genera un data frame pero readr nos genera un tibble los cuales son una versión actualizada de un data frame.\nHay varias diferencias entre tibbles y data.frames. Puedes leer mas en la viñeta. Sin embargo, algunas de las diferencias mas notables son:\n\nEl tipo de entrada permanece inalterado: los data.frames son conocidos por tratar las cadenas de texto como factores; esto no sucederá con los tibbles.\nLos nombres de las variables permanecen inalterados: En R base, al crear data.frames se eliminan los espacios de los nombres, convirtiéndolos en puntos o agregando una “x” antes de los nombres de las columnas numéricas. Al crear tibbles, los nombres de las variables (columnas) no cambian.\nNo hay row.names() para un tibble: Los datos ordenados requieren que las variables se almacenen de manera consistente, eliminando la necesidad de nombres de filas. Los tibbles imprimen las primeras diez filas y columnas que caben en una pantalla: Imprimir un tibble en la pantalla nunca mostrará todo el enorme marco de datos. Por defecto, solo muestra lo que cabe en tu pantalla.\n\n\n\nSi tenemos datos rectangulares como data.frame podemos convertirlo facilmente a tibble con la función as_tibble()\nPor ejemplo, podemos:\n\nas_tibble(trees)\n\n# A tibble: 31 × 3\n   Girth Height Volume\n   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1   8.3     70   10.3\n 2   8.6     65   10.3\n 3   8.8     63   10.2\n 4  10.5     72   16.4\n 5  10.7     81   18.8\n 6  10.8     83   19.7\n 7  11       66   15.6\n 8  11       75   18.2\n 9  11.1     80   22.6\n10  11.2     75   19.9\n# ℹ 21 more rows\n\n\n\n\n\n\n\n\nWarning\n\n\n\nRecuerda que si solo ejecutamos el comando as_tibble(trees) R solo nos arrojará el resutlado en la consola pero no hizo ningún cambio al objeto trees. Para esto necesitamos renombrar o generar un nuevo objeto. Por ejemplo\n\ntrees_tbl &lt;- as_tibble(trees)\n\nahora si, tenemos un nuevo objetvo como tibble\n\nclass(trees)\n\n[1] \"data.frame\"\n\nclass(trees_tbl)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\nAl igual que como lo hariamos con un data.frame o una matriz, podemos acceder a las primeras o últimas filas de nuestro tibble con las funciones head() y tail()\n\nhead(df)\n\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\ntail(df)\n\n# A tibble: 6 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Chinstrap Dream            45.7          17                 195        3650\n2 Chinstrap Dream            55.8          19.8               207        4000\n3 Chinstrap Dream            43.5          18.1               202        3400\n4 Chinstrap Dream            49.6          18.2               193        3775\n5 Chinstrap Dream            50.8          19                 210        4100\n6 Chinstrap Dream            50.2          18.7               198        3775\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\nTambién es posible hacer tibble sobre la marcha utilizando la función tibble(). Por ejemplo:\n\nmi_tibl &lt;- tibble(\n  a = 1:5,\n  b = 6:10,\n  c = 1,\n  z = (a + b)^2 + c\n)\n\nmi_tibl\n\n# A tibble: 5 × 4\n      a     b     c     z\n  &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     6     1    50\n2     2     7     1    82\n3     3     8     1   122\n4     4     9     1   170\n5     5    10     1   226\n\n\nNota que al momento de generar este tibble, puedes hacer referencias a columnas del mismo tibble (columa z)\nOtro comportamiento de los tibbles es que es posible tener nombres de columnas con espacios u otros caracteres y estos estarán rodeados por ``\n\nmi_tibl &lt;- tibble(\n  `cinco números` = 1:5,\n  `12` = \"numeric\",\n  `:)` = \"smile\",\n)\n\nmi_tibl\n\n# A tibble: 5 × 3\n  `cinco números` `12`    `:)` \n            &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;\n1               1 numeric smile\n2               2 numeric smile\n3               3 numeric smile\n4               4 numeric smile\n5               5 numeric smile"
  },
  {
    "objectID": "3.Data_import.html#importar-desde-excel",
    "href": "3.Data_import.html#importar-desde-excel",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "Las hojas de calculo de excel (formatos .xls o .xlsx) siguen siendo muy comunes y muy utilizados dentro de la comunidad académica.\nTidyverse no tiene dentro de su núcleo una función para importar este tipo de archivos, pero esto se soluciona fácilmente con el paquete readxl.\n\n\n\n\n\n\ninstall.packages(\"readxl\")\n\n\nlibrary(readxl)\n\nWarning: package 'readxl' was built under R version 4.3.1\n\n\nCon esto podemos usar la función read_excel() que no necesita ningún otro argumento mas que la ruta (path) donde se encuentra el archivo .xlsx\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\")\n\nexcel_df\n\n# A tibble: 405 × 9\n   `Sample ID` ExpNum TreatTemp Meas_Temp `WetWeight(g)` `buffer(ml)`\n   &lt;chr&gt;        &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;\n 1 Hf100U           3        24        18          0.093         0.93\n 2 Hf100U           3        24        18          0.093         0.93\n 3 Hf100U           3        24        32          0.093         0.93\n 4 Hf100U           3        24        32          0.093         0.93\n 5 Hf101U           3        30        18          0.114         1.14\n 6 Hf101U           3        30        18          0.114         1.14\n 7 Hf101U           3        30        32          0.114         1.14\n 8 Hf101U           3        30        32          0.114         1.14\n 9 Hf102U           3        30        18          0.092         0.92\n10 Hf102U           3        30        18          0.092         0.92\n# ℹ 395 more rows\n# ℹ 3 more variables: `MessVol(ul)` &lt;dbl&gt;, slopeTDH &lt;dbl&gt;, ActivityTDH &lt;dbl&gt;\n\n\nEn caso de que los datos de interes estén en una hoja en particular usamos el argumento sheet=\n\nexcel_df&lt;- read_excel(\"data/actividad_enzimas.xlsx\", sheet = \"hoja1\")\n\nUn caso mas complicado es cuando nuestro datos inician unas filas mas abajo y en un determinado intervalo de columnas. Otro caso común es que los nombres de las columnas tengan símbolos especiales o que estén repetidos\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", skip = 3, na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\nEn caso de que tengamos otra información que nos este generando conflicto podemos especificar el rango de datos de interés\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nHeterogeneidad en los nombres de las columna\n\n\n\nObserva como los tibbles permite que haya símbolos, espacios, acentos y alternancia de mayúsculas y minúsculas en los nombres de las columnas. Sin embargo, al momento de trabajar, esta heterogeneidad puede darnos problemas. Esto se puede solucionar con el paquete janitor."
  },
  {
    "objectID": "3.Data_import.html#limpiar-etiquetas-con-janitor",
    "href": "3.Data_import.html#limpiar-etiquetas-con-janitor",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "El paquete Janitor es una herramienta pequeña pero increíblemente útil y conveniente cuando se trata de limpiar y mantener conjuntos de datos en RStudio. Además, es un paquete orientado a “tidyverse”, por lo que se integra perfectamente con los pipes.\nRegresemos a los nombres de las columnas de nuestro archivo excel antes de utilizar janitor\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\n\n\n [1] \"Número de muestra\"        \"Número de experimento\"   \n [3] \"Tratamiento\"              \"Temperatura\"             \n [5] \"peso húmedo (g)\"          \"buffer (ml)\"             \n [7] \"volumen de reaccion (ul)\" \"concentración g/ml\"      \n [9] \"pendiente...9\"            \"pendiente...10\"          \n\n\n\nNo hay consistencia entre el uso de mayúsculas y minúsculas en los nombres. Recuerda que R es sensible a mayúsculas, por lo que Temperatura no es lo mismo que temperatura.\nTenemos símbolos como acentos que nos pueden generar conflictos, sobre todo si tenemos símbolos en otros idiomas.\nLos espacios en blanco así como otros símbolos como / son reemplazados por un punto. Esto genera etiquetas complicadas.\n\nLo ideal es tener consistencia en el formato de las etiquetas. Algunos formatos conocidos son los siguientes:\n\n\n\n\n\nAhora utilicemos janitor para limpiar las etiquetas\n\nlibrary(janitor)\n\nWarning: package 'janitor' was built under R version 4.3.1\n\n\n\nAttaching package: 'janitor'\n\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\n\n\nexcel_clean &lt;- clean_names(excel_df)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente_9 &lt;dbl&gt;, pendiente_10 &lt;dbl&gt;\n\n\nlas opciones son:\n\n“snake”\n“small_camel”\n“big_camel”\n“screaming_snake”\n“parsed”\n“lower_upper”\n“upper_lower”\n\npor ejemplo:\n\nexcel_clean &lt;- clean_names(excel_df, case = \"screaming_snake\")\nexcel_clean\n\n# A tibble: 405 × 10\n   NUMERO_DE_MUESTRA NUMERO_DE_EXPERIMENTO TRATAMIENTO TEMPERATURA PESO_HUMEDO_G\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: BUFFER_ML &lt;dbl&gt;, VOLUMEN_DE_REACCION_UL &lt;dbl&gt;,\n#   CONCENTRACION_G_ML &lt;dbl&gt;, PENDIENTE_9 &lt;dbl&gt;, PENDIENTE_10 &lt;dbl&gt;\n\n\nCon janitor podemos integrar la función make_clean_name al momento de importar datos ya sea con readxl o con readr. Por ejemplo:\n\nexcel_clean &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\",\n                       .name_repair =  make_clean_names)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWarning\n\n\n\nObserva que tanto readxl como readr interpretan las columnas de número de experimento, tratamiento y temperatura como variables numéricas debido a que analizan la cantidad de datos para inferir el tipo de variable. No obstante, estas variables son en realidad factores, ya que representan categorías. Más adelante veremos cómo realizar este ajuste de manera manual."
  },
  {
    "objectID": "3.Data_import.html#echando-un-vistado-a-los-datos",
    "href": "3.Data_import.html#echando-un-vistado-a-los-datos",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "Un aspecto importante para el análisis de datos es tener una perspectiva rápida del tibble o datafram para entender las variables que tenemos, asi como los patrones generales de los datos.\nHay varias funciones que podemos utilizar. Ya mencionamos algunas herramienta como head() o tail() para echar un vistazo a las primeras o últimas filas de la tabla, respectivamente.\nOtra herramienta es la función glimpse() de dplyr que nos muestra algunos datos de cada columna de nuestro tibble para tener una idea de la estructura de la tabla.\n\nglimpse(excel_clean)\n\nRows: 405\nColumns: 10\n$ numero_de_muestra      &lt;chr&gt; \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf101U…\n$ numero_de_experimento  &lt;dbl&gt; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,…\n$ tratamiento            &lt;dbl&gt; 24, 24, 24, 24, 30, 30, 30, 30, 30, 30, 30, 30,…\n$ temperatura            &lt;dbl&gt; 18, 18, 32, 32, 18, 18, 32, 32, 18, 18, 32, 32,…\n$ peso_humedo_g          &lt;dbl&gt; 0.093, 0.093, 0.093, 0.093, 0.114, 0.114, 0.114…\n$ buffer_ml              &lt;dbl&gt; 0.93, 0.93, 0.93, 0.93, 1.14, 1.14, 1.14, 1.14,…\n$ volumen_de_reaccion_ul &lt;dbl&gt; 20, 10, 20, 10, 20, 10, 20, 10, 20, 10, 20, 10,…\n$ concentracion_g_ml     &lt;dbl&gt; 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.…\n$ pendiente              &lt;dbl&gt; 0.0331, 0.0145, 0.1431, 0.0653, 0.0354, 0.0155,…\n$ pendiente_2            &lt;dbl&gt; 2.660772, 2.331190, 11.503215, 10.498392, 2.845…\n\n\nLa función summary() es parte de las funciones base de R y es particularmente útil cuando tenemos datos continuos, ya que nos muestra, para cada columna, los valores mínimos, máximos, promedio, mediana y el 1er y 3er quartil.\n\nsummary(excel_clean)\n\n numero_de_muestra  numero_de_experimento  tratamiento     temperatura   \n Length:405         Min.   :1.000         Min.   :18.00   Min.   :18.00  \n Class :character   1st Qu.:2.000         1st Qu.:24.00   1st Qu.:18.00  \n Mode  :character   Median :3.000         Median :24.00   Median :18.00  \n                    Mean   :2.528         Mean   :26.04   Mean   :24.74  \n                    3rd Qu.:4.000         3rd Qu.:30.00   3rd Qu.:32.00  \n                    Max.   :4.000         Max.   :32.00   Max.   :32.00  \n                                                                         \n peso_humedo_g       buffer_ml      volumen_de_reaccion_ul concentracion_g_ml\n Min.   :0.02900   Min.   :0.2900   Min.   :10.00          Min.   :0.1       \n 1st Qu.:0.06700   1st Qu.:0.6700   1st Qu.:10.00          1st Qu.:0.1       \n Median :0.08500   Median :0.8500   Median :20.00          Median :0.1       \n Mean   :0.08387   Mean   :0.8387   Mean   :15.04          Mean   :0.1       \n 3rd Qu.:0.09900   3rd Qu.:0.9900   3rd Qu.:20.00          3rd Qu.:0.1       \n Max.   :0.18900   Max.   :1.8900   Max.   :20.00          Max.   :0.1       \n                                                                             \n   pendiente        pendiente_2    \n Min.   :0.00000   Min.   : 0.000  \n 1st Qu.:0.01480   1st Qu.: 1.632  \n Median :0.03500   Median : 4.594  \n Mean   :0.04949   Mean   : 5.205  \n 3rd Qu.:0.07290   3rd Qu.: 8.163  \n Max.   :0.31390   Max.   :25.233  \n                   NA's   :13      \n\n\nOtra herramienta un poco mas sofisticada pero bastante útil es la función gt_plt_summary() del paquete gtExtras, la cual nos permite gráficar cada una de las variables, nos muestra los valores promedio, mediana y desvicación, y ádemas nos muestra el % de valores faltantes (missing).\nPara utilizar esta herramienta, primero necesitamos instalar el paquete gtExtras y posteriormente cargar la librería.\n\ninstall.packages(\"gtExtras\")\n\n\nlibrary(gtExtras)\n\nWarning: package 'gtExtras' was built under R version 4.3.1\n\ngt_plt_summary(excel_clean)\n\nWarning: Computation failed in `stat_bin()`\nCaused by error in `bin_breaks_width()`:\n! The number of histogram bins must be less than 1,000,000.\nℹ Did you make `binwidth` too small?\n\n\n\n\n\n\n  \n    \n      excel_clean\n    \n    \n      405 rows x 10 cols\n    \n    \n      \n      Column\n      Plot Overview\n      Missing\n      Mean\n      Median\n      SD\n    \n  \n  \n    \nnumero_de_muestra\n                  96 categories\n0.0%\n—\n—\n—\n    \nnumero_de_experimento\n                  14\n0.0%\n2.5\n3.0\n1.1\n    \ntratamiento\n                  1832\n0.0%\n26.0\n24.0\n5.4\n    \ntemperatura\n                  1832\n0.0%\n24.7\n18.0\n7.0\n    \npeso_humedo_g\n                  0.030.19\n0.0%\n0.1\n0.1\n0.0\n    \nbuffer_ml\n                  0.31.9\n0.0%\n0.8\n0.8\n0.3\n    \nvolumen_de_reaccion_ul\n                  1020\n0.0%\n15.0\n20.0\n5.0\n    \nconcentracion_g_ml\n                  00\n0.0%\n0.1\n0.1\n0.0\n    \npendiente\n                  0.000.31\n0.0%\n0.0\n0.0\n0.0\n    \npendiente_2\n                  025\n3.2%\n5.2\n4.6\n4.2"
  },
  {
    "objectID": "3.Data_import.html#exportar-datos",
    "href": "3.Data_import.html#exportar-datos",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "Una vez terminado nuestro análisis debemos guardarlo. Siguiendo la recomendación que vimos anteriormente, lo ideal es guardar los datos ya procesados (ya sea que se haya realizado algún tipo de filtrado o transformación) en una carpeta diferente a la carpeta donde están los datos crudos, los cuales se recomienda que se preserven sin alteraciones.\nPodemos crear una nueva carpeta con Archivos &gt; Nuevo directorio o desde la línea de comando usando la función dir.create()\n\ndir.create(\"resultados/tablas\", recursive = TRUE)\n\nWarning in dir.create(\"resultados/tablas\", recursive = TRUE):\n'resultados\\tablas' already exists\n\n\nPara guardar nuestros datos, las funciones que utilizaremos mas frecuentemente son write.table y write_csv()\nPor ejemplo, vamos a tomar las primeras filas de nuestro objeto excel_clean con la función head()\n\nexcel_subset &lt;- head(excel_clean)\nexcel_subset\n\n# A tibble: 6 × 10\n  numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n  &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n1 Hf100U                                3          24          18         0.093\n2 Hf100U                                3          24          18         0.093\n3 Hf100U                                3          24          32         0.093\n4 Hf100U                                3          24          32         0.093\n5 Hf101U                                3          30          18         0.114\n6 Hf101U                                3          30          18         0.114\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\nAhora lo guardamos en la carpeta que acabamos de crear usando la función write_csv()\n\nwrite_csv(excel_subset, file = \"resultados/tablas/excel_subset.csv\")\n\no con write.table() la cual nos permite usar una mayor diversidad de formatos\n\nwrite.table(excel_subset, file = \"resultados/tablas/excel_subset.txt\", sep = \"\\t\")"
  },
  {
    "objectID": "4.data_wrangling.html",
    "href": "4.data_wrangling.html",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "",
    "text": "Tidy Data es un concepto fundamental dentro del ecosistema Tidyverse en R que se centra en la organización y manipulación eficiente de datos para análisis y visualización.\nEn el contexto de Tidy Data, se busca estructurar los conjuntos de datos de manera que cada observación sea una fila, cada variable sea una columna y cada valor tenga su propia celda. Esto permite que los datos estén organizados en un formato uniforme y consistente, lo que facilita su manipulación y análisis. En resumen, los principios de Tidy Data son:\nEn resumen, un tidy data sigue las siguientes características:\n\nCada variable debe tener su propia columna\nCada observación debe tener su propia fila\nCada valor debe tener su propia celda"
  },
  {
    "objectID": "4.data_wrangling.html#seleccionar-columnas-con-select",
    "href": "4.data_wrangling.html#seleccionar-columnas-con-select",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "2.1 Seleccionar columnas con select()",
    "text": "2.1 Seleccionar columnas con select()\nPermite seleccionar una o varias columnas de un tibble o data.frame.\nPor ejemplo, si queremos seleccionar solamente las columnas Name, y Attack\n\nselect(pokemon, name, attack)\n\n# A tibble: 801 × 2\n   name       attack\n   &lt;chr&gt;       &lt;dbl&gt;\n 1 Bulbasaur      49\n 2 Ivysaur        62\n 3 Venusaur      100\n 4 Charmander     52\n 5 Charmeleon     64\n 6 Charizard     104\n 7 Squirtle       48\n 8 Wartortle      63\n 9 Blastoise     103\n10 Caterpie       30\n# ℹ 791 more rows\n\n\nRecuerda que si queremos generar un nuevo objeto con ese subset de datos tenemos que asignarlo a otro objeto.\n\npokemon_sub &lt;- select(pokemon, name, attack)\npokemon_sub\n\n# A tibble: 801 × 2\n   name       attack\n   &lt;chr&gt;       &lt;dbl&gt;\n 1 Bulbasaur      49\n 2 Ivysaur        62\n 3 Venusaur      100\n 4 Charmander     52\n 5 Charmeleon     64\n 6 Charizard     104\n 7 Squirtle       48\n 8 Wartortle      63\n 9 Blastoise     103\n10 Caterpie       30\n# ℹ 791 more rows\n\n\nCon select() tambien podemos seleccionar todo menos una columna especifica con el operador -\n\npokemon_sub &lt;- select(pokemon, -attack)\npokemon_sub\n\n# A tibble: 801 × 12\n   pokedex_number name  defense    hp percentage_male sp_attack sp_defense speed\n            &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n 1              1 Bulb…      49    45            88.1        65         65    45\n 2              2 Ivys…      63    60            88.1        80         80    60\n 3              3 Venu…     123    80            88.1       122        120    80\n 4              4 Char…      43    39            88.1        60         50    65\n 5              5 Char…      58    58            88.1        80         65    80\n 6              6 Char…      78    78            88.1       159        115   100\n 7              7 Squi…      65    44            88.1        50         64    43\n 8              8 Wart…      80    59            88.1        65         80    58\n 9              9 Blas…     120    79            88.1       135        115    78\n10             10 Cate…      35    45            50          20         20    45\n# ℹ 791 more rows\n# ℹ 4 more variables: type1 &lt;chr&gt;, weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;,\n#   is_legendary &lt;dbl&gt;\n\n\no podemos seleccionar un intervalo de columnas\n\npokemon_sub &lt;- select(pokemon, name, attack:hp)\npokemon_sub\n\n# A tibble: 801 × 4\n   name       attack defense    hp\n   &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n 1 Bulbasaur      49      49    45\n 2 Ivysaur        62      63    60\n 3 Venusaur      100     123    80\n 4 Charmander     52      43    39\n 5 Charmeleon     64      58    58\n 6 Charizard     104      78    78\n 7 Squirtle       48      65    44\n 8 Wartortle      63      80    59\n 9 Blastoise     103     120    79\n10 Caterpie       30      35    45\n# ℹ 791 more rows\n\n\no lo inverso para descargar un intervalo de columnas\n\npokemon_sub &lt;- select(pokemon, -(attack:hp))\npokemon_sub\n\n# A tibble: 801 × 10\n   pokedex_number name       percentage_male sp_attack sp_defense speed type1\n            &lt;dbl&gt; &lt;chr&gt;                &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n 1              1 Bulbasaur             88.1        65         65    45 grass\n 2              2 Ivysaur               88.1        80         80    60 grass\n 3              3 Venusaur              88.1       122        120    80 grass\n 4              4 Charmander            88.1        60         50    65 fire \n 5              5 Charmeleon            88.1        80         65    80 fire \n 6              6 Charizard             88.1       159        115   100 fire \n 7              7 Squirtle              88.1        50         64    43 water\n 8              8 Wartortle             88.1        65         80    58 water\n 9              9 Blastoise             88.1       135        115    78 water\n10             10 Caterpie              50          20         20    45 bug  \n# ℹ 791 more rows\n# ℹ 3 more variables: weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\nLa función everything() se puede seleccionar todo, y con esto es factible combiar el orden de las columnas. Por ejemplo, si queremos que la primera columna sea type ejecutamos:\n\nselect(pokemon, type1, everything())\n\n# A tibble: 801 × 13\n   type1 pokedex_number name      attack defense    hp percentage_male sp_attack\n   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1 grass              1 Bulbasaur     49      49    45            88.1        65\n 2 grass              2 Ivysaur       62      63    60            88.1        80\n 3 grass              3 Venusaur     100     123    80            88.1       122\n 4 fire               4 Charmand…     52      43    39            88.1        60\n 5 fire               5 Charmele…     64      58    58            88.1        80\n 6 fire               6 Charizard    104      78    78            88.1       159\n 7 water              7 Squirtle      48      65    44            88.1        50\n 8 water              8 Wartortle     63      80    59            88.1        65\n 9 water              9 Blastoise    103     120    79            88.1       135\n10 bug               10 Caterpie      30      35    45            50          20\n# ℹ 791 more rows\n# ℹ 5 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, weight_kg &lt;dbl&gt;,\n#   generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n2.1.1 Seleccionar variables con un patrón\nEstas funcionen ayudad a seleccionar variables según un patrón determinado\n\nstarts_with(): Inicia con un prefijo exacto\nends_with(): Finaliza con un sufijo exacto\ncontains(): Contiene una cadena literal\n\nPor ejemplo, podemos seleccionar las columnas de Sp attack y Sp deffense utilizando el prefijo sp\n\nselect(pokemon, name, starts_with(\"sp_\"))\n\n# A tibble: 801 × 3\n   name       sp_attack sp_defense\n   &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt;\n 1 Bulbasaur         65         65\n 2 Ivysaur           80         80\n 3 Venusaur         122        120\n 4 Charmander        60         50\n 5 Charmeleon        80         65\n 6 Charizard        159        115\n 7 Squirtle          50         64\n 8 Wartortle         65         80\n 9 Blastoise        135        115\n10 Caterpie          20         20\n# ℹ 791 more rows\n\n\nO podemos seleccionar las variables relacionadas con ataque (attack)\n\nselect(pokemon, name, contains(\"attack\"))\n\n# A tibble: 801 × 3\n   name       attack sp_attack\n   &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n 1 Bulbasaur      49        65\n 2 Ivysaur        62        80\n 3 Venusaur      100       122\n 4 Charmander     52        60\n 5 Charmeleon     64        80\n 6 Charizard     104       159\n 7 Squirtle       48        50\n 8 Wartortle      63        65\n 9 Blastoise     103       135\n10 Caterpie       30        20\n# ℹ 791 more rows"
  },
  {
    "objectID": "4.data_wrangling.html#filtrar-variables-con-filter",
    "href": "4.data_wrangling.html#filtrar-variables-con-filter",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "2.2 Filtrar variables con filter()",
    "text": "2.2 Filtrar variables con filter()\n\nLa función filter() nos permite filtrar los elementos de una variable (columna) que cumplan con una condición especifica.\nPor ejemplo, para filtrar pokemon que tengan un nivel de ataque (Attack) superior a 100 usariamos\n\nfilter(pokemon, attack &gt; 100)\n\n# A tibble: 169 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              6 Charizard     104      78    78            88.1       159\n 2              9 Blastoise     103     120    79            88.1       135\n 3             15 Beedrill      150      40    65            50          15\n 4             34 Nidoking      102      77    81           100          85\n 5             57 Primeape      105      60    65            50          60\n 6             59 Arcanine      110      80    90            75.4       100\n 7             68 Machamp       130      80    90            75.4        65\n 8             71 Victreebel    105      65    80            50         100\n 9             76 Golem         120     130    80            50          55\n10             85 Dodrio        110      70    60            50          60\n# ℹ 159 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\nPara establecer varios condiciones, simplemente las podemos separar por una ,. Por ejemplo, si queremos filtrar a los pokemon que tengan un nivel de ataque mayor a 100 y que sea de tipo fuego (fire)\n\nfilter(pokemon, attack &gt; 100, type1 == \"fire\")\n\n# A tibble: 11 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              6 Charizard     104      78    78            88.1       159\n 2             59 Arcanine      110      80    90            75.4       100\n 3            136 Flareon       130      60    65            88.1        95\n 4            244 Entei         115      85   115            NA          90\n 5            250 Ho-Oh         130      90   106            NA         110\n 6            257 Blaziken      160      80    80            88.1       130\n 7            323 Camerupt      120     100    70            50         145\n 8            392 Infernape     104      71    76            88.1       104\n 9            500 Emboar        123      65   110            88.1       100\n10            721 Volcanion     110     120    80            NA         130\n11            727 Incineroar    115      90    95            88.1        80\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\nTip\n\n\n\nSi tienes muchas condiciones, puedes escribir cada condición en una línea diferente para evitar líneas de código muy largas\n\nfilter(pokemon, attack &gt; 100,\n       type1 == \"fire\",\n       generation == 1, \n       speed &gt; 50)\n\n\n\nSi queremos filtrar distintas condiciones de una misma variable (columna) podemos usar el operador %in%.\nPor ejemplo, para filtar los pokemon que sean de tipo fuego y agua\n\nfilter(pokemon, type1 %in% c(\"fire\", \"water\"))\n\n# A tibble: 166 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              4 Charmander     52      43    39            88.1        60\n 2              5 Charmeleon     64      58    58            88.1        80\n 3              6 Charizard     104      78    78            88.1       159\n 4              7 Squirtle       48      65    44            88.1        50\n 5              8 Wartortle      63      80    59            88.1        65\n 6              9 Blastoise     103     120    79            88.1       135\n 7             37 Vulpix         41      40    38            24.6        50\n 8             38 Ninetales      67      75    73            24.6        81\n 9             54 Psyduck        52      48    50            50          65\n10             55 Golduck        82      78    80            50          95\n# ℹ 156 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\nNota\n\n\n\nSi tienes muchas condiciones o si tienes las mismas condiciones que quieres filtrar en distintos sets de datos, puedes hacer un vector y despues incorporarlo en la funcion filter. Por ejemplo\n\ntipos &lt;- c(\"fire\", \"normal\", \"water\")\n\nfilter(pokemon, type1 %in% tipos)\n\n# A tibble: 271 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              4 Charmander     52      43    39            88.1        60\n 2              5 Charmeleon     64      58    58            88.1        80\n 3              6 Charizard     104      78    78            88.1       159\n 4              7 Squirtle       48      65    44            88.1        50\n 5              8 Wartortle      63      80    59            88.1        65\n 6              9 Blastoise     103     120    79            88.1       135\n 7             16 Pidgey         45      40    40            50          35\n 8             17 Pidgeotto      60      55    63            50          50\n 9             18 Pidgeot        80      80    83            50         135\n10             19 Rattata        56      35    30            50          25\n# ℹ 261 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\nEs posbile filtrar un intervalo de valores utilizando la función between(). Esta función requiere como argumentos el nombre de la variable que queremos filtrar, el límite inferior y el límite superior.\nPor ejemplo, si queremos filtrar los pokemon que tengan un nivel de ataque (attack) mayor a 100 pero menor a 150\n\nfilter(pokemon, between(attack, 100, 150))\n\n# A tibble: 191 × 13\n   pokedex_number name      attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              3 Venusaur     100     123    80            88.1       122\n 2              6 Charizard    104      78    78            88.1       159\n 3              9 Blastoise    103     120    79            88.1       135\n 4             15 Beedrill     150      40    65            50          15\n 5             28 Sandslash    100     120    75            50          25\n 6             34 Nidoking     102      77    81           100          85\n 7             51 Dugtrio      100      60    35            50          50\n 8             57 Primeape     105      60    65            50          60\n 9             59 Arcanine     110      80    90            75.4       100\n10             67 Machoke      100      70    80            75.4        50\n# ℹ 181 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\nPodemos usar la operación opuesta utilizando el operado !\n\nfilter(pokemon, !between(attack, 100, 150))\n\n# A tibble: 610 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              1 Bulbasaur      49      49    45            88.1        65\n 2              2 Ivysaur        62      63    60            88.1        80\n 3              4 Charmander     52      43    39            88.1        60\n 4              5 Charmeleon     64      58    58            88.1        80\n 5              7 Squirtle       48      65    44            88.1        50\n 6              8 Wartortle      63      80    59            88.1        65\n 7             10 Caterpie       30      35    45            50          20\n 8             11 Metapod        20      55    50            50          25\n 9             12 Butterfree     45      50    60            50          90\n10             13 Weedle         35      50    40            50          20\n# ℹ 600 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\nEjercicio: ¿¡QUIEN ES ESE POKEMON!? 📣\n\n\n\n\n\n\n\n\nNuestro pokémon tiene un valor de HP entre 100 y 200; valor de velocidad menor a 50; es del tipo1 Normal; tiene un valor de defensa menor a 40 y pertenece a la primera generación\n\n\nver codigo\nfilter(pokemon, between(hp, 100, 200),\n       speed &lt; 50,\n       type1 == \"normal\",\n       defense &lt; 40,\n       generation == 1)\n\n\n\n\n\n2.2.1 Filtrar variables con un patrón\nTambien es posible filtrar una variable a partir de un caracter en especifico usando la función str_detect().\n\nfilter(pokemon, str_detect(name, \"eon\"))\n\n# A tibble: 13 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              5 Charmeleon     64      58    58            88.1        80\n 2            134 Vaporeon       65      60   130            88.1       110\n 3            135 Jolteon        65      60    65            88.1       110\n 4            136 Flareon       130      60    65            88.1        95\n 5            196 Espeon         65      60    65            88.1       130\n 6            197 Umbreon        65     110    95            88.1        60\n 7            352 Kecleon        90      70    60            50          60\n 8            395 Empoleon       86      88    84            88.1       111\n 9            456 Finneon        49      56    49            50          49\n10            457 Lumineon       69      76    69            50          69\n11            470 Leafeon       110     130    65            88.1        60\n12            471 Glaceon        60     110    65            88.1       130\n13            700 Sylveon        65      65    95            88.1       110\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\nEjercicio: Una galaxía muy lejana…\n\n\n\nAbre la tabla starwars que se encuentra en el directorio de databases y genera los siguientes objetos:\n\nUna tabla que incluya solamente el nombre del personaje y todas las variables relacionadas con colores.\nUna tabla que incluya solamente los personajes femeninos del planeta Naboo.\nUna tabla con los personajes que hayan aparecido en Attack of the Clones."
  },
  {
    "objectID": "4.data_wrangling.html#transformar-o-crear-columnas-con-mutate",
    "href": "4.data_wrangling.html#transformar-o-crear-columnas-con-mutate",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "2.3 Transformar o crear columnas con mutate()",
    "text": "2.3 Transformar o crear columnas con mutate()\n\n\n\n\n\nLa función mutate() es una función versatil en el sentido que nos permite crear nuevas variables que contengan alguna operación a partir de las que ya tenemos, añadir una nueva variable o transformar una variable ya existente\nPor ejemplo, podemos generar una nueva columna llamada “at_df_ratio” con la propoción de los valores de Ataque sobre Defensa\n\npokemon_mutate &lt;- mutate(pokemon, at_df_ratio = attack/defense )\n\nhead(pokemon_mutate$at_df_ratio)\n\n[1] 1.0000000 0.9841270 0.8130081 1.2093023 1.1034483 1.3333333\n\n\nDe igual manera, se pueden generar diversas nuevas columnas en una misma función separadas por comas.\n\npokemon_mutate &lt;- mutate(pokemon, \n                         at_df_ratio = attack/defense,\n                         at_df_per = at_df_ratio * 100,\n                         nueva_col = \"nueva columna\")\n\npokemon_mutate\n\n# A tibble: 801 × 16\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              1 Bulbasaur      49      49    45            88.1        65\n 2              2 Ivysaur        62      63    60            88.1        80\n 3              3 Venusaur      100     123    80            88.1       122\n 4              4 Charmander     52      43    39            88.1        60\n 5              5 Charmeleon     64      58    58            88.1        80\n 6              6 Charizard     104      78    78            88.1       159\n 7              7 Squirtle       48      65    44            88.1        50\n 8              8 Wartortle      63      80    59            88.1        65\n 9              9 Blastoise     103     120    79            88.1       135\n10             10 Caterpie       30      35    45            50          20\n# ℹ 791 more rows\n# ℹ 9 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;, at_df_ratio &lt;dbl&gt;,\n#   at_df_per &lt;dbl&gt;, nueva_col &lt;chr&gt;\n\n\nCon mutate(), también es posible cambiar el tipo de dato de cada columna. Por ejemplo, cambiar la columna “Type1” de carácter a factor:\n\npokemon_mutate &lt;- mutate(pokemon, type1 = factor(type1))\npokemon_mutate\n\n# A tibble: 801 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              1 Bulbasaur      49      49    45            88.1        65\n 2              2 Ivysaur        62      63    60            88.1        80\n 3              3 Venusaur      100     123    80            88.1       122\n 4              4 Charmander     52      43    39            88.1        60\n 5              5 Charmeleon     64      58    58            88.1        80\n 6              6 Charizard     104      78    78            88.1       159\n 7              7 Squirtle       48      65    44            88.1        50\n 8              8 Wartortle      63      80    59            88.1        65\n 9              9 Blastoise     103     120    79            88.1       135\n10             10 Caterpie       30      35    45            50          20\n# ℹ 791 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;fct&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;"
  },
  {
    "objectID": "4.data_wrangling.html#operaciones-agrupadas",
    "href": "4.data_wrangling.html#operaciones-agrupadas",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "4.1 Operaciones agrupadas",
    "text": "4.1 Operaciones agrupadas\nConsiderando la base de datos, seria mas informativo obtener el promedio por especie o por isla. La función group_by() permite agrupar los datos de acuerdo a alguna variable (factor).\nPor ejemplo, para obtener el peso promedio por especie:\n\npenguins %&gt;% \n  group_by(species) %&gt;% \n  summarise(promedio_peso = mean(body_mass_g, na.rm = TRUE))\n\n# A tibble: 3 × 2\n  species   promedio_peso\n  &lt;chr&gt;             &lt;dbl&gt;\n1 Adelie            3701.\n2 Chinstrap         3733.\n3 Gentoo            5076.\n\n\nPodemos agrupar utilizando mas variables separadas por una coma:\n\npenguins %&gt;% \n  group_by(island, species, sex) %&gt;% \n  summarise(promedio_peso = mean(body_mass_g, na.rm = TRUE),\n            desviacion = sd(body_mass_g, na.rm = TRUE),\n            N = n())\n\n`summarise()` has grouped output by 'island', 'species'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 13 × 6\n# Groups:   island, species [5]\n   island    species   sex    promedio_peso desviacion     N\n   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt;\n 1 Biscoe    Adelie    female         3369.       343.    22\n 2 Biscoe    Adelie    male           4050        356.    22\n 3 Biscoe    Gentoo    female         4680.       282.    58\n 4 Biscoe    Gentoo    male           5485.       313.    61\n 5 Biscoe    Gentoo    &lt;NA&gt;           4588.       338.     5\n 6 Dream     Adelie    female         3344.       212.    27\n 7 Dream     Adelie    male           4046.       331.    28\n 8 Dream     Adelie    &lt;NA&gt;           2975         NA      1\n 9 Dream     Chinstrap female         3527.       285.    34\n10 Dream     Chinstrap male           3939.       362.    34\n11 Torgersen Adelie    female         3396.       259.    24\n12 Torgersen Adelie    male           4035.       372.    23\n13 Torgersen Adelie    &lt;NA&gt;           3681.       413.     5\n\n\nExisten otras funciones útiles por las que nos podría interesar agrupar\n\ncount()\nmean()\nmedian()\nmin()\nmax()\nquantile(x, 0.25)\nIQR()\n\nEl uso de la función group_by() tambien nos permite transformar una variable e incluirla en una columna en conjunto con la función mutate()\n\npenguins %&gt;% \n  group_by(species, island,sex) %&gt;% \n  mutate(promedio_peso_grupo = mean(body_mass_g, na.rm = TRUE)) %&gt;% \n  select(promedio_peso_grupo, everything())\n\n# A tibble: 344 × 9\n# Groups:   species, island, sex [13]\n   promedio_peso_grupo species island    bill_length_mm bill_depth_mm\n                 &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;\n 1               4035. Adelie  Torgersen           39.1          18.7\n 2               3396. Adelie  Torgersen           39.5          17.4\n 3               3396. Adelie  Torgersen           40.3          18  \n 4               3681. Adelie  Torgersen           NA            NA  \n 5               3396. Adelie  Torgersen           36.7          19.3\n 6               4035. Adelie  Torgersen           39.3          20.6\n 7               3396. Adelie  Torgersen           38.9          17.8\n 8               4035. Adelie  Torgersen           39.2          19.6\n 9               3681. Adelie  Torgersen           34.1          18.1\n10               3681. Adelie  Torgersen           42            20.2\n# ℹ 334 more rows\n# ℹ 4 more variables: flipper_length_mm &lt;dbl&gt;, body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;,\n#   year &lt;dbl&gt;"
  },
  {
    "objectID": "4.data_wrangling.html#resumir-todas-las-variables-con-summarise_all",
    "href": "4.data_wrangling.html#resumir-todas-las-variables-con-summarise_all",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "4.2 Resumir todas las variables con summarise_all()",
    "text": "4.2 Resumir todas las variables con summarise_all()\nLa función summarise_all() requiere una función como argumento, la cual aplica a todas las columnas de la tabla. En este ejemplo se agrego el argumento na.rm = TRUE el cual ignora los NAs\n\npenguins %&gt;% \n  group_by(species, island, sex) %&gt;% \n  summarise_all(mean, na.rm = TRUE) \n\n# A tibble: 13 × 8\n# Groups:   species, island [5]\n   species   island    sex    bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1 Adelie    Biscoe    female           37.4          17.7              187.\n 2 Adelie    Biscoe    male             40.6          19.0              190.\n 3 Adelie    Dream     female           36.9          17.6              188.\n 4 Adelie    Dream     male             40.1          18.8              192.\n 5 Adelie    Dream     &lt;NA&gt;             37.5          18.9              179 \n 6 Adelie    Torgersen female           37.6          17.6              188.\n 7 Adelie    Torgersen male             40.6          19.4              195.\n 8 Adelie    Torgersen &lt;NA&gt;             37.9          18.2              187.\n 9 Chinstrap Dream     female           46.6          17.6              192.\n10 Chinstrap Dream     male             51.1          19.3              200.\n11 Gentoo    Biscoe    female           45.6          14.2              213.\n12 Gentoo    Biscoe    male             49.5          15.7              222.\n13 Gentoo    Biscoe    &lt;NA&gt;             45.6          14.6              216.\n# ℹ 2 more variables: body_mass_g &lt;dbl&gt;, year &lt;dbl&gt;"
  }
]