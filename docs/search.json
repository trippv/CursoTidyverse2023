[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso: Análisis de datos con Tidyverse",
    "section": "",
    "text": "Date: Date and time\nLugar: Centro de Investigaciones Biológicas del Noroeste, S.C.\nInstructores: Miguel A. Tripp Valdez\n\n\n1 ¡Bienvenidos!\n\n\n\n\n\n\nObjetivos del curso\n\n\n\n\nQue el alumno tenga un panorama detallado sobre el uso de la herramientas dentro del conjunto de paquetes de Tidyverse para importar, manipular, extraer y visualizar información relevante a partir de bases de datos.\nQue el alumno adquiera habilidades prácticas para la manipulación y visualización de datos\nQue el alumno sea capaz de acoplar la experiencia adquirida en este curso para análisis estadísticos, datos genómicos, datos espaciales, etc.\n\n\n\n\nRequisitos\n\nEs deseable que el alumno tenga experiencia básica en el uso de R\nTener acceso internet\nTener instalado R y Rstudio en su computadora\n\n\n\n\n2 Horario del curso\n\n\n\n\n\n\n\n\nHorario\nLección\n\n\n\n\n\nxxxx - xxxxx\nIntroducción a Tidyvese, Rstuio y Posit Cloud\nImportar datos, limpiar etiquetas y exportar\n\n\n\nxxxx - xxxx\nData wrangling\ndplyr, tidyr, uso del pipe\n\n\nxxxx - xxxx\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncountdown::countdown(1, warn_when = 10)\n\n\n−+\n01:00"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About page\n\n\n\nThis page contains some elaborated background information about your workshop, or the instructors.\n\n\nFor example: A central problem in machine learning is how to make an algorithm perform well not just on the training data, but also on new inputs. Many strategies in machine learning are explicitly designed to reduce this test error, possibly at the expense of increased training error. These strategies are collectively known as regularisation and they are instrumental for good performance of any kind of prediction or classification model, especially in the context of small data (many features, few samples).\nIn the hands-on tutorial we will use R to perform an integrated analysis of multi-omics data with penalised regression.\n\nContact\nInstructor A: contact\nInstructor B: contact\nInstructor C: contact"
  },
  {
    "objectID": "part_1_prep.html",
    "href": "part_1_prep.html",
    "title": "Preparation",
    "section": "",
    "text": "Page without code\n\n\n\nThis page contains an example for some structured preparation information for a workshop. No code is executed here.\nHere are some preparation information for the participants."
  },
  {
    "objectID": "part_1_prep.html#software",
    "href": "part_1_prep.html#software",
    "title": "Preparation",
    "section": "1 Software",
    "text": "1 Software\nIn this workshop we will be using R. You can either\n\nhave R and Rstudio installed on your laptop\nor, use Posit cloud (formerly Rstudio Cloud).\n\nPosit cloud is free of charge for personal users, yet you need to sign up for a new user account and have internet connection.\nThe R package we are using is glmnet."
  },
  {
    "objectID": "part_1_prep.html#data",
    "href": "part_1_prep.html#data",
    "title": "Preparation",
    "section": "2 Data",
    "text": "2 Data\nThe datasets we use can be found here (insert link)."
  },
  {
    "objectID": "part_1_prep.html#code",
    "href": "part_1_prep.html#code",
    "title": "Preparation",
    "section": "3 Code",
    "text": "3 Code\nThe R scripts used in part 1 and part 2 can be found here (insert link)."
  },
  {
    "objectID": "part_1_prep.html#resources",
    "href": "part_1_prep.html#resources",
    "title": "Preparation",
    "section": "4 Resources",
    "text": "4 Resources\nLecture notes (insert link)\nLab notes (insert link)"
  },
  {
    "objectID": "part_2_eda.html",
    "href": "part_2_eda.html",
    "title": "Part I",
    "section": "",
    "text": "Page with R code\n\n\n\nThis page contains an example template for a lab session, where R code and results are displayed here.\nYou can find more information on how to include code in Quarto website here.\nYou can experiment with code-fold and code-tools in the yaml header above to change how the code cells look like."
  },
  {
    "objectID": "part_2_eda.html#a-cancer-modeling-example",
    "href": "part_2_eda.html#a-cancer-modeling-example",
    "title": "Part I",
    "section": "1 A Cancer Modeling Example",
    "text": "1 A Cancer Modeling Example\nExercise on analysis of miRNA, mRNA and protein data from the paper Aure et al, Integrated analysis reveals microRNA networks coordinately expressed with key proteins in breast cancer, Genome Medicine, 2015.\nPlease run the code provided to replicate some of the analyses. Make sure you can explain what all the analysis steps do and that you understand all the results.\nIn addition, there are some extra tasks (Task 1), where no R code is provided. Please do these tasks when you have time available at the end of the lab.\n\n1.1 Load the data\nRead the data, and convert to matrix format.\n\nmrna &lt;- read.table(\"data/data_example.txt\", header=T, sep=\"\\t\", dec=\".\")\n\n# Convert to matrix format\n\nmrna &lt;- as.matrix(mrna)\n\nPrint the data\n\nmrna[1:4, 1:4]\n\n      OSL2R.3002T4 OSL2R.3005T1 OSL2R.3013T1 OSL2R.3030T2\nACACA      1.60034     -0.49087     -0.26553     -0.27857\nANXA1     -2.42501     -0.05416     -0.46478     -2.18393\nAR         0.39615     -0.43348     -0.10232      0.58299\nBAK1       0.78627      0.39897      0.22598     -1.31202\n\n\nVisualise the overall distribution of expression levels by histogram\n\nhist(mrna, nclass=40, xlim=c(-5,5), col=\"lightblue\")\n\n\n\n\n\n\n\n\n\n\nTask 1\n\n\n\nThis is a callout-note, and it can be quite useful for exercises. You can find more about callout here.\nExample: Extend the above analysis to cover all genes."
  },
  {
    "objectID": "apoyo.html",
    "href": "apoyo.html",
    "title": "Recursos de apoyo",
    "section": "",
    "text": "A continuación encontrarás diversos materiales disponibles en la red con la que puedes ampliar tus conocimientos en R y ciencia de datos\n\nLibros en línea\n\nR para Ciencia de Datos - Versión en español de conocido libro R fo Data Science de Wickham y Grolemund\nThe Big Book of R - Extensa colección de libros y materiales en línea\nData Visualization with R - Libro para la creación de gráficos en ggplot\nFundamentals of Data Visualization - Guía para generar visualizaciones efectivas\nQuarto - Guia para generar reportes, páginas web y documentos PDF con Quarto\n\nA quien seguir\n\nPositPBC - Seminarios, tutoriales y comentarios sobre las últimas novedades de la comunidad de Rstudio (Posit)\nR ladies - R-Ladies es una organización mundial cuya misión es promover la diversidad de género en la comunidad R.\nCommunity of Bioinformatics Software Developers - Canal de bioinformática con númerosos tutoriales de R desde nivel principiante hasta análisis avanzados"
  },
  {
    "objectID": "1.Introduccion.html",
    "href": "1.Introduccion.html",
    "title": "Introducción al curso",
    "section": "",
    "text": "Tidyverse no es en si un paquete sino un conjunto de paquetes en el lenguaje de programación R, diseñado para facilitar la manipulación, visualización y análisis de datos. Desarrollado por Hadley Wickham y su equipo, Tidyverse busca proporcionar un enfoque coherente y eficiente para trabajar con datos, promoviendo la claridad, la reproducibilidad y la facilidad de uso en el análisis de datos.\nPodríamos decir que Tidyverse es una filosofía de trabajo que permite que diversos programas y funciones trabajen bajo esta misma filosofía.\n\n\n\n\n\n\n¿Realmente necesito aprender a usar Tidyverse?\n\n\n\nRealmente no. Todas las funciones y herramientas que veremos a lo largo de este curso pueden realizarse utilizando funciones de base de R. Sin embargo, Tidyverse tiene una estructura mas coherente, legible y comprensible."
  },
  {
    "objectID": "1.Introduccion.html#footnotes",
    "href": "1.Introduccion.html#footnotes",
    "title": "Introducción al curso",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nTidyverse↩︎"
  },
  {
    "objectID": "2.Proyectos.html",
    "href": "2.Proyectos.html",
    "title": "Leccion 1: Proyectos en Rstudio",
    "section": "",
    "text": "@allison_horst\n\n\nIndependientemente de si estás dando tus primeros pasos en R o si ya eres un experto, es frecuente que la primera línea de tu código sea algo como esto:\nsetwd(\"C:\\Users\\miguel\\ruta\\que\\solo\\yo\\tengo\")\nsetwd() toma una ruta absoluta y la establece como el directorio de trabajo activo. El utilizar una ruta absoluta como directorio de trabajo hace que sea difícil de reproducir o de mover ya que otra persona u otro equipo no tiene esa misma ruta absoluta.\n\n1 Proyectos en Rstudio\nLos proyectos de RStudio resuelven el problema de las rutas ‘frágiles’ al hacer que las rutas de archivo sean relativas. El archivo de proyecto de RStudio es un archivo que se encuentra en el directorio raíz, con la extensión .Rproj. Cuando tu sesión de RStudio está siendo ejecutada a través del archivo de proyecto (.Rproj), el directorio de trabajo actual apunta a la carpeta raíz donde se guarda ese archivo .Rproj.\nEste proyecto facilita importar y exportar archivos ya que todos están a la mano a partir de rutas relativas a la carpeta raíz.\n\n\n\n\n\n\nTip\n\n\n\nOtra gran ventaja de los proyectos de Rstudio, es que puedes compartirlo con otra persona manteniendo la estructura de las rutas relativas, de manera que no importa en donde se guarde el proyecto o si esta utilizando otro sistema operativo, las rutas relativas permanecen funcionales siempre y cuando abra la sesión utilizando el proyecto (.Rproj).\n\n\nUn ejemplo de como podemos estructurar un proyecto es el siguiente:\n\n\n\n\n\n\nDatos: Esta es la carpeta en la que se guardan los archivos que necesito leer en R para realizar mi análisis o visualización. Estos pueden ser CSV, TXT, TSV, etc. La idea principal de tener esta carpeta es que estos archivos crudos en ningún momento debería sobrescribir o editar para garantizar la reproducibilidad.\nScript: Aquí es donde puedes guardar los scripts de R y/o archivos RMarkdown o Quarto.\nSalida: En esta carpeta puedes guardar todas tus salidas, incluyendo gráficos, HTML y tablas, etc. Tener esta carpeta de Salida ayuda a otros a identificar qué archivos son resultados del código, en contraste con los archivos fuente que se utilizaron para producir el análisis.\n\n\n\n2 Como generar un proyecto nuevo\nPara crear un proyecto nuevo sigue estos passos:\n\nAbre Rstudio y selecciona Archivo -&gt; Nuevo Proyecto\n\n\n\n\n\n\n\nSelecciona Nueva Carpeta si estas empezando el proyecto desde cero o carpeta existente si deseas crear un proyecto dentro de alguna carpeta que ya tengas\n\n\n\n\n\n\n\nDa un nombre a tu proyecto y ¡listo! ya puedes empezar a trabajar.\n\nEl proyecto R que has creado estará en una carpeta que contiene un archivo .Rproj. Este archivo es un acceso directo y probablemente la forma más directa de abrir tu proyecto. También puedes abrir un proyecto seleccionando “Open Project” en el menú File. Alternativamente, en el extremo superior derecho de RStudio verás un icono de R projects y un menú desplegable de proyectos disponibles.\n\n\n\n\n\nPara salir de un proyecto R, abre un nuevo proyecto o cierra el proyecto actual (Archivo - Cerrar proyecto).\n\n\n\n\n\n\nEjercicio\n\n\n\nAhora prueba creando un proyecto dentro de una carpeta local en tu computadora y genera una estructura de carpetas como la indicada anteriormente\n\n\n\n\n\n\n\n\nPro tip: uso de here() para rutas relativas\n\n\n\nEl paquete here() se utiliza para construir rutas de archivos y directorios de manera relativa al directorio del proyecto actual. En lugar de utilizar rutas absolutas (que especifican la ruta completa desde la raíz del sistema de archivos) o rutas relativas estándar (que se basan en la ubicación del script en ejecución), here() crea rutas relativas desde el directorio del proyecto."
  },
  {
    "objectID": "3_Data_import.html",
    "href": "3_Data_import.html",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "La importación de archivos de texto es el primer paso y parte fundamental para la exploración de datos. Sin embargo, también puede llegar a ser una tarea complicada.\nLos tipos de archivos mas comunes con los que solemos trabajar son:\n\nComa-separated values (csv)\nTab-separated values (tsv)\nExcel (xls)\nArchivo de texto simple (txt)\n\n\n\nPara importar un archivo a nuestro ambiente podemos utilizar las funciones base read.table, read.csv, read.delim. Por ejemplo, para abrir un archivo txt separado por tabuladores utilizando la función:\n\ndf &lt;- read.table(\"data/palmer_penguins.txt\", header = TRUE, sep = \"\\t\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007\n\n\no usando read.csv\n\ndf &lt;- read.csv(\"data/palmer_penguins.csv\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007\n\n\n\n\n\nDentro del Tidyverse, la importación de datos rectangulares se realiza con el paquete readr el cual tiene funciones que van a sonar muy familiares:\n\nread_csv(): comma-separated values (CSV)\nread_tsv(): tab-separated values (TSV)\nread_csv2(): semicolon-separated values with , as the decimal mark\nread_delim(): delimited files (CSV and TSV are important special cases)\nread_table(): whitespace-separated files\n\n\n\n\n\n\n\n¿Has notado algo? 🧐\n\n\n\nComo ves, los nombres de las funciones son muy parecidas a las funciones base pero reemplazando el “.” por un “_”. Esta tendencia se repite en numerosas funciones que siguen la filosofía tidy. Por ejemplo, en lugar de la prueba shapiro.test, rstatix utiliza la función shapiro_test.\n\n\nHagamos la prueba…\n\nlibrary(tidyverse)\nlibrary(here)\n\n\ndf &lt;- read_table(\"data/palmer_penguins.txt\")\n\n\n── Column specification ────────────────────────────────────────────────────────\ncols(\n  species = col_character(),\n  island = col_character(),\n  bill_length_mm = col_double(),\n  bill_depth_mm = col_double(),\n  flipper_length_mm = col_double(),\n  body_mass_g = col_double(),\n  sex = col_character(),\n  year = col_double()\n)\n\n\nObserva como, aún antes de desplegar la tabla,read_table ya nos arroja información sobre la estructura de los datos y nos indica si cada columna es número, carácter o de otro tipo.\nAhora observa como se despliega la tabla\n\ndf\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\n\n\n\n¿double? ¿character? 😱\n\n\n\nEn caso de que no lo recuerdes, estos son los principales tipos de datos en R\n\n\n\nTipo\nDescripción\nEjemplo\n\n\nNumeric\ninterger números enteros\n0L, 1L\n\n\nNumeric\ndouble números reales\n1.0,\n\n\nLogic\nvalores booleanos\nTRUE, FALSE\n\n\nCharacter\ncadena de texto\n“Hola mundo”\n\n\nFactor\nrepresentan datos categóricos\nmacho, hembra\n\n\nDates\nFechas\n“2023-08-24”\n\n\n\n\n\n\n\n\nCon R base, la función read.table nos genera un data frame pero readr nos genera un tibble los cuales son una versión actualizada de un data frame.\nHay varias diferencias entre tibbles y data.frames. Puedes leer mas en la viñeta. Sin embargo, algunas de las diferencias mas notables son:\n\nEl tipo de entrada permanece inalterado: los data.frames son conocidos por tratar las cadenas de texto como factores; esto no sucederá con los tibbles.\nLos nombres de las variables permanecen inalterados: En R base, al crear data.frames se eliminan los espacios de los nombres, convirtiéndolos en puntos o agregando una “x” antes de los nombres de las columnas numéricas. Al crear tibbles, los nombres de las variables (columnas) no cambian.\nNo hay row.names() para un tibble: Los datos ordenados requieren que las variables se almacenen de manera consistente, eliminando la necesidad de nombres de filas. Los tibbles imprimen las primeras diez filas y columnas que caben en una pantalla: Imprimir un tibble en la pantalla nunca mostrará todo el enorme marco de datos. Por defecto, solo muestra lo que cabe en tu pantalla.\n\n\n\nSi tenemos datos rectangulares como data.frame podemos convertirlo facilmente a tibble con la función as_tibble()\nPor ejemplo, podemos:\n\nas_tibble(trees)\n\n# A tibble: 31 × 3\n   Girth Height Volume\n   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1   8.3     70   10.3\n 2   8.6     65   10.3\n 3   8.8     63   10.2\n 4  10.5     72   16.4\n 5  10.7     81   18.8\n 6  10.8     83   19.7\n 7  11       66   15.6\n 8  11       75   18.2\n 9  11.1     80   22.6\n10  11.2     75   19.9\n# ℹ 21 more rows\n\n\n\n\n\n\n\n\nWarning\n\n\n\nRecuerda que si solo ejecutamos el comando as_tibble(trees) R solo nos arrojará el resutlado en la consola pero no hizo ningún cambio al objeto trees. Para esto necesitamos renombrar o generar un nuevo objeto. Por ejemplo\n\ntrees_tbl &lt;- as_tibble(trees)\n\nahora si, tenemos un nuevo objetvo como tibble\n\nclass(trees)\n\n[1] \"data.frame\"\n\nclass(trees_tbl)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\nAl igual que como lo hariamos con un data.frame o una matriz, podemos acceder a las primeras o últimas filas de nuestro tibble con las funciones head() y tail()\n\nhead(df)\n\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\ntail(df)\n\n# A tibble: 6 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Chinstrap Dream            45.7          17                 195        3650\n2 Chinstrap Dream            55.8          19.8               207        4000\n3 Chinstrap Dream            43.5          18.1               202        3400\n4 Chinstrap Dream            49.6          18.2               193        3775\n5 Chinstrap Dream            50.8          19                 210        4100\n6 Chinstrap Dream            50.2          18.7               198        3775\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\nTambién es posible hacer tibble sobre la marcha utilizando la función tibble(). Por ejemplo:\n\nmi_tibl &lt;- tibble(\n  a = 1:5,\n  b = 6:10,\n  c = 1,\n  z = (a + b)^2 + c\n)\n\nmi_tibl\n\n# A tibble: 5 × 4\n      a     b     c     z\n  &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     6     1    50\n2     2     7     1    82\n3     3     8     1   122\n4     4     9     1   170\n5     5    10     1   226\n\n\nNota que al momento de generar este tibble, puedes hacer referencias a columnas del mismo tibble (columa z)\nOtro comportamiento de los tibbles es que es posible tener nombres de columnas con espacios u otros caracteres y estos estarán rodeados por ``\n\nmi_tibl &lt;- tibble(\n  `cinco números` = 1:5,\n  `12` = \"numeric\",\n  `:)` = \"smile\",\n)\n\nmi_tibl\n\n# A tibble: 5 × 3\n  `cinco números` `12`    `:)` \n            &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;\n1               1 numeric smile\n2               2 numeric smile\n3               3 numeric smile\n4               4 numeric smile\n5               5 numeric smile\n\n\n\n\n\n\nLas hojas de calculo de excel (formatos .xls o .xlsx) siguen siendo muy comunes y muy utilizados dentro de la comunidad académica.\nTidyverse no tiene dentro de su núcleo una función para importar este tipo de archivos, pero esto se soluciona fácilmente con el paquete readxl.\n\n\n\n\n\n\ninstall.packages(\"readxl\")\n\n\nlibrary(readxl)\n\nWarning: package 'readxl' was built under R version 4.3.1\n\n\nCon esto podemos usar la función read_excel() que no necesita ningún otro argumento mas que la ruta (path) donde se encuentra el archivo .xlsx\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\")\n\nexcel_df\n\n# A tibble: 405 × 9\n   `Sample ID` ExpNum TreatTemp Meas_Temp `WetWeight(g)` `buffer(ml)`\n   &lt;chr&gt;        &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;\n 1 Hf100U           3        24        18          0.093         0.93\n 2 Hf100U           3        24        18          0.093         0.93\n 3 Hf100U           3        24        32          0.093         0.93\n 4 Hf100U           3        24        32          0.093         0.93\n 5 Hf101U           3        30        18          0.114         1.14\n 6 Hf101U           3        30        18          0.114         1.14\n 7 Hf101U           3        30        32          0.114         1.14\n 8 Hf101U           3        30        32          0.114         1.14\n 9 Hf102U           3        30        18          0.092         0.92\n10 Hf102U           3        30        18          0.092         0.92\n# ℹ 395 more rows\n# ℹ 3 more variables: `MessVol(ul)` &lt;dbl&gt;, slopeTDH &lt;dbl&gt;, ActivityTDH &lt;dbl&gt;\n\n\nEn caso de que los datos de interes estén en una hoja en particular usamos el argumento sheet=\n\nexcel_df&lt;- read_excel(\"data/actividad_enzimas.xlsx\", sheet = \"hoja1\")\n\nUn caso mas complicado es cuando nuestro datos inician unas filas mas abajo y en un determinado intervalo de columnas. Otro caso común es que los nombres de las columnas tengan símbolos especiales o que estén repetidos\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", skip = 3, na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\nEn caso de que tengamos otra información que nos este generando conflicto podemos especificar el rango de datos de interés\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nHeterogeneidad en los nombres de las columna\n\n\n\nObserva como los tibbles permite que haya símbolos, espacios, acentos y alternancia de mayúsculas y minúsculas en los nombres de las columnas. Sin embargo, al momento de trabajar, esta heterogeneidad puede darnos problemas. Esto se puede solucionar con el paquete janitor.\n\n\n\n\n\n\n\n\n\n\nEl paquete Janitor es una herramienta pequeña pero increíblemente útil y conveniente cuando se trata de limpiar y mantener conjuntos de datos en RStudio. Además, es un paquete orientado a “tidyverse”, por lo que se integra perfectamente con los pipes.\nRegresemos a los nombres de las columnas de nuestro archivo excel antes de utilizar janitor\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\n\n\n [1] \"Número de muestra\"        \"Número de experimento\"   \n [3] \"Tratamiento\"              \"Temperatura\"             \n [5] \"peso húmedo (g)\"          \"buffer (ml)\"             \n [7] \"volumen de reaccion (ul)\" \"concentración g/ml\"      \n [9] \"pendiente...9\"            \"pendiente...10\"          \n\n\n\nNo hay consistencia entre el uso de mayúsculas y minúsculas en los nombres. Recuerda que R es sensible a mayúsculas, por lo que Temperatura no es lo mismo que temperatura.\nTenemos símbolos como acentos que nos pueden generar conflictos, sobre todo si tenemos símbolos en otros idiomas.\nLos espacios en blanco así como otros símbolos como / son reemplazados por un punto. Esto genera etiquetas complicadas.\n\nLo ideal es tener consistencia en el formato de las etiquetas. Algunos formatos conocidos son los siguientes:\n\n\n\n\n\nAhora utilicemos janitor para limpiar las etiquetas\n\nlibrary(janitor)\n\nWarning: package 'janitor' was built under R version 4.3.1\n\n\n\nAttaching package: 'janitor'\n\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\n\n\nexcel_clean &lt;- clean_names(excel_df)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente_9 &lt;dbl&gt;, pendiente_10 &lt;dbl&gt;\n\n\nlas opciones son:\n\n“snake”\n“small_camel”\n“big_camel”\n“screaming_snake”\n“parsed”\n“lower_upper”\n“upper_lower”\n\npor ejemplo:\n\nexcel_clean &lt;- clean_names(excel_df, case = \"screaming_snake\")\nexcel_clean\n\n# A tibble: 405 × 10\n   NUMERO_DE_MUESTRA NUMERO_DE_EXPERIMENTO TRATAMIENTO TEMPERATURA PESO_HUMEDO_G\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: BUFFER_ML &lt;dbl&gt;, VOLUMEN_DE_REACCION_UL &lt;dbl&gt;,\n#   CONCENTRACION_G_ML &lt;dbl&gt;, PENDIENTE_9 &lt;dbl&gt;, PENDIENTE_10 &lt;dbl&gt;\n\n\nCon janitor podemos integrar la función make_clean_name al momento de importar datos ya sea con readxl o con readr. Por ejemplo:\n\nexcel_clean &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\",\n                       .name_repair =  make_clean_names)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWarning\n\n\n\nObserva que tanto readxl como readr interpretan las columnas de número de experimento, tratamiento y temperatura como variables numéricas debido a que analizan la cantidad de datos para inferir el tipo de variable. No obstante, estas variables son en realidad factores, ya que representan categorías. Más adelante veremos cómo realizar este ajuste de manera manual.\n\n\n\n\n\nUn aspecto importante para el análisis de datos es tener una perspectiva rápida del tibble o datafram para entender las variables que tenemos, asi como los patrones generales de los datos.\nHay varias funciones que podemos utilizar. Ya mencionamos algunas herramienta como head() o tail() para echar un vistazo a las primeras o últimas filas de la tabla, respectivamente.\nOtra herramienta es la función glimpse() de dplyr que nos muestra algunos datos de cada columna de nuestro tibble para tener una idea de la estructura de la tabla.\n\nglimpse(excel_clean)\n\nRows: 405\nColumns: 10\n$ numero_de_muestra      &lt;chr&gt; \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf101U…\n$ numero_de_experimento  &lt;dbl&gt; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,…\n$ tratamiento            &lt;dbl&gt; 24, 24, 24, 24, 30, 30, 30, 30, 30, 30, 30, 30,…\n$ temperatura            &lt;dbl&gt; 18, 18, 32, 32, 18, 18, 32, 32, 18, 18, 32, 32,…\n$ peso_humedo_g          &lt;dbl&gt; 0.093, 0.093, 0.093, 0.093, 0.114, 0.114, 0.114…\n$ buffer_ml              &lt;dbl&gt; 0.93, 0.93, 0.93, 0.93, 1.14, 1.14, 1.14, 1.14,…\n$ volumen_de_reaccion_ul &lt;dbl&gt; 20, 10, 20, 10, 20, 10, 20, 10, 20, 10, 20, 10,…\n$ concentracion_g_ml     &lt;dbl&gt; 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.…\n$ pendiente              &lt;dbl&gt; 0.0331, 0.0145, 0.1431, 0.0653, 0.0354, 0.0155,…\n$ pendiente_2            &lt;dbl&gt; 2.660772, 2.331190, 11.503215, 10.498392, 2.845…\n\n\nLa función summary() es parte de las funciones base de R y es particularmente útil cuando tenemos datos continuos, ya que nos muestra, para cada columna, los valores mínimos, máximos, promedio, mediana y el 1er y 3er quartil.\n\nsummary(excel_clean)\n\n numero_de_muestra  numero_de_experimento  tratamiento     temperatura   \n Length:405         Min.   :1.000         Min.   :18.00   Min.   :18.00  \n Class :character   1st Qu.:2.000         1st Qu.:24.00   1st Qu.:18.00  \n Mode  :character   Median :3.000         Median :24.00   Median :18.00  \n                    Mean   :2.528         Mean   :26.04   Mean   :24.74  \n                    3rd Qu.:4.000         3rd Qu.:30.00   3rd Qu.:32.00  \n                    Max.   :4.000         Max.   :32.00   Max.   :32.00  \n                                                                         \n peso_humedo_g       buffer_ml      volumen_de_reaccion_ul concentracion_g_ml\n Min.   :0.02900   Min.   :0.2900   Min.   :10.00          Min.   :0.1       \n 1st Qu.:0.06700   1st Qu.:0.6700   1st Qu.:10.00          1st Qu.:0.1       \n Median :0.08500   Median :0.8500   Median :20.00          Median :0.1       \n Mean   :0.08387   Mean   :0.8387   Mean   :15.04          Mean   :0.1       \n 3rd Qu.:0.09900   3rd Qu.:0.9900   3rd Qu.:20.00          3rd Qu.:0.1       \n Max.   :0.18900   Max.   :1.8900   Max.   :20.00          Max.   :0.1       \n                                                                             \n   pendiente        pendiente_2    \n Min.   :0.00000   Min.   : 0.000  \n 1st Qu.:0.01480   1st Qu.: 1.632  \n Median :0.03500   Median : 4.594  \n Mean   :0.04949   Mean   : 5.205  \n 3rd Qu.:0.07290   3rd Qu.: 8.163  \n Max.   :0.31390   Max.   :25.233  \n                   NA's   :13      \n\n\nOtra herramienta un poco mas sofisticada pero bastante útil es la función gt_plt_summary() del paquete gtExtras, la cual nos permite gráficar cada una de las variables, nos muestra los valores promedio, mediana y desvicación, y ádemas nos muestra el % de valores faltantes (missing).\nPara utilizar esta herramienta, primero necesitamos instalar el paquete gtExtras y posteriormente cargar la librería.\n\ninstall.packages(\"gtExtras\")\n\n\nlibrary(gtExtras)\n\nWarning: package 'gtExtras' was built under R version 4.3.1\n\ngt_plt_summary(excel_clean)\n\nWarning: Computation failed in `stat_bin()`\nCaused by error in `bin_breaks_width()`:\n! The number of histogram bins must be less than 1,000,000.\nℹ Did you make `binwidth` too small?\n\n\n\n\n\n\n  \n    \n      excel_clean\n    \n    \n      405 rows x 10 cols\n    \n    \n      \n      Column\n      Plot Overview\n      Missing\n      Mean\n      Median\n      SD\n    \n  \n  \n    \nnumero_de_muestra\n                  96 categories\n0.0%\n—\n—\n—\n    \nnumero_de_experimento\n                  14\n0.0%\n2.5\n3.0\n1.1\n    \ntratamiento\n                  1832\n0.0%\n26.0\n24.0\n5.4\n    \ntemperatura\n                  1832\n0.0%\n24.7\n18.0\n7.0\n    \npeso_humedo_g\n                  0.030.19\n0.0%\n0.1\n0.1\n0.0\n    \nbuffer_ml\n                  0.31.9\n0.0%\n0.8\n0.8\n0.3\n    \nvolumen_de_reaccion_ul\n                  1020\n0.0%\n15.0\n20.0\n5.0\n    \nconcentracion_g_ml\n                  00\n0.0%\n0.1\n0.1\n0.0\n    \npendiente\n                  0.000.31\n0.0%\n0.0\n0.0\n0.0\n    \npendiente_2\n                  025\n3.2%\n5.2\n4.6\n4.2\n  \n  \n  \n\n\n\n\n\n\n\nUna vez terminado nuestro análisis debemos guardarlo. Siguiendo la recomendación que vimos anteriormente, lo ideal es guardar los datos ya procesados (ya sea que se haya realizado algún tipo de filtrado o transformación) en una carpeta diferente a la carpeta donde están los datos crudos, los cuales se recomienda que se preserven sin alteraciones.\nPodemos crear una nueva carpeta con Archivos &gt; Nuevo directorio o desde la línea de comando usando la función dir.create()\n\ndir.create(\"resultados/tablas\", recursive = TRUE)\n\nWarning in dir.create(\"resultados/tablas\", recursive = TRUE):\n'resultados\\tablas' already exists\n\n\nPara guardar nuestros datos, las funciones que utilizaremos mas frecuentemente son write.table y write_csv()\nPor ejemplo, vamos a tomar las primeras filas de nuestro objeto excel_clean con la función head()\n\nexcel_subset &lt;- head(excel_clean)\nexcel_subset\n\n# A tibble: 6 × 10\n  numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n  &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n1 Hf100U                                3          24          18         0.093\n2 Hf100U                                3          24          18         0.093\n3 Hf100U                                3          24          32         0.093\n4 Hf100U                                3          24          32         0.093\n5 Hf101U                                3          30          18         0.114\n6 Hf101U                                3          30          18         0.114\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\nAhora lo guardamos en la carpeta que acabamos de crear usando la función write_csv()\n\nwrite_csv(excel_subset, file = \"resultados/tablas/excel_subset.csv\")\n\no con write.table() la cual nos permite usar una mayor diversidad de formatos\n\nwrite.table(excel_subset, file = \"resultados/tablas/excel_subset.txt\", sep = \"\\t\")"
  },
  {
    "objectID": "3_Data_import.html#funciones-base-para-importar-archivos",
    "href": "3_Data_import.html#funciones-base-para-importar-archivos",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "Para importar un archivo a nuestro ambiente podemos utilizar las funciones base read.table, read.csv, read.delim. Por ejemplo, para abrir un archivo txt separado por tabuladores utilizando la función:\n\ndf &lt;- read.table(\"data/palmer_penguins.txt\", header = TRUE, sep = \"\\t\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007\n\n\no usando read.csv\n\ndf &lt;- read.csv(\"data/palmer_penguins.csv\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007"
  },
  {
    "objectID": "3_Data_import.html#importar-datos-a-lá-tidyverse",
    "href": "3_Data_import.html#importar-datos-a-lá-tidyverse",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "Dentro del Tidyverse, la importación de datos rectangulares se realiza con el paquete readr el cual tiene funciones que van a sonar muy familiares:\n\nread_csv(): comma-separated values (CSV)\nread_tsv(): tab-separated values (TSV)\nread_csv2(): semicolon-separated values with , as the decimal mark\nread_delim(): delimited files (CSV and TSV are important special cases)\nread_table(): whitespace-separated files\n\n\n\n\n\n\n\n¿Has notado algo? 🧐\n\n\n\nComo ves, los nombres de las funciones son muy parecidas a las funciones base pero reemplazando el “.” por un “_”. Esta tendencia se repite en numerosas funciones que siguen la filosofía tidy. Por ejemplo, en lugar de la prueba shapiro.test, rstatix utiliza la función shapiro_test.\n\n\nHagamos la prueba…\n\nlibrary(tidyverse)\nlibrary(here)\n\n\ndf &lt;- read_table(\"data/palmer_penguins.txt\")\n\n\n── Column specification ────────────────────────────────────────────────────────\ncols(\n  species = col_character(),\n  island = col_character(),\n  bill_length_mm = col_double(),\n  bill_depth_mm = col_double(),\n  flipper_length_mm = col_double(),\n  body_mass_g = col_double(),\n  sex = col_character(),\n  year = col_double()\n)\n\n\nObserva como, aún antes de desplegar la tabla,read_table ya nos arroja información sobre la estructura de los datos y nos indica si cada columna es número, carácter o de otro tipo.\nAhora observa como se despliega la tabla\n\ndf\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\n\n\n\n¿double? ¿character? 😱\n\n\n\nEn caso de que no lo recuerdes, estos son los principales tipos de datos en R\n\n\n\nTipo\nDescripción\nEjemplo\n\n\nNumeric\ninterger números enteros\n0L, 1L\n\n\nNumeric\ndouble números reales\n1.0,\n\n\nLogic\nvalores booleanos\nTRUE, FALSE\n\n\nCharacter\ncadena de texto\n“Hola mundo”\n\n\nFactor\nrepresentan datos categóricos\nmacho, hembra\n\n\nDates\nFechas\n“2023-08-24”"
  },
  {
    "objectID": "3_Data_import.html#tibbles",
    "href": "3_Data_import.html#tibbles",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "Con R base, la función read.table nos genera un data frame pero readr nos genera un tibble los cuales son una versión actualizada de un data frame.\nHay varias diferencias entre tibbles y data.frames. Puedes leer mas en la viñeta. Sin embargo, algunas de las diferencias mas notables son:\n\nEl tipo de entrada permanece inalterado: los data.frames son conocidos por tratar las cadenas de texto como factores; esto no sucederá con los tibbles.\nLos nombres de las variables permanecen inalterados: En R base, al crear data.frames se eliminan los espacios de los nombres, convirtiéndolos en puntos o agregando una “x” antes de los nombres de las columnas numéricas. Al crear tibbles, los nombres de las variables (columnas) no cambian.\nNo hay row.names() para un tibble: Los datos ordenados requieren que las variables se almacenen de manera consistente, eliminando la necesidad de nombres de filas. Los tibbles imprimen las primeras diez filas y columnas que caben en una pantalla: Imprimir un tibble en la pantalla nunca mostrará todo el enorme marco de datos. Por defecto, solo muestra lo que cabe en tu pantalla.\n\n\n\nSi tenemos datos rectangulares como data.frame podemos convertirlo facilmente a tibble con la función as_tibble()\nPor ejemplo, podemos:\n\nas_tibble(trees)\n\n# A tibble: 31 × 3\n   Girth Height Volume\n   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1   8.3     70   10.3\n 2   8.6     65   10.3\n 3   8.8     63   10.2\n 4  10.5     72   16.4\n 5  10.7     81   18.8\n 6  10.8     83   19.7\n 7  11       66   15.6\n 8  11       75   18.2\n 9  11.1     80   22.6\n10  11.2     75   19.9\n# ℹ 21 more rows\n\n\n\n\n\n\n\n\nWarning\n\n\n\nRecuerda que si solo ejecutamos el comando as_tibble(trees) R solo nos arrojará el resutlado en la consola pero no hizo ningún cambio al objeto trees. Para esto necesitamos renombrar o generar un nuevo objeto. Por ejemplo\n\ntrees_tbl &lt;- as_tibble(trees)\n\nahora si, tenemos un nuevo objetvo como tibble\n\nclass(trees)\n\n[1] \"data.frame\"\n\nclass(trees_tbl)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\nAl igual que como lo hariamos con un data.frame o una matriz, podemos acceder a las primeras o últimas filas de nuestro tibble con las funciones head() y tail()\n\nhead(df)\n\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\ntail(df)\n\n# A tibble: 6 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Chinstrap Dream            45.7          17                 195        3650\n2 Chinstrap Dream            55.8          19.8               207        4000\n3 Chinstrap Dream            43.5          18.1               202        3400\n4 Chinstrap Dream            49.6          18.2               193        3775\n5 Chinstrap Dream            50.8          19                 210        4100\n6 Chinstrap Dream            50.2          18.7               198        3775\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\nTambién es posible hacer tibble sobre la marcha utilizando la función tibble(). Por ejemplo:\n\nmi_tibl &lt;- tibble(\n  a = 1:5,\n  b = 6:10,\n  c = 1,\n  z = (a + b)^2 + c\n)\n\nmi_tibl\n\n# A tibble: 5 × 4\n      a     b     c     z\n  &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     6     1    50\n2     2     7     1    82\n3     3     8     1   122\n4     4     9     1   170\n5     5    10     1   226\n\n\nNota que al momento de generar este tibble, puedes hacer referencias a columnas del mismo tibble (columa z)\nOtro comportamiento de los tibbles es que es posible tener nombres de columnas con espacios u otros caracteres y estos estarán rodeados por ``\n\nmi_tibl &lt;- tibble(\n  `cinco números` = 1:5,\n  `12` = \"numeric\",\n  `:)` = \"smile\",\n)\n\nmi_tibl\n\n# A tibble: 5 × 3\n  `cinco números` `12`    `:)` \n            &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;\n1               1 numeric smile\n2               2 numeric smile\n3               3 numeric smile\n4               4 numeric smile\n5               5 numeric smile"
  },
  {
    "objectID": "3_Data_import.html#importar-desde-excel",
    "href": "3_Data_import.html#importar-desde-excel",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "Las hojas de calculo de excel (formatos .xls o .xlsx) siguen siendo muy comunes y muy utilizados dentro de la comunidad académica.\nTidyverse no tiene dentro de su núcleo una función para importar este tipo de archivos, pero esto se soluciona fácilmente con el paquete readxl.\n\n\n\n\n\n\ninstall.packages(\"readxl\")\n\n\nlibrary(readxl)\n\nWarning: package 'readxl' was built under R version 4.3.1\n\n\nCon esto podemos usar la función read_excel() que no necesita ningún otro argumento mas que la ruta (path) donde se encuentra el archivo .xlsx\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\")\n\nexcel_df\n\n# A tibble: 405 × 9\n   `Sample ID` ExpNum TreatTemp Meas_Temp `WetWeight(g)` `buffer(ml)`\n   &lt;chr&gt;        &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;\n 1 Hf100U           3        24        18          0.093         0.93\n 2 Hf100U           3        24        18          0.093         0.93\n 3 Hf100U           3        24        32          0.093         0.93\n 4 Hf100U           3        24        32          0.093         0.93\n 5 Hf101U           3        30        18          0.114         1.14\n 6 Hf101U           3        30        18          0.114         1.14\n 7 Hf101U           3        30        32          0.114         1.14\n 8 Hf101U           3        30        32          0.114         1.14\n 9 Hf102U           3        30        18          0.092         0.92\n10 Hf102U           3        30        18          0.092         0.92\n# ℹ 395 more rows\n# ℹ 3 more variables: `MessVol(ul)` &lt;dbl&gt;, slopeTDH &lt;dbl&gt;, ActivityTDH &lt;dbl&gt;\n\n\nEn caso de que los datos de interes estén en una hoja en particular usamos el argumento sheet=\n\nexcel_df&lt;- read_excel(\"data/actividad_enzimas.xlsx\", sheet = \"hoja1\")\n\nUn caso mas complicado es cuando nuestro datos inician unas filas mas abajo y en un determinado intervalo de columnas. Otro caso común es que los nombres de las columnas tengan símbolos especiales o que estén repetidos\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", skip = 3, na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\nEn caso de que tengamos otra información que nos este generando conflicto podemos especificar el rango de datos de interés\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nHeterogeneidad en los nombres de las columna\n\n\n\nObserva como los tibbles permite que haya símbolos, espacios, acentos y alternancia de mayúsculas y minúsculas en los nombres de las columnas. Sin embargo, al momento de trabajar, esta heterogeneidad puede darnos problemas. Esto se puede solucionar con el paquete janitor."
  },
  {
    "objectID": "3_Data_import.html#limpiar-etiquetas-con-janitor",
    "href": "3_Data_import.html#limpiar-etiquetas-con-janitor",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "El paquete Janitor es una herramienta pequeña pero increíblemente útil y conveniente cuando se trata de limpiar y mantener conjuntos de datos en RStudio. Además, es un paquete orientado a “tidyverse”, por lo que se integra perfectamente con los pipes.\nRegresemos a los nombres de las columnas de nuestro archivo excel antes de utilizar janitor\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\n\n\n [1] \"Número de muestra\"        \"Número de experimento\"   \n [3] \"Tratamiento\"              \"Temperatura\"             \n [5] \"peso húmedo (g)\"          \"buffer (ml)\"             \n [7] \"volumen de reaccion (ul)\" \"concentración g/ml\"      \n [9] \"pendiente...9\"            \"pendiente...10\"          \n\n\n\nNo hay consistencia entre el uso de mayúsculas y minúsculas en los nombres. Recuerda que R es sensible a mayúsculas, por lo que Temperatura no es lo mismo que temperatura.\nTenemos símbolos como acentos que nos pueden generar conflictos, sobre todo si tenemos símbolos en otros idiomas.\nLos espacios en blanco así como otros símbolos como / son reemplazados por un punto. Esto genera etiquetas complicadas.\n\nLo ideal es tener consistencia en el formato de las etiquetas. Algunos formatos conocidos son los siguientes:\n\n\n\n\n\nAhora utilicemos janitor para limpiar las etiquetas\n\nlibrary(janitor)\n\nWarning: package 'janitor' was built under R version 4.3.1\n\n\n\nAttaching package: 'janitor'\n\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\n\n\nexcel_clean &lt;- clean_names(excel_df)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente_9 &lt;dbl&gt;, pendiente_10 &lt;dbl&gt;\n\n\nlas opciones son:\n\n“snake”\n“small_camel”\n“big_camel”\n“screaming_snake”\n“parsed”\n“lower_upper”\n“upper_lower”\n\npor ejemplo:\n\nexcel_clean &lt;- clean_names(excel_df, case = \"screaming_snake\")\nexcel_clean\n\n# A tibble: 405 × 10\n   NUMERO_DE_MUESTRA NUMERO_DE_EXPERIMENTO TRATAMIENTO TEMPERATURA PESO_HUMEDO_G\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: BUFFER_ML &lt;dbl&gt;, VOLUMEN_DE_REACCION_UL &lt;dbl&gt;,\n#   CONCENTRACION_G_ML &lt;dbl&gt;, PENDIENTE_9 &lt;dbl&gt;, PENDIENTE_10 &lt;dbl&gt;\n\n\nCon janitor podemos integrar la función make_clean_name al momento de importar datos ya sea con readxl o con readr. Por ejemplo:\n\nexcel_clean &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\",\n                       .name_repair =  make_clean_names)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWarning\n\n\n\nObserva que tanto readxl como readr interpretan las columnas de número de experimento, tratamiento y temperatura como variables numéricas debido a que analizan la cantidad de datos para inferir el tipo de variable. No obstante, estas variables son en realidad factores, ya que representan categorías. Más adelante veremos cómo realizar este ajuste de manera manual."
  },
  {
    "objectID": "3_Data_import.html#echando-un-vistado-a-los-datos",
    "href": "3_Data_import.html#echando-un-vistado-a-los-datos",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "Un aspecto importante para el análisis de datos es tener una perspectiva rápida del tibble o datafram para entender las variables que tenemos, asi como los patrones generales de los datos.\nHay varias funciones que podemos utilizar. Ya mencionamos algunas herramienta como head() o tail() para echar un vistazo a las primeras o últimas filas de la tabla, respectivamente.\nOtra herramienta es la función glimpse() de dplyr que nos muestra algunos datos de cada columna de nuestro tibble para tener una idea de la estructura de la tabla.\n\nglimpse(excel_clean)\n\nRows: 405\nColumns: 10\n$ numero_de_muestra      &lt;chr&gt; \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf101U…\n$ numero_de_experimento  &lt;dbl&gt; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,…\n$ tratamiento            &lt;dbl&gt; 24, 24, 24, 24, 30, 30, 30, 30, 30, 30, 30, 30,…\n$ temperatura            &lt;dbl&gt; 18, 18, 32, 32, 18, 18, 32, 32, 18, 18, 32, 32,…\n$ peso_humedo_g          &lt;dbl&gt; 0.093, 0.093, 0.093, 0.093, 0.114, 0.114, 0.114…\n$ buffer_ml              &lt;dbl&gt; 0.93, 0.93, 0.93, 0.93, 1.14, 1.14, 1.14, 1.14,…\n$ volumen_de_reaccion_ul &lt;dbl&gt; 20, 10, 20, 10, 20, 10, 20, 10, 20, 10, 20, 10,…\n$ concentracion_g_ml     &lt;dbl&gt; 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.…\n$ pendiente              &lt;dbl&gt; 0.0331, 0.0145, 0.1431, 0.0653, 0.0354, 0.0155,…\n$ pendiente_2            &lt;dbl&gt; 2.660772, 2.331190, 11.503215, 10.498392, 2.845…\n\n\nLa función summary() es parte de las funciones base de R y es particularmente útil cuando tenemos datos continuos, ya que nos muestra, para cada columna, los valores mínimos, máximos, promedio, mediana y el 1er y 3er quartil.\n\nsummary(excel_clean)\n\n numero_de_muestra  numero_de_experimento  tratamiento     temperatura   \n Length:405         Min.   :1.000         Min.   :18.00   Min.   :18.00  \n Class :character   1st Qu.:2.000         1st Qu.:24.00   1st Qu.:18.00  \n Mode  :character   Median :3.000         Median :24.00   Median :18.00  \n                    Mean   :2.528         Mean   :26.04   Mean   :24.74  \n                    3rd Qu.:4.000         3rd Qu.:30.00   3rd Qu.:32.00  \n                    Max.   :4.000         Max.   :32.00   Max.   :32.00  \n                                                                         \n peso_humedo_g       buffer_ml      volumen_de_reaccion_ul concentracion_g_ml\n Min.   :0.02900   Min.   :0.2900   Min.   :10.00          Min.   :0.1       \n 1st Qu.:0.06700   1st Qu.:0.6700   1st Qu.:10.00          1st Qu.:0.1       \n Median :0.08500   Median :0.8500   Median :20.00          Median :0.1       \n Mean   :0.08387   Mean   :0.8387   Mean   :15.04          Mean   :0.1       \n 3rd Qu.:0.09900   3rd Qu.:0.9900   3rd Qu.:20.00          3rd Qu.:0.1       \n Max.   :0.18900   Max.   :1.8900   Max.   :20.00          Max.   :0.1       \n                                                                             \n   pendiente        pendiente_2    \n Min.   :0.00000   Min.   : 0.000  \n 1st Qu.:0.01480   1st Qu.: 1.632  \n Median :0.03500   Median : 4.594  \n Mean   :0.04949   Mean   : 5.205  \n 3rd Qu.:0.07290   3rd Qu.: 8.163  \n Max.   :0.31390   Max.   :25.233  \n                   NA's   :13      \n\n\nOtra herramienta un poco mas sofisticada pero bastante útil es la función gt_plt_summary() del paquete gtExtras, la cual nos permite gráficar cada una de las variables, nos muestra los valores promedio, mediana y desvicación, y ádemas nos muestra el % de valores faltantes (missing).\nPara utilizar esta herramienta, primero necesitamos instalar el paquete gtExtras y posteriormente cargar la librería.\n\ninstall.packages(\"gtExtras\")\n\n\nlibrary(gtExtras)\n\nWarning: package 'gtExtras' was built under R version 4.3.1\n\ngt_plt_summary(excel_clean)\n\nWarning: Computation failed in `stat_bin()`\nCaused by error in `bin_breaks_width()`:\n! The number of histogram bins must be less than 1,000,000.\nℹ Did you make `binwidth` too small?\n\n\n\n\n\n\n  \n    \n      excel_clean\n    \n    \n      405 rows x 10 cols\n    \n    \n      \n      Column\n      Plot Overview\n      Missing\n      Mean\n      Median\n      SD\n    \n  \n  \n    \nnumero_de_muestra\n                  96 categories\n0.0%\n—\n—\n—\n    \nnumero_de_experimento\n                  14\n0.0%\n2.5\n3.0\n1.1\n    \ntratamiento\n                  1832\n0.0%\n26.0\n24.0\n5.4\n    \ntemperatura\n                  1832\n0.0%\n24.7\n18.0\n7.0\n    \npeso_humedo_g\n                  0.030.19\n0.0%\n0.1\n0.1\n0.0\n    \nbuffer_ml\n                  0.31.9\n0.0%\n0.8\n0.8\n0.3\n    \nvolumen_de_reaccion_ul\n                  1020\n0.0%\n15.0\n20.0\n5.0\n    \nconcentracion_g_ml\n                  00\n0.0%\n0.1\n0.1\n0.0\n    \npendiente\n                  0.000.31\n0.0%\n0.0\n0.0\n0.0\n    \npendiente_2\n                  025\n3.2%\n5.2\n4.6\n4.2"
  },
  {
    "objectID": "3_Data_import.html#exportar-datos",
    "href": "3_Data_import.html#exportar-datos",
    "title": "Leccion 1: Importar y limpiar archivos",
    "section": "",
    "text": "Una vez terminado nuestro análisis debemos guardarlo. Siguiendo la recomendación que vimos anteriormente, lo ideal es guardar los datos ya procesados (ya sea que se haya realizado algún tipo de filtrado o transformación) en una carpeta diferente a la carpeta donde están los datos crudos, los cuales se recomienda que se preserven sin alteraciones.\nPodemos crear una nueva carpeta con Archivos &gt; Nuevo directorio o desde la línea de comando usando la función dir.create()\n\ndir.create(\"resultados/tablas\", recursive = TRUE)\n\nWarning in dir.create(\"resultados/tablas\", recursive = TRUE):\n'resultados\\tablas' already exists\n\n\nPara guardar nuestros datos, las funciones que utilizaremos mas frecuentemente son write.table y write_csv()\nPor ejemplo, vamos a tomar las primeras filas de nuestro objeto excel_clean con la función head()\n\nexcel_subset &lt;- head(excel_clean)\nexcel_subset\n\n# A tibble: 6 × 10\n  numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n  &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n1 Hf100U                                3          24          18         0.093\n2 Hf100U                                3          24          18         0.093\n3 Hf100U                                3          24          32         0.093\n4 Hf100U                                3          24          32         0.093\n5 Hf101U                                3          30          18         0.114\n6 Hf101U                                3          30          18         0.114\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\nAhora lo guardamos en la carpeta que acabamos de crear usando la función write_csv()\n\nwrite_csv(excel_subset, file = \"resultados/tablas/excel_subset.csv\")\n\no con write.table() la cual nos permite usar una mayor diversidad de formatos\n\nwrite.table(excel_subset, file = \"resultados/tablas/excel_subset.txt\", sep = \"\\t\")"
  },
  {
    "objectID": "4_data_wrangling.html",
    "href": "4_data_wrangling.html",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "",
    "text": "Tidy Data es un concepto fundamental dentro del ecosistema Tidyverse en R que se centra en la organización y manipulación eficiente de datos para análisis y visualización.\nEn el contexto de Tidy Data, se busca estructurar los conjuntos de datos de manera que cada observación sea una fila, cada variable sea una columna y cada valor tenga su propia celda. Esto permite que los datos estén organizados en un formato uniforme y consistente, lo que facilita su manipulación y análisis. En resumen, los principios de Tidy Data son:\nEn resumen, un tidy data sigue las siguientes características:\n\nCada variable debe tener su propia columna\nCada observación debe tener su propia fila\nCada valor debe tener su propia celda"
  },
  {
    "objectID": "4_data_wrangling.html#seleccinar-columnas-con-select",
    "href": "4_data_wrangling.html#seleccinar-columnas-con-select",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "Seleccinar columnas con select()",
    "text": "Seleccinar columnas con select()\nPermite seleccionar una o varias columnas de un tibble o data.frame.\nPor ejemplo, si queremos seleccionar solamente las columnas Name, y Attack\n\nselect(pokemon, name, attack)\n\n# A tibble: 801 × 2\n   name       attack\n   &lt;chr&gt;       &lt;dbl&gt;\n 1 Bulbasaur      49\n 2 Ivysaur        62\n 3 Venusaur      100\n 4 Charmander     52\n 5 Charmeleon     64\n 6 Charizard     104\n 7 Squirtle       48\n 8 Wartortle      63\n 9 Blastoise     103\n10 Caterpie       30\n# ℹ 791 more rows\n\n\nRecuerda que si queremos generar un nuevo objeto con ese subset de datos tenemos que asignarlo a otro objeto.\n\npokemon_sub &lt;- select(pokemon, name, attack)\npokemon_sub\n\n# A tibble: 801 × 2\n   name       attack\n   &lt;chr&gt;       &lt;dbl&gt;\n 1 Bulbasaur      49\n 2 Ivysaur        62\n 3 Venusaur      100\n 4 Charmander     52\n 5 Charmeleon     64\n 6 Charizard     104\n 7 Squirtle       48\n 8 Wartortle      63\n 9 Blastoise     103\n10 Caterpie       30\n# ℹ 791 more rows\n\n\nCon select() tambien podemos seleccionar todo menos una columna especifica con el operador -\n\npokemon_sub &lt;- select(pokemon, -attack)\npokemon_sub\n\n# A tibble: 801 × 12\n   pokedex_number name  defense    hp percentage_male sp_attack sp_defense speed\n            &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n 1              1 Bulb…      49    45            88.1        65         65    45\n 2              2 Ivys…      63    60            88.1        80         80    60\n 3              3 Venu…     123    80            88.1       122        120    80\n 4              4 Char…      43    39            88.1        60         50    65\n 5              5 Char…      58    58            88.1        80         65    80\n 6              6 Char…      78    78            88.1       159        115   100\n 7              7 Squi…      65    44            88.1        50         64    43\n 8              8 Wart…      80    59            88.1        65         80    58\n 9              9 Blas…     120    79            88.1       135        115    78\n10             10 Cate…      35    45            50          20         20    45\n# ℹ 791 more rows\n# ℹ 4 more variables: type1 &lt;chr&gt;, weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;,\n#   is_legendary &lt;dbl&gt;\n\n\no podemos seleccionar un intervalo de columnas\n\npokemon_sub &lt;- select(pokemon, name, attack:hp)\n\no lo inverso para descargar un intervalo de columnas\n\npokemon_sub &lt;- select(pokemon, -(attack:hp))"
  },
  {
    "objectID": "4_data_wrangling.html#seleccionar-columnas-con-select",
    "href": "4_data_wrangling.html#seleccionar-columnas-con-select",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "2.1 Seleccionar columnas con select()",
    "text": "2.1 Seleccionar columnas con select()\nPermite seleccionar una o varias columnas de un tibble o data.frame.\nPor ejemplo, si queremos seleccionar solamente las columnas Name, y Attack\n\nselect(pokemon, name, attack)\n\n# A tibble: 801 × 2\n   name       attack\n   &lt;chr&gt;       &lt;dbl&gt;\n 1 Bulbasaur      49\n 2 Ivysaur        62\n 3 Venusaur      100\n 4 Charmander     52\n 5 Charmeleon     64\n 6 Charizard     104\n 7 Squirtle       48\n 8 Wartortle      63\n 9 Blastoise     103\n10 Caterpie       30\n# ℹ 791 more rows\n\n\nRecuerda que si queremos generar un nuevo objeto con ese subset de datos tenemos que asignarlo a otro objeto.\n\npokemon_sub &lt;- select(pokemon, name, attack)\npokemon_sub\n\n# A tibble: 801 × 2\n   name       attack\n   &lt;chr&gt;       &lt;dbl&gt;\n 1 Bulbasaur      49\n 2 Ivysaur        62\n 3 Venusaur      100\n 4 Charmander     52\n 5 Charmeleon     64\n 6 Charizard     104\n 7 Squirtle       48\n 8 Wartortle      63\n 9 Blastoise     103\n10 Caterpie       30\n# ℹ 791 more rows\n\n\nCon select() tambien podemos seleccionar todo menos una columna especifica con el operador -\n\npokemon_sub &lt;- select(pokemon, -attack)\npokemon_sub\n\n# A tibble: 801 × 12\n   pokedex_number name  defense    hp percentage_male sp_attack sp_defense speed\n            &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n 1              1 Bulb…      49    45            88.1        65         65    45\n 2              2 Ivys…      63    60            88.1        80         80    60\n 3              3 Venu…     123    80            88.1       122        120    80\n 4              4 Char…      43    39            88.1        60         50    65\n 5              5 Char…      58    58            88.1        80         65    80\n 6              6 Char…      78    78            88.1       159        115   100\n 7              7 Squi…      65    44            88.1        50         64    43\n 8              8 Wart…      80    59            88.1        65         80    58\n 9              9 Blas…     120    79            88.1       135        115    78\n10             10 Cate…      35    45            50          20         20    45\n# ℹ 791 more rows\n# ℹ 4 more variables: type1 &lt;chr&gt;, weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;,\n#   is_legendary &lt;dbl&gt;\n\n\no podemos seleccionar un intervalo de columnas\n\npokemon_sub &lt;- select(pokemon, name, attack:hp)\npokemon_sub\n\n# A tibble: 801 × 4\n   name       attack defense    hp\n   &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n 1 Bulbasaur      49      49    45\n 2 Ivysaur        62      63    60\n 3 Venusaur      100     123    80\n 4 Charmander     52      43    39\n 5 Charmeleon     64      58    58\n 6 Charizard     104      78    78\n 7 Squirtle       48      65    44\n 8 Wartortle      63      80    59\n 9 Blastoise     103     120    79\n10 Caterpie       30      35    45\n# ℹ 791 more rows\n\n\no lo inverso para descargar un intervalo de columnas\n\npokemon_sub &lt;- select(pokemon, -(attack:hp))\npokemon_sub\n\n# A tibble: 801 × 10\n   pokedex_number name       percentage_male sp_attack sp_defense speed type1\n            &lt;dbl&gt; &lt;chr&gt;                &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n 1              1 Bulbasaur             88.1        65         65    45 grass\n 2              2 Ivysaur               88.1        80         80    60 grass\n 3              3 Venusaur              88.1       122        120    80 grass\n 4              4 Charmander            88.1        60         50    65 fire \n 5              5 Charmeleon            88.1        80         65    80 fire \n 6              6 Charizard             88.1       159        115   100 fire \n 7              7 Squirtle              88.1        50         64    43 water\n 8              8 Wartortle             88.1        65         80    58 water\n 9              9 Blastoise             88.1       135        115    78 water\n10             10 Caterpie              50          20         20    45 bug  \n# ℹ 791 more rows\n# ℹ 3 more variables: weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\nLa función everything() se puede seleccionar todo, y con esto es factible combiar el orden de las columnas. Por ejemplo, si queremos que la primera columna sea type ejecutamos:\n\nselect(pokemon, type1, everything())\n\n# A tibble: 801 × 13\n   type1 pokedex_number name      attack defense    hp percentage_male sp_attack\n   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1 grass              1 Bulbasaur     49      49    45            88.1        65\n 2 grass              2 Ivysaur       62      63    60            88.1        80\n 3 grass              3 Venusaur     100     123    80            88.1       122\n 4 fire               4 Charmand…     52      43    39            88.1        60\n 5 fire               5 Charmele…     64      58    58            88.1        80\n 6 fire               6 Charizard    104      78    78            88.1       159\n 7 water              7 Squirtle      48      65    44            88.1        50\n 8 water              8 Wartortle     63      80    59            88.1        65\n 9 water              9 Blastoise    103     120    79            88.1       135\n10 bug               10 Caterpie      30      35    45            50          20\n# ℹ 791 more rows\n# ℹ 5 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, weight_kg &lt;dbl&gt;,\n#   generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n2.1.1 Seleccionar variables con un patrón\nEstas funcionen ayudad a seleccionar variables según un patrón determinado\n\nstarts_with(): Inicia con un prefijo exacto\nends_with(): Finaliza con un sufijo exacto\ncontains(): Contiene una cadena literal\n\nPor ejemplo, podemos seleccionar las columnas de Sp attack y Sp deffense utilizando el prefijo sp\n\nselect(pokemon, name, starts_with(\"sp_\"))\n\n# A tibble: 801 × 3\n   name       sp_attack sp_defense\n   &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt;\n 1 Bulbasaur         65         65\n 2 Ivysaur           80         80\n 3 Venusaur         122        120\n 4 Charmander        60         50\n 5 Charmeleon        80         65\n 6 Charizard        159        115\n 7 Squirtle          50         64\n 8 Wartortle         65         80\n 9 Blastoise        135        115\n10 Caterpie          20         20\n# ℹ 791 more rows\n\n\nO podemos seleccionar las variables relacionadas con ataque (attack)\n\nselect(pokemon, name, contains(\"attack\"))\n\n# A tibble: 801 × 3\n   name       attack sp_attack\n   &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n 1 Bulbasaur      49        65\n 2 Ivysaur        62        80\n 3 Venusaur      100       122\n 4 Charmander     52        60\n 5 Charmeleon     64        80\n 6 Charizard     104       159\n 7 Squirtle       48        50\n 8 Wartortle      63        65\n 9 Blastoise     103       135\n10 Caterpie       30        20\n# ℹ 791 more rows"
  },
  {
    "objectID": "4_data_wrangling.html#seleccionar-variables-con-un-patrón",
    "href": "4_data_wrangling.html#seleccionar-variables-con-un-patrón",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "2.2 Seleccionar variables con un patrón",
    "text": "2.2 Seleccionar variables con un patrón\nEstas funcionen ayudad a seleccionar variables según un patrón determinado\n\nstarts_with(): Inicia con un prefijo exacto\nends_with(): Finaliza con un sufijo exacto\ncontains(): Contiene una cadena literal"
  },
  {
    "objectID": "4_data_wrangling.html#filtrar-variables-con-filter",
    "href": "4_data_wrangling.html#filtrar-variables-con-filter",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "2.2 Filtrar variables con filter()",
    "text": "2.2 Filtrar variables con filter()\n\nLa función filter() nos permite filtrar los elementos de una variable (columna) que cumplan con una condición especifica.\nPor ejemplo, para filtrar pokemon que tengan un nivel de ataque (Attack) superior a 100 usariamos\n\nfilter(pokemon, attack &gt; 100)\n\n# A tibble: 169 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              6 Charizard     104      78    78            88.1       159\n 2              9 Blastoise     103     120    79            88.1       135\n 3             15 Beedrill      150      40    65            50          15\n 4             34 Nidoking      102      77    81           100          85\n 5             57 Primeape      105      60    65            50          60\n 6             59 Arcanine      110      80    90            75.4       100\n 7             68 Machamp       130      80    90            75.4        65\n 8             71 Victreebel    105      65    80            50         100\n 9             76 Golem         120     130    80            50          55\n10             85 Dodrio        110      70    60            50          60\n# ℹ 159 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\nPara establecer varios condiciones, simplemente las podemos separar por una ,. Por ejemplo, si queremos filtrar a los pokemon que tengan un nivel de ataque mayor a 100 y que sea de tipo fuego (fire)\n\nfilter(pokemon, attack &gt; 100, type1 == \"fire\")\n\n# A tibble: 11 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              6 Charizard     104      78    78            88.1       159\n 2             59 Arcanine      110      80    90            75.4       100\n 3            136 Flareon       130      60    65            88.1        95\n 4            244 Entei         115      85   115            NA          90\n 5            250 Ho-Oh         130      90   106            NA         110\n 6            257 Blaziken      160      80    80            88.1       130\n 7            323 Camerupt      120     100    70            50         145\n 8            392 Infernape     104      71    76            88.1       104\n 9            500 Emboar        123      65   110            88.1       100\n10            721 Volcanion     110     120    80            NA         130\n11            727 Incineroar    115      90    95            88.1        80\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\nTip\n\n\n\nSi tienes muchas condiciones, puedes escribir cada condición en una línea diferente para evitar líneas de código muy largas\n\nfilter(pokemon, attack &gt; 100,\n       type1 == \"fire\",\n       generation == 1, \n       speed &gt; 50)\n\n\n\nSi queremos filtrar distintas condiciones de una misma variable (columna) podemos usar el operador %in%.\nPor ejemplo, para filtar los pokemon que sean de tipo fuego y agua\n\nfilter(pokemon, type1 %in% c(\"fire\", \"water\"))\n\n# A tibble: 166 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              4 Charmander     52      43    39            88.1        60\n 2              5 Charmeleon     64      58    58            88.1        80\n 3              6 Charizard     104      78    78            88.1       159\n 4              7 Squirtle       48      65    44            88.1        50\n 5              8 Wartortle      63      80    59            88.1        65\n 6              9 Blastoise     103     120    79            88.1       135\n 7             37 Vulpix         41      40    38            24.6        50\n 8             38 Ninetales      67      75    73            24.6        81\n 9             54 Psyduck        52      48    50            50          65\n10             55 Golduck        82      78    80            50          95\n# ℹ 156 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\nNota\n\n\n\nSi tienes muchas condiciones o si tienes las mismas condiciones que quieres filtrar en distintos sets de datos, puedes hacer un vector y despues incorporarlo en la funcion filter. Por ejemplo\n\ntipos &lt;- c(\"fire\", \"normal\", \"water\")\n\nfilter(pokemon, type1 %in% tipos)\n\n# A tibble: 271 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              4 Charmander     52      43    39            88.1        60\n 2              5 Charmeleon     64      58    58            88.1        80\n 3              6 Charizard     104      78    78            88.1       159\n 4              7 Squirtle       48      65    44            88.1        50\n 5              8 Wartortle      63      80    59            88.1        65\n 6              9 Blastoise     103     120    79            88.1       135\n 7             16 Pidgey         45      40    40            50          35\n 8             17 Pidgeotto      60      55    63            50          50\n 9             18 Pidgeot        80      80    83            50         135\n10             19 Rattata        56      35    30            50          25\n# ℹ 261 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\nEs posbile filtrar un intervalo de valores utilizando la función between(). Esta función requiere como argumentos el nombre de la variable que queremos filtrar, el límite inferior y el límite superior.\nPor ejemplo, si queremos filtrar los pokemon que tengan un nivel de ataque (attack) mayor a 100 pero menor a 150\n\nfilter(pokemon, between(attack, 100, 150))\n\n# A tibble: 191 × 13\n   pokedex_number name      attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              3 Venusaur     100     123    80            88.1       122\n 2              6 Charizard    104      78    78            88.1       159\n 3              9 Blastoise    103     120    79            88.1       135\n 4             15 Beedrill     150      40    65            50          15\n 5             28 Sandslash    100     120    75            50          25\n 6             34 Nidoking     102      77    81           100          85\n 7             51 Dugtrio      100      60    35            50          50\n 8             57 Primeape     105      60    65            50          60\n 9             59 Arcanine     110      80    90            75.4       100\n10             67 Machoke      100      70    80            75.4        50\n# ℹ 181 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\nPodemos usar la operación opuesta utilizando el operado !\n\nfilter(pokemon, !between(attack, 100, 150))\n\n# A tibble: 610 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              1 Bulbasaur      49      49    45            88.1        65\n 2              2 Ivysaur        62      63    60            88.1        80\n 3              4 Charmander     52      43    39            88.1        60\n 4              5 Charmeleon     64      58    58            88.1        80\n 5              7 Squirtle       48      65    44            88.1        50\n 6              8 Wartortle      63      80    59            88.1        65\n 7             10 Caterpie       30      35    45            50          20\n 8             11 Metapod        20      55    50            50          25\n 9             12 Butterfree     45      50    60            50          90\n10             13 Weedle         35      50    40            50          20\n# ℹ 600 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\nEjercicio: ¿¡QUIEN ES ESE POKEMON!? 📣\n\n\n\n\n\n\n\n\nNuestro pokémon tiene un valor de HP entre 100 y 200; valor de velocidad menor a 50; es del tipo1 Normal; tiene un valor de defensa menor a 40 y pertenece a la primera generación\n\n\nver codigo\nfilter(pokemon, between(hp, 100, 200),\n       speed &lt; 50,\n       type1 == \"normal\",\n       defense &lt; 40,\n       generation == 1)\n\n\n\n\n\n2.2.1 Filtrar variables con un patrón\nTambien es posible filtrar una variable a partir de un caracter en especifico usando la función str_detect().\n\nfilter(pokemon, str_detect(name, \"eon\"))\n\n# A tibble: 13 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              5 Charmeleon     64      58    58            88.1        80\n 2            134 Vaporeon       65      60   130            88.1       110\n 3            135 Jolteon        65      60    65            88.1       110\n 4            136 Flareon       130      60    65            88.1        95\n 5            196 Espeon         65      60    65            88.1       130\n 6            197 Umbreon        65     110    95            88.1        60\n 7            352 Kecleon        90      70    60            50          60\n 8            395 Empoleon       86      88    84            88.1       111\n 9            456 Finneon        49      56    49            50          49\n10            457 Lumineon       69      76    69            50          69\n11            470 Leafeon       110     130    65            88.1        60\n12            471 Glaceon        60     110    65            88.1       130\n13            700 Sylveon        65      65    95            88.1       110\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\nEjercicio: Una galaxía muy lejana…\n\n\n\nAbre la tabla starwars que se encuentra en el directorio de databases y genera los siguientes objetos:\n\nUna tabla que incluya solamente el nombre del personaje y todas las variables relacionadas con colores.\nUna tabla que incluya solamente los personajes femeninos del planeta Naboo.\nUna tabla con los personajes que hayan aparecido en Attack of the Clones."
  },
  {
    "objectID": "4_data_wrangling.html#ejercicio-1-quien-es-ese-pokemon",
    "href": "4_data_wrangling.html#ejercicio-1-quien-es-ese-pokemon",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "2.3 Ejercicio 1: ¿¡QUIEN ES ESE POKEMON!? 📣",
    "text": "2.3 Ejercicio 1: ¿¡QUIEN ES ESE POKEMON!? 📣\n\n\n\n\n\nNuestro pokemon tiene un valor de HP entre 100 y 200; valor de velocidad menor a 50; es del tipo1 Normal; tiene un valor de defensa menor a 40 y pertenece a la primera generación\n\nfilter(pokemon, between(hp, 100, 200),\n       speed &lt; 50,\n       type1 == \"normal\",\n       defense &lt; 40,\n       generation == 1)\n\n# A tibble: 1 × 13\n  pokedex_number name  attack defense    hp percentage_male sp_attack sp_defense\n           &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n1             39 Jigg…     45      20   115            24.6        45         25\n# ℹ 5 more variables: speed &lt;dbl&gt;, type1 &lt;chr&gt;, weight_kg &lt;dbl&gt;,\n#   generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;"
  },
  {
    "objectID": "4_data_wrangling.html#ejercicio",
    "href": "4_data_wrangling.html#ejercicio",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "2.3 Ejercicio",
    "text": "2.3 Ejercicio\nAbre la tabla starwars que se encuentra en el directorio de databases y genera los siguientes objetos:\n\ntabla que incluya solamente el nombre del personaje y todas las variables relacionadas con colores.\nUna tabla ue incluya solamente los personajes femeninos del planeta Naboo.\nUna tabla con los personajes que hayan aparecido en Attack of the Clones."
  },
  {
    "objectID": "4_data_wrangling.html#transformar-o-crear-columnas-con-mutate",
    "href": "4_data_wrangling.html#transformar-o-crear-columnas-con-mutate",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "2.3 Transformar o crear columnas con mutate()",
    "text": "2.3 Transformar o crear columnas con mutate()\n\n\n\n\n\nLa función mutate() es una función versatil en el sentido que nos permite crear nuevas variables que contengan alguna operación a partir de las que ya tenemos, añadir una nueva variable o transformar una variable ya existente\nPor ejemplo, podemos generar una nueva columna llamada “at_df_ratio” con la propoción de los valores de Ataque sobre Defensa\n\npokemon_mutate &lt;- mutate(pokemon, at_df_ratio = attack/defense )\n\nhead(pokemon_mutate$at_df_ratio)\n\n[1] 1.0000000 0.9841270 0.8130081 1.2093023 1.1034483 1.3333333\n\n\nDe igual manera, se pueden generar diversas nuevas columnas en una misma función separadas por comas.\n\npokemon_mutate &lt;- mutate(pokemon, \n                         at_df_ratio = attack/defense,\n                         at_df_per = at_df_ratio * 100,\n                         nueva_col = \"nueva columna\")\n\npokemon_mutate\n\n# A tibble: 801 × 16\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              1 Bulbasaur      49      49    45            88.1        65\n 2              2 Ivysaur        62      63    60            88.1        80\n 3              3 Venusaur      100     123    80            88.1       122\n 4              4 Charmander     52      43    39            88.1        60\n 5              5 Charmeleon     64      58    58            88.1        80\n 6              6 Charizard     104      78    78            88.1       159\n 7              7 Squirtle       48      65    44            88.1        50\n 8              8 Wartortle      63      80    59            88.1        65\n 9              9 Blastoise     103     120    79            88.1       135\n10             10 Caterpie       30      35    45            50          20\n# ℹ 791 more rows\n# ℹ 9 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;, at_df_ratio &lt;dbl&gt;,\n#   at_df_per &lt;dbl&gt;, nueva_col &lt;chr&gt;\n\n\nCon mutate(), también es posible cambiar el tipo de dato de cada columna. Por ejemplo, cambiar la columna “Type1” de carácter a factor:\n\npokemon_mutate &lt;- mutate(pokemon, type1 = factor(type1))\npokemon_mutate\n\n# A tibble: 801 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              1 Bulbasaur      49      49    45            88.1        65\n 2              2 Ivysaur        62      63    60            88.1        80\n 3              3 Venusaur      100     123    80            88.1       122\n 4              4 Charmander     52      43    39            88.1        60\n 5              5 Charmeleon     64      58    58            88.1        80\n 6              6 Charizard     104      78    78            88.1       159\n 7              7 Squirtle       48      65    44            88.1        50\n 8              8 Wartortle      63      80    59            88.1        65\n 9              9 Blastoise     103     120    79            88.1       135\n10             10 Caterpie       30      35    45            50          20\n# ℹ 791 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;fct&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;"
  },
  {
    "objectID": "4_data_wrangling.html#operaciones-agrupadas",
    "href": "4_data_wrangling.html#operaciones-agrupadas",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "4.1 Operaciones agrupadas",
    "text": "4.1 Operaciones agrupadas\nConsiderando la base de datos, seria mas informativo obtener el promedio por especie o por isla. La función group_by() permite agrupar los datos de acuerdo a alguna variable (factor).\nPor ejemplo, para obtener el peso promedio por especie:\n\npenguins %&gt;% \n  group_by(species) %&gt;% \n  summarise(promedio_peso = mean(body_mass_g, na.rm = TRUE))\n\n# A tibble: 3 × 2\n  species   promedio_peso\n  &lt;chr&gt;             &lt;dbl&gt;\n1 Adelie            3701.\n2 Chinstrap         3733.\n3 Gentoo            5076.\n\n\nPodemos agrupar utilizando mas variables separadas por una coma:\n\npenguins %&gt;% \n  group_by(island, species, sex) %&gt;% \n  summarise(promedio_peso = mean(body_mass_g, na.rm = TRUE),\n            desviacion = sd(body_mass_g, na.rm = TRUE),\n            N = n())\n\n`summarise()` has grouped output by 'island', 'species'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 13 × 6\n# Groups:   island, species [5]\n   island    species   sex    promedio_peso desviacion     N\n   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt;\n 1 Biscoe    Adelie    female         3369.       343.    22\n 2 Biscoe    Adelie    male           4050        356.    22\n 3 Biscoe    Gentoo    female         4680.       282.    58\n 4 Biscoe    Gentoo    male           5485.       313.    61\n 5 Biscoe    Gentoo    &lt;NA&gt;           4588.       338.     5\n 6 Dream     Adelie    female         3344.       212.    27\n 7 Dream     Adelie    male           4046.       331.    28\n 8 Dream     Adelie    &lt;NA&gt;           2975         NA      1\n 9 Dream     Chinstrap female         3527.       285.    34\n10 Dream     Chinstrap male           3939.       362.    34\n11 Torgersen Adelie    female         3396.       259.    24\n12 Torgersen Adelie    male           4035.       372.    23\n13 Torgersen Adelie    &lt;NA&gt;           3681.       413.     5\n\n\nExisten otras funciones útiles por las que nos podría interesar agrupar\n\ncount()\nmean()\nmedian()\nmin()\nmax()\nquantile(x, 0.25)\nIQR()\n\nEl uso de la función group_by() tambien nos permite transformar una variable e incluirla en una columna en conjunto con la función mutate()\n\npenguins %&gt;% \n  group_by(species, island,sex) %&gt;% \n  mutate(promedio_peso_grupo = mean(body_mass_g, na.rm = TRUE)) %&gt;% \n  select(promedio_peso_grupo, everything())\n\n# A tibble: 344 × 9\n# Groups:   species, island, sex [13]\n   promedio_peso_grupo species island    bill_length_mm bill_depth_mm\n                 &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;\n 1               4035. Adelie  Torgersen           39.1          18.7\n 2               3396. Adelie  Torgersen           39.5          17.4\n 3               3396. Adelie  Torgersen           40.3          18  \n 4               3681. Adelie  Torgersen           NA            NA  \n 5               3396. Adelie  Torgersen           36.7          19.3\n 6               4035. Adelie  Torgersen           39.3          20.6\n 7               3396. Adelie  Torgersen           38.9          17.8\n 8               4035. Adelie  Torgersen           39.2          19.6\n 9               3681. Adelie  Torgersen           34.1          18.1\n10               3681. Adelie  Torgersen           42            20.2\n# ℹ 334 more rows\n# ℹ 4 more variables: flipper_length_mm &lt;dbl&gt;, body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;,\n#   year &lt;dbl&gt;"
  },
  {
    "objectID": "4_data_wrangling.html#resumir-todas-las-variables-con-summarise_all",
    "href": "4_data_wrangling.html#resumir-todas-las-variables-con-summarise_all",
    "title": "Lección 2. Manipulación de datos con dplyr",
    "section": "4.2 Resumir todas las variables con summarise_all()",
    "text": "4.2 Resumir todas las variables con summarise_all()\nLa función summarise_all() requiere una función como argumento, la cual aplica a todas las columnas de la tabla. En este ejemplo se agrego el argumento na.rm = TRUE el cual ignora los NAs\n\npenguins %&gt;% \n  group_by(species, island, sex) %&gt;% \n  summarise_all(mean, na.rm = TRUE) \n\n# A tibble: 13 × 8\n# Groups:   species, island [5]\n   species   island    sex    bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1 Adelie    Biscoe    female           37.4          17.7              187.\n 2 Adelie    Biscoe    male             40.6          19.0              190.\n 3 Adelie    Dream     female           36.9          17.6              188.\n 4 Adelie    Dream     male             40.1          18.8              192.\n 5 Adelie    Dream     &lt;NA&gt;             37.5          18.9              179 \n 6 Adelie    Torgersen female           37.6          17.6              188.\n 7 Adelie    Torgersen male             40.6          19.4              195.\n 8 Adelie    Torgersen &lt;NA&gt;             37.9          18.2              187.\n 9 Chinstrap Dream     female           46.6          17.6              192.\n10 Chinstrap Dream     male             51.1          19.3              200.\n11 Gentoo    Biscoe    female           45.6          14.2              213.\n12 Gentoo    Biscoe    male             49.5          15.7              222.\n13 Gentoo    Biscoe    &lt;NA&gt;             45.6          14.6              216.\n# ℹ 2 more variables: body_mass_g &lt;dbl&gt;, year &lt;dbl&gt;"
  },
  {
    "objectID": "3.Data_import.html",
    "href": "3.Data_import.html",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "La importación de archivos de texto es el primer paso y parte fundamental para la exploración de datos. Sin embargo, también puede llegar a ser una tarea complicada.\nLos tipos de archivos mas comunes con los que solemos trabajar son:\n\nComa-separated values (csv)\nTab-separated values (tsv)\nExcel (xls)\nArchivo de texto simple (txt)\n\n\n\nPara importar un archivo a nuestro ambiente podemos utilizar las funciones base read.table, read.csv, read.delim. Por ejemplo, para abrir un archivo txt separado por tabuladores utilizando la función:\n\ndf &lt;- read.table(\"data/palmer_penguins.txt\", header = TRUE, sep = \"\\t\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007\n\n\no usando read.csv\n\ndf &lt;- read.csv(\"data/palmer_penguins.csv\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007\n\n\n\n\n\nDentro del Tidyverse, la importación de datos rectangulares se realiza con el paquete readr el cual tiene funciones que van a sonar muy familiares:\n\nread_csv(): comma-separated values (CSV)\nread_tsv(): tab-separated values (TSV)\nread_csv2(): semicolon-separated values with , as the decimal mark\nread_delim(): delimited files (CSV and TSV are important special cases)\nread_table(): whitespace-separated files\n\n\n\n\n\n\n\n¿Has notado algo? 🧐\n\n\n\nComo ves, los nombres de las funciones son muy parecidas a las funciones base pero reemplazando el “.” por un “_”. Esta tendencia se repite en numerosas funciones que siguen la filosofía tidy. Por ejemplo, en lugar de la prueba shapiro.test, rstatix utiliza la función shapiro_test.\n\n\nHagamos la prueba…\n\nlibrary(tidyverse)\nlibrary(here)\n\n\ndf &lt;- read_table(\"data/palmer_penguins.txt\")\n\n\n── Column specification ────────────────────────────────────────────────────────\ncols(\n  species = col_character(),\n  island = col_character(),\n  bill_length_mm = col_double(),\n  bill_depth_mm = col_double(),\n  flipper_length_mm = col_double(),\n  body_mass_g = col_double(),\n  sex = col_character(),\n  year = col_double()\n)\n\n\nObserva como, aún antes de desplegar la tabla,read_table ya nos arroja información sobre la estructura de los datos y nos indica si cada columna es número, carácter o de otro tipo.\nAhora observa como se despliega la tabla\n\ndf\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\n\n\n\n¿double? ¿character? 😱\n\n\n\nEn caso de que no lo recuerdes, estos son los principales tipos de datos en R\n\n\n\nTipo\nDescripción\nEjemplo\n\n\nNumeric\ninterger números enteros\n0L, 1L\n\n\nNumeric\ndouble números reales\n1.0,\n\n\nLogic\nvalores booleanos\nTRUE, FALSE\n\n\nCharacter\ncadena de texto\n“Hola mundo”\n\n\nFactor\nrepresentan datos categóricos\nmacho, hembra\n\n\nDates\nFechas\n“2023-08-24”\n\n\n\n\n\n\n\n\nCon R base, la función read.table nos genera un data frame pero readr nos genera un tibble los cuales son una versión actualizada de un data frame.\nHay varias diferencias entre tibbles y data.frames. Puedes leer mas en la viñeta. Sin embargo, algunas de las diferencias mas notables son:\n\nEl tipo de entrada permanece inalterado: los data.frames son conocidos por tratar las cadenas de texto como factores; esto no sucederá con los tibbles.\nLos nombres de las variables permanecen inalterados: En R base, al crear data.frames se eliminan los espacios de los nombres, convirtiéndolos en puntos o agregando una “x” antes de los nombres de las columnas numéricas. Al crear tibbles, los nombres de las variables (columnas) no cambian.\nNo hay row.names() para un tibble: Los datos ordenados requieren que las variables se almacenen de manera consistente, eliminando la necesidad de nombres de filas. Los tibbles imprimen las primeras diez filas y columnas que caben en una pantalla: Imprimir un tibble en la pantalla nunca mostrará todo el enorme marco de datos. Por defecto, solo muestra lo que cabe en tu pantalla.\n\n\n\nSi tenemos datos rectangulares como data.frame podemos convertirlo facilmente a tibble con la función as_tibble()\nPor ejemplo, podemos:\n\nas_tibble(trees)\n\n# A tibble: 31 × 3\n   Girth Height Volume\n   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1   8.3     70   10.3\n 2   8.6     65   10.3\n 3   8.8     63   10.2\n 4  10.5     72   16.4\n 5  10.7     81   18.8\n 6  10.8     83   19.7\n 7  11       66   15.6\n 8  11       75   18.2\n 9  11.1     80   22.6\n10  11.2     75   19.9\n# ℹ 21 more rows\n\n\n\n\n\n\n\n\nWarning\n\n\n\nRecuerda que si solo ejecutamos el comando as_tibble(trees) R solo nos arrojará el resutlado en la consola pero no hizo ningún cambio al objeto trees. Para esto necesitamos renombrar o generar un nuevo objeto. Por ejemplo\n\ntrees_tbl &lt;- as_tibble(trees)\n\nahora si, tenemos un nuevo objetvo como tibble\n\nclass(trees)\n\n[1] \"data.frame\"\n\nclass(trees_tbl)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\nAl igual que como lo hariamos con un data.frame o una matriz, podemos acceder a las primeras o últimas filas de nuestro tibble con las funciones head() y tail()\n\nhead(df)\n\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\ntail(df)\n\n# A tibble: 6 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Chinstrap Dream            45.7          17                 195        3650\n2 Chinstrap Dream            55.8          19.8               207        4000\n3 Chinstrap Dream            43.5          18.1               202        3400\n4 Chinstrap Dream            49.6          18.2               193        3775\n5 Chinstrap Dream            50.8          19                 210        4100\n6 Chinstrap Dream            50.2          18.7               198        3775\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\nTambién es posible hacer tibble sobre la marcha utilizando la función tibble(). Por ejemplo:\n\nmi_tibl &lt;- tibble(\n  a = 1:5,\n  b = 6:10,\n  c = 1,\n  z = (a + b)^2 + c\n)\n\nmi_tibl\n\n# A tibble: 5 × 4\n      a     b     c     z\n  &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     6     1    50\n2     2     7     1    82\n3     3     8     1   122\n4     4     9     1   170\n5     5    10     1   226\n\n\nNota que al momento de generar este tibble, puedes hacer referencias a columnas del mismo tibble (columa z)\nOtro comportamiento de los tibbles es que es posible tener nombres de columnas con espacios u otros caracteres y estos estarán rodeados por ``\n\nmi_tibl &lt;- tibble(\n  `cinco números` = 1:5,\n  `12` = \"numeric\",\n  `:)` = \"smile\",\n)\n\nmi_tibl\n\n# A tibble: 5 × 3\n  `cinco números` `12`    `:)` \n            &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;\n1               1 numeric smile\n2               2 numeric smile\n3               3 numeric smile\n4               4 numeric smile\n5               5 numeric smile\n\n\n\n\n\n\nLas hojas de calculo de excel (formatos .xls o .xlsx) siguen siendo muy comunes y muy utilizados dentro de la comunidad académica.\nTidyverse no tiene dentro de su núcleo una función para importar este tipo de archivos, pero esto se soluciona fácilmente con el paquete readxl.\n\n\n\n\n\n\ninstall.packages(\"readxl\")\n\n\nlibrary(readxl)\n\nWarning: package 'readxl' was built under R version 4.3.1\n\n\nCon esto podemos usar la función read_excel() que no necesita ningún otro argumento mas que la ruta (path) donde se encuentra el archivo .xlsx\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\")\n\nexcel_df\n\n# A tibble: 405 × 9\n   `Sample ID` ExpNum TreatTemp Meas_Temp `WetWeight(g)` `buffer(ml)`\n   &lt;chr&gt;        &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;\n 1 Hf100U           3        24        18          0.093         0.93\n 2 Hf100U           3        24        18          0.093         0.93\n 3 Hf100U           3        24        32          0.093         0.93\n 4 Hf100U           3        24        32          0.093         0.93\n 5 Hf101U           3        30        18          0.114         1.14\n 6 Hf101U           3        30        18          0.114         1.14\n 7 Hf101U           3        30        32          0.114         1.14\n 8 Hf101U           3        30        32          0.114         1.14\n 9 Hf102U           3        30        18          0.092         0.92\n10 Hf102U           3        30        18          0.092         0.92\n# ℹ 395 more rows\n# ℹ 3 more variables: `MessVol(ul)` &lt;dbl&gt;, slopeTDH &lt;dbl&gt;, ActivityTDH &lt;dbl&gt;\n\n\nEn caso de que los datos de interes estén en una hoja en particular usamos el argumento sheet=\n\nexcel_df&lt;- read_excel(\"data/actividad_enzimas.xlsx\", sheet = \"hoja1\")\n\nUn caso mas complicado es cuando nuestro datos inician unas filas mas abajo y en un determinado intervalo de columnas. Otro caso común es que los nombres de las columnas tengan símbolos especiales o que estén repetidos\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", skip = 3, na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\nEn caso de que tengamos otra información que nos este generando conflicto podemos especificar el rango de datos de interés\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nHeterogeneidad en los nombres de las columna\n\n\n\nObserva como los tibbles permite que haya símbolos, espacios, acentos y alternancia de mayúsculas y minúsculas en los nombres de las columnas. Sin embargo, al momento de trabajar, esta heterogeneidad puede darnos problemas. Esto se puede solucionar con el paquete janitor.\n\n\n\n\n\n\n\n\n\n\nEl paquete Janitor es una herramienta pequeña pero increíblemente útil y conveniente cuando se trata de limpiar y mantener conjuntos de datos en RStudio. Además, es un paquete orientado a “tidyverse”, por lo que se integra perfectamente con los pipes.\nRegresemos a los nombres de las columnas de nuestro archivo excel antes de utilizar janitor\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\n\n\n [1] \"Número de muestra\"        \"Número de experimento\"   \n [3] \"Tratamiento\"              \"Temperatura\"             \n [5] \"peso húmedo (g)\"          \"buffer (ml)\"             \n [7] \"volumen de reaccion (ul)\" \"concentración g/ml\"      \n [9] \"pendiente...9\"            \"pendiente...10\"          \n\n\n\nNo hay consistencia entre el uso de mayúsculas y minúsculas en los nombres. Recuerda que R es sensible a mayúsculas, por lo que Temperatura no es lo mismo que temperatura.\nTenemos símbolos como acentos que nos pueden generar conflictos, sobre todo si tenemos símbolos en otros idiomas.\nLos espacios en blanco así como otros símbolos como / son reemplazados por un punto. Esto genera etiquetas complicadas.\n\nLo ideal es tener consistencia en el formato de las etiquetas. Algunos formatos conocidos son los siguientes:\n\n\n\n\n\nAhora utilicemos janitor para limpiar las etiquetas\n\nlibrary(janitor)\n\nWarning: package 'janitor' was built under R version 4.3.1\n\n\n\nAttaching package: 'janitor'\n\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\n\n\nexcel_clean &lt;- clean_names(excel_df)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente_9 &lt;dbl&gt;, pendiente_10 &lt;dbl&gt;\n\n\nlas opciones son:\n\n“snake”\n“small_camel”\n“big_camel”\n“screaming_snake”\n“parsed”\n“lower_upper”\n“upper_lower”\n\npor ejemplo:\n\nexcel_clean &lt;- clean_names(excel_df, case = \"screaming_snake\")\nexcel_clean\n\n# A tibble: 405 × 10\n   NUMERO_DE_MUESTRA NUMERO_DE_EXPERIMENTO TRATAMIENTO TEMPERATURA PESO_HUMEDO_G\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: BUFFER_ML &lt;dbl&gt;, VOLUMEN_DE_REACCION_UL &lt;dbl&gt;,\n#   CONCENTRACION_G_ML &lt;dbl&gt;, PENDIENTE_9 &lt;dbl&gt;, PENDIENTE_10 &lt;dbl&gt;\n\n\nCon janitor podemos integrar la función make_clean_name al momento de importar datos ya sea con readxl o con readr. Por ejemplo:\n\nexcel_clean &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\",\n                       .name_repair =  make_clean_names)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWarning\n\n\n\nObserva que tanto readxl como readr interpretan las columnas de número de experimento, tratamiento y temperatura como variables numéricas debido a que analizan la cantidad de datos para inferir el tipo de variable. No obstante, estas variables son en realidad factores, ya que representan categorías. Más adelante veremos cómo realizar este ajuste de manera manual.\n\n\n\n\n\nUn aspecto importante para el análisis de datos es tener una perspectiva rápida del tibble o datafram para entender las variables que tenemos, asi como los patrones generales de los datos.\nHay varias funciones que podemos utilizar. Ya mencionamos algunas herramienta como head() o tail() para echar un vistazo a las primeras o últimas filas de la tabla, respectivamente.\nOtra herramienta es la función glimpse() de dplyr que nos muestra algunos datos de cada columna de nuestro tibble para tener una idea de la estructura de la tabla.\n\nglimpse(excel_clean)\n\nRows: 405\nColumns: 10\n$ numero_de_muestra      &lt;chr&gt; \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf101U…\n$ numero_de_experimento  &lt;dbl&gt; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,…\n$ tratamiento            &lt;dbl&gt; 24, 24, 24, 24, 30, 30, 30, 30, 30, 30, 30, 30,…\n$ temperatura            &lt;dbl&gt; 18, 18, 32, 32, 18, 18, 32, 32, 18, 18, 32, 32,…\n$ peso_humedo_g          &lt;dbl&gt; 0.093, 0.093, 0.093, 0.093, 0.114, 0.114, 0.114…\n$ buffer_ml              &lt;dbl&gt; 0.93, 0.93, 0.93, 0.93, 1.14, 1.14, 1.14, 1.14,…\n$ volumen_de_reaccion_ul &lt;dbl&gt; 20, 10, 20, 10, 20, 10, 20, 10, 20, 10, 20, 10,…\n$ concentracion_g_ml     &lt;dbl&gt; 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.…\n$ pendiente              &lt;dbl&gt; 0.0331, 0.0145, 0.1431, 0.0653, 0.0354, 0.0155,…\n$ pendiente_2            &lt;dbl&gt; 2.660772, 2.331190, 11.503215, 10.498392, 2.845…\n\n\nLa función summary() es parte de las funciones base de R y es particularmente útil cuando tenemos datos continuos, ya que nos muestra, para cada columna, los valores mínimos, máximos, promedio, mediana y el 1er y 3er quartil.\n\nsummary(excel_clean)\n\n numero_de_muestra  numero_de_experimento  tratamiento     temperatura   \n Length:405         Min.   :1.000         Min.   :18.00   Min.   :18.00  \n Class :character   1st Qu.:2.000         1st Qu.:24.00   1st Qu.:18.00  \n Mode  :character   Median :3.000         Median :24.00   Median :18.00  \n                    Mean   :2.528         Mean   :26.04   Mean   :24.74  \n                    3rd Qu.:4.000         3rd Qu.:30.00   3rd Qu.:32.00  \n                    Max.   :4.000         Max.   :32.00   Max.   :32.00  \n                                                                         \n peso_humedo_g       buffer_ml      volumen_de_reaccion_ul concentracion_g_ml\n Min.   :0.02900   Min.   :0.2900   Min.   :10.00          Min.   :0.1       \n 1st Qu.:0.06700   1st Qu.:0.6700   1st Qu.:10.00          1st Qu.:0.1       \n Median :0.08500   Median :0.8500   Median :20.00          Median :0.1       \n Mean   :0.08387   Mean   :0.8387   Mean   :15.04          Mean   :0.1       \n 3rd Qu.:0.09900   3rd Qu.:0.9900   3rd Qu.:20.00          3rd Qu.:0.1       \n Max.   :0.18900   Max.   :1.8900   Max.   :20.00          Max.   :0.1       \n                                                                             \n   pendiente        pendiente_2    \n Min.   :0.00000   Min.   : 0.000  \n 1st Qu.:0.01480   1st Qu.: 1.632  \n Median :0.03500   Median : 4.594  \n Mean   :0.04949   Mean   : 5.205  \n 3rd Qu.:0.07290   3rd Qu.: 8.163  \n Max.   :0.31390   Max.   :25.233  \n                   NA's   :13      \n\n\nOtra herramienta un poco mas sofisticada pero bastante útil es la función gt_plt_summary() del paquete gtExtras, la cual nos permite gráficar cada una de las variables, nos muestra los valores promedio, mediana y desvicación, y ádemas nos muestra el % de valores faltantes (missing).\nPara utilizar esta herramienta, primero necesitamos instalar el paquete gtExtras y posteriormente cargar la librería.\n\ninstall.packages(\"gtExtras\")\n\n\nlibrary(gtExtras)\n\nWarning: package 'gtExtras' was built under R version 4.3.1\n\ngt_plt_summary(excel_clean)\n\nWarning: Computation failed in `stat_bin()`\nCaused by error in `bin_breaks_width()`:\n! The number of histogram bins must be less than 1,000,000.\nℹ Did you make `binwidth` too small?\n\n\n\n\n\n\n  \n    \n      excel_clean\n    \n    \n      405 rows x 10 cols\n    \n    \n      \n      Column\n      Plot Overview\n      Missing\n      Mean\n      Median\n      SD\n    \n  \n  \n    \nnumero_de_muestra\n                  96 categories\n0.0%\n—\n—\n—\n    \nnumero_de_experimento\n                  14\n0.0%\n2.5\n3.0\n1.1\n    \ntratamiento\n                  1832\n0.0%\n26.0\n24.0\n5.4\n    \ntemperatura\n                  1832\n0.0%\n24.7\n18.0\n7.0\n    \npeso_humedo_g\n                  0.030.19\n0.0%\n0.1\n0.1\n0.0\n    \nbuffer_ml\n                  0.31.9\n0.0%\n0.8\n0.8\n0.3\n    \nvolumen_de_reaccion_ul\n                  1020\n0.0%\n15.0\n20.0\n5.0\n    \nconcentracion_g_ml\n                  00\n0.0%\n0.1\n0.1\n0.0\n    \npendiente\n                  0.000.31\n0.0%\n0.0\n0.0\n0.0\n    \npendiente_2\n                  025\n3.2%\n5.2\n4.6\n4.2\n  \n  \n  \n\n\n\n\n\n\n\nUna vez terminado nuestro análisis debemos guardarlo. Siguiendo la recomendación que vimos anteriormente, lo ideal es guardar los datos ya procesados (ya sea que se haya realizado algún tipo de filtrado o transformación) en una carpeta diferente a la carpeta donde están los datos crudos, los cuales se recomienda que se preserven sin alteraciones.\nPodemos crear una nueva carpeta con Archivos &gt; Nuevo directorio o desde la línea de comando usando la función dir.create()\n\ndir.create(\"resultados/tablas\", recursive = TRUE)\n\nWarning in dir.create(\"resultados/tablas\", recursive = TRUE):\n'resultados\\tablas' already exists\n\n\nPara guardar nuestros datos, las funciones que utilizaremos mas frecuentemente son write.table y write_csv()\nPor ejemplo, vamos a tomar las primeras filas de nuestro objeto excel_clean con la función head()\n\nexcel_subset &lt;- head(excel_clean)\nexcel_subset\n\n# A tibble: 6 × 10\n  numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n  &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n1 Hf100U                                3          24          18         0.093\n2 Hf100U                                3          24          18         0.093\n3 Hf100U                                3          24          32         0.093\n4 Hf100U                                3          24          32         0.093\n5 Hf101U                                3          30          18         0.114\n6 Hf101U                                3          30          18         0.114\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\nAhora lo guardamos en la carpeta que acabamos de crear usando la función write_csv()\n\nwrite_csv(excel_subset, file = \"resultados/tablas/excel_subset.csv\")\n\no con write.table() la cual nos permite usar una mayor diversidad de formatos\n\nwrite.table(excel_subset, file = \"resultados/tablas/excel_subset.txt\", sep = \"\\t\")"
  },
  {
    "objectID": "3.Data_import.html#funciones-base-para-importar-archivos",
    "href": "3.Data_import.html#funciones-base-para-importar-archivos",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "Para importar un archivo a nuestro ambiente podemos utilizar las funciones base read.table, read.csv, read.delim. Por ejemplo, para abrir un archivo txt separado por tabuladores utilizando la función:\n\ndf &lt;- read.table(\"data/palmer_penguins.txt\", header = TRUE, sep = \"\\t\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007\n\n\no usando read.csv\n\ndf &lt;- read.csv(\"data/palmer_penguins.csv\")\nhead(df)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007"
  },
  {
    "objectID": "3.Data_import.html#importar-datos-a-lá-tidyverse",
    "href": "3.Data_import.html#importar-datos-a-lá-tidyverse",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "Dentro del Tidyverse, la importación de datos rectangulares se realiza con el paquete readr el cual tiene funciones que van a sonar muy familiares:\n\nread_csv(): comma-separated values (CSV)\nread_tsv(): tab-separated values (TSV)\nread_csv2(): semicolon-separated values with , as the decimal mark\nread_delim(): delimited files (CSV and TSV are important special cases)\nread_table(): whitespace-separated files\n\n\n\n\n\n\n\n¿Has notado algo? 🧐\n\n\n\nComo ves, los nombres de las funciones son muy parecidas a las funciones base pero reemplazando el “.” por un “_”. Esta tendencia se repite en numerosas funciones que siguen la filosofía tidy. Por ejemplo, en lugar de la prueba shapiro.test, rstatix utiliza la función shapiro_test.\n\n\nHagamos la prueba…\n\nlibrary(tidyverse)\nlibrary(here)\n\n\ndf &lt;- read_table(\"data/palmer_penguins.txt\")\n\n\n── Column specification ────────────────────────────────────────────────────────\ncols(\n  species = col_character(),\n  island = col_character(),\n  bill_length_mm = col_double(),\n  bill_depth_mm = col_double(),\n  flipper_length_mm = col_double(),\n  body_mass_g = col_double(),\n  sex = col_character(),\n  year = col_double()\n)\n\n\nObserva como, aún antes de desplegar la tabla,read_table ya nos arroja información sobre la estructura de los datos y nos indica si cada columna es número, carácter o de otro tipo.\nAhora observa como se despliega la tabla\n\ndf\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\n\n\n\n¿double? ¿character? 😱\n\n\n\nEn caso de que no lo recuerdes, estos son los principales tipos de datos en R\n\n\n\nTipo\nDescripción\nEjemplo\n\n\nNumeric\ninterger números enteros\n0L, 1L\n\n\nNumeric\ndouble números reales\n1.0,\n\n\nLogic\nvalores booleanos\nTRUE, FALSE\n\n\nCharacter\ncadena de texto\n“Hola mundo”\n\n\nFactor\nrepresentan datos categóricos\nmacho, hembra\n\n\nDates\nFechas\n“2023-08-24”"
  },
  {
    "objectID": "3.Data_import.html#tibbles",
    "href": "3.Data_import.html#tibbles",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "Con R base, la función read.table nos genera un data frame pero readr nos genera un tibble los cuales son una versión actualizada de un data frame.\nHay varias diferencias entre tibbles y data.frames. Puedes leer mas en la viñeta. Sin embargo, algunas de las diferencias mas notables son:\n\nEl tipo de entrada permanece inalterado: los data.frames son conocidos por tratar las cadenas de texto como factores; esto no sucederá con los tibbles.\nLos nombres de las variables permanecen inalterados: En R base, al crear data.frames se eliminan los espacios de los nombres, convirtiéndolos en puntos o agregando una “x” antes de los nombres de las columnas numéricas. Al crear tibbles, los nombres de las variables (columnas) no cambian.\nNo hay row.names() para un tibble: Los datos ordenados requieren que las variables se almacenen de manera consistente, eliminando la necesidad de nombres de filas. Los tibbles imprimen las primeras diez filas y columnas que caben en una pantalla: Imprimir un tibble en la pantalla nunca mostrará todo el enorme marco de datos. Por defecto, solo muestra lo que cabe en tu pantalla.\n\n\n\nSi tenemos datos rectangulares como data.frame podemos convertirlo facilmente a tibble con la función as_tibble()\nPor ejemplo, podemos:\n\nas_tibble(trees)\n\n# A tibble: 31 × 3\n   Girth Height Volume\n   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1   8.3     70   10.3\n 2   8.6     65   10.3\n 3   8.8     63   10.2\n 4  10.5     72   16.4\n 5  10.7     81   18.8\n 6  10.8     83   19.7\n 7  11       66   15.6\n 8  11       75   18.2\n 9  11.1     80   22.6\n10  11.2     75   19.9\n# ℹ 21 more rows\n\n\n\n\n\n\n\n\nWarning\n\n\n\nRecuerda que si solo ejecutamos el comando as_tibble(trees) R solo nos arrojará el resutlado en la consola pero no hizo ningún cambio al objeto trees. Para esto necesitamos renombrar o generar un nuevo objeto. Por ejemplo\n\ntrees_tbl &lt;- as_tibble(trees)\n\nahora si, tenemos un nuevo objetvo como tibble\n\nclass(trees)\n\n[1] \"data.frame\"\n\nclass(trees_tbl)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\nAl igual que como lo hariamos con un data.frame o una matriz, podemos acceder a las primeras o últimas filas de nuestro tibble con las funciones head() y tail()\n\nhead(df)\n\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\ntail(df)\n\n# A tibble: 6 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Chinstrap Dream            45.7          17                 195        3650\n2 Chinstrap Dream            55.8          19.8               207        4000\n3 Chinstrap Dream            43.5          18.1               202        3400\n4 Chinstrap Dream            49.6          18.2               193        3775\n5 Chinstrap Dream            50.8          19                 210        4100\n6 Chinstrap Dream            50.2          18.7               198        3775\n# ℹ 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\n\nTambién es posible hacer tibble sobre la marcha utilizando la función tibble(). Por ejemplo:\n\nmi_tibl &lt;- tibble(\n  a = 1:5,\n  b = 6:10,\n  c = 1,\n  z = (a + b)^2 + c\n)\n\nmi_tibl\n\n# A tibble: 5 × 4\n      a     b     c     z\n  &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     6     1    50\n2     2     7     1    82\n3     3     8     1   122\n4     4     9     1   170\n5     5    10     1   226\n\n\nNota que al momento de generar este tibble, puedes hacer referencias a columnas del mismo tibble (columa z)\nOtro comportamiento de los tibbles es que es posible tener nombres de columnas con espacios u otros caracteres y estos estarán rodeados por ``\n\nmi_tibl &lt;- tibble(\n  `cinco números` = 1:5,\n  `12` = \"numeric\",\n  `:)` = \"smile\",\n)\n\nmi_tibl\n\n# A tibble: 5 × 3\n  `cinco números` `12`    `:)` \n            &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;\n1               1 numeric smile\n2               2 numeric smile\n3               3 numeric smile\n4               4 numeric smile\n5               5 numeric smile"
  },
  {
    "objectID": "3.Data_import.html#importar-desde-excel",
    "href": "3.Data_import.html#importar-desde-excel",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "Las hojas de calculo de excel (formatos .xls o .xlsx) siguen siendo muy comunes y muy utilizados dentro de la comunidad académica.\nTidyverse no tiene dentro de su núcleo una función para importar este tipo de archivos, pero esto se soluciona fácilmente con el paquete readxl.\n\n\n\n\n\n\ninstall.packages(\"readxl\")\n\n\nlibrary(readxl)\n\nWarning: package 'readxl' was built under R version 4.3.1\n\n\nCon esto podemos usar la función read_excel() que no necesita ningún otro argumento mas que la ruta (path) donde se encuentra el archivo .xlsx\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\")\n\nexcel_df\n\n# A tibble: 405 × 9\n   `Sample ID` ExpNum TreatTemp Meas_Temp `WetWeight(g)` `buffer(ml)`\n   &lt;chr&gt;        &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;\n 1 Hf100U           3        24        18          0.093         0.93\n 2 Hf100U           3        24        18          0.093         0.93\n 3 Hf100U           3        24        32          0.093         0.93\n 4 Hf100U           3        24        32          0.093         0.93\n 5 Hf101U           3        30        18          0.114         1.14\n 6 Hf101U           3        30        18          0.114         1.14\n 7 Hf101U           3        30        32          0.114         1.14\n 8 Hf101U           3        30        32          0.114         1.14\n 9 Hf102U           3        30        18          0.092         0.92\n10 Hf102U           3        30        18          0.092         0.92\n# ℹ 395 more rows\n# ℹ 3 more variables: `MessVol(ul)` &lt;dbl&gt;, slopeTDH &lt;dbl&gt;, ActivityTDH &lt;dbl&gt;\n\n\nEn caso de que los datos de interes estén en una hoja en particular usamos el argumento sheet=\n\nexcel_df&lt;- read_excel(\"data/actividad_enzimas.xlsx\", sheet = \"hoja1\")\n\nUn caso mas complicado es cuando nuestro datos inician unas filas mas abajo y en un determinado intervalo de columnas. Otro caso común es que los nombres de las columnas tengan símbolos especiales o que estén repetidos\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", skip = 3, na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\nEn caso de que tengamos otra información que nos este generando conflicto podemos especificar el rango de datos de interés\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\nNew names:\n• `pendiente` -&gt; `pendiente...9`\n• `pendiente` -&gt; `pendiente...10`\n\nexcel_df\n\n# A tibble: 405 × 10\n   `Número de muestra` `Número de experimento` Tratamiento Temperatura\n   &lt;chr&gt;                                 &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 Hf100U                                    3          24          18\n 2 Hf100U                                    3          24          18\n 3 Hf100U                                    3          24          32\n 4 Hf100U                                    3          24          32\n 5 Hf101U                                    3          30          18\n 6 Hf101U                                    3          30          18\n 7 Hf101U                                    3          30          32\n 8 Hf101U                                    3          30          32\n 9 Hf102U                                    3          30          18\n10 Hf102U                                    3          30          18\n# ℹ 395 more rows\n# ℹ 6 more variables: `peso húmedo (g)` &lt;dbl&gt;, `buffer (ml)` &lt;dbl&gt;,\n#   `volumen de reaccion (ul)` &lt;dbl&gt;, `concentración g/ml` &lt;dbl&gt;,\n#   pendiente...9 &lt;dbl&gt;, pendiente...10 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nHeterogeneidad en los nombres de las columna\n\n\n\nObserva como los tibbles permite que haya símbolos, espacios, acentos y alternancia de mayúsculas y minúsculas en los nombres de las columnas. Sin embargo, al momento de trabajar, esta heterogeneidad puede darnos problemas. Esto se puede solucionar con el paquete janitor."
  },
  {
    "objectID": "3.Data_import.html#limpiar-etiquetas-con-janitor",
    "href": "3.Data_import.html#limpiar-etiquetas-con-janitor",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "El paquete Janitor es una herramienta pequeña pero increíblemente útil y conveniente cuando se trata de limpiar y mantener conjuntos de datos en RStudio. Además, es un paquete orientado a “tidyverse”, por lo que se integra perfectamente con los pipes.\nRegresemos a los nombres de las columnas de nuestro archivo excel antes de utilizar janitor\n\nexcel_df &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\")\n\n\n\n [1] \"Número de muestra\"        \"Número de experimento\"   \n [3] \"Tratamiento\"              \"Temperatura\"             \n [5] \"peso húmedo (g)\"          \"buffer (ml)\"             \n [7] \"volumen de reaccion (ul)\" \"concentración g/ml\"      \n [9] \"pendiente...9\"            \"pendiente...10\"          \n\n\n\nNo hay consistencia entre el uso de mayúsculas y minúsculas en los nombres. Recuerda que R es sensible a mayúsculas, por lo que Temperatura no es lo mismo que temperatura.\nTenemos símbolos como acentos que nos pueden generar conflictos, sobre todo si tenemos símbolos en otros idiomas.\nLos espacios en blanco así como otros símbolos como / son reemplazados por un punto. Esto genera etiquetas complicadas.\n\nLo ideal es tener consistencia en el formato de las etiquetas. Algunos formatos conocidos son los siguientes:\n\n\n\n\n\nAhora utilicemos janitor para limpiar las etiquetas\n\nlibrary(janitor)\n\nWarning: package 'janitor' was built under R version 4.3.1\n\n\n\nAttaching package: 'janitor'\n\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\n\n\nexcel_clean &lt;- clean_names(excel_df)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente_9 &lt;dbl&gt;, pendiente_10 &lt;dbl&gt;\n\n\nlas opciones son:\n\n“snake”\n“small_camel”\n“big_camel”\n“screaming_snake”\n“parsed”\n“lower_upper”\n“upper_lower”\n\npor ejemplo:\n\nexcel_clean &lt;- clean_names(excel_df, case = \"screaming_snake\")\nexcel_clean\n\n# A tibble: 405 × 10\n   NUMERO_DE_MUESTRA NUMERO_DE_EXPERIMENTO TRATAMIENTO TEMPERATURA PESO_HUMEDO_G\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: BUFFER_ML &lt;dbl&gt;, VOLUMEN_DE_REACCION_UL &lt;dbl&gt;,\n#   CONCENTRACION_G_ML &lt;dbl&gt;, PENDIENTE_9 &lt;dbl&gt;, PENDIENTE_10 &lt;dbl&gt;\n\n\nCon janitor podemos integrar la función make_clean_name al momento de importar datos ya sea con readxl o con readr. Por ejemplo:\n\nexcel_clean &lt;- read_excel(\"data/actividad_enzimas.xlsx\", \n                       sheet = \"hoja3\", range = \"D4:M409\", na = \"-\",\n                       .name_repair =  make_clean_names)\nexcel_clean\n\n# A tibble: 405 × 10\n   numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n   &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n 1 Hf100U                                3          24          18         0.093\n 2 Hf100U                                3          24          18         0.093\n 3 Hf100U                                3          24          32         0.093\n 4 Hf100U                                3          24          32         0.093\n 5 Hf101U                                3          30          18         0.114\n 6 Hf101U                                3          30          18         0.114\n 7 Hf101U                                3          30          32         0.114\n 8 Hf101U                                3          30          32         0.114\n 9 Hf102U                                3          30          18         0.092\n10 Hf102U                                3          30          18         0.092\n# ℹ 395 more rows\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWarning\n\n\n\nObserva que tanto readxl como readr interpretan las columnas de número de experimento, tratamiento y temperatura como variables numéricas debido a que analizan la cantidad de datos para inferir el tipo de variable. No obstante, estas variables son en realidad factores, ya que representan categorías. Más adelante veremos cómo realizar este ajuste de manera manual."
  },
  {
    "objectID": "3.Data_import.html#echando-un-vistado-a-los-datos",
    "href": "3.Data_import.html#echando-un-vistado-a-los-datos",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "Un aspecto importante para el análisis de datos es tener una perspectiva rápida del tibble o datafram para entender las variables que tenemos, asi como los patrones generales de los datos.\nHay varias funciones que podemos utilizar. Ya mencionamos algunas herramienta como head() o tail() para echar un vistazo a las primeras o últimas filas de la tabla, respectivamente.\nOtra herramienta es la función glimpse() de dplyr que nos muestra algunos datos de cada columna de nuestro tibble para tener una idea de la estructura de la tabla.\n\nglimpse(excel_clean)\n\nRows: 405\nColumns: 10\n$ numero_de_muestra      &lt;chr&gt; \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf100U\", \"Hf101U…\n$ numero_de_experimento  &lt;dbl&gt; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,…\n$ tratamiento            &lt;dbl&gt; 24, 24, 24, 24, 30, 30, 30, 30, 30, 30, 30, 30,…\n$ temperatura            &lt;dbl&gt; 18, 18, 32, 32, 18, 18, 32, 32, 18, 18, 32, 32,…\n$ peso_humedo_g          &lt;dbl&gt; 0.093, 0.093, 0.093, 0.093, 0.114, 0.114, 0.114…\n$ buffer_ml              &lt;dbl&gt; 0.93, 0.93, 0.93, 0.93, 1.14, 1.14, 1.14, 1.14,…\n$ volumen_de_reaccion_ul &lt;dbl&gt; 20, 10, 20, 10, 20, 10, 20, 10, 20, 10, 20, 10,…\n$ concentracion_g_ml     &lt;dbl&gt; 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.…\n$ pendiente              &lt;dbl&gt; 0.0331, 0.0145, 0.1431, 0.0653, 0.0354, 0.0155,…\n$ pendiente_2            &lt;dbl&gt; 2.660772, 2.331190, 11.503215, 10.498392, 2.845…\n\n\nLa función summary() es parte de las funciones base de R y es particularmente útil cuando tenemos datos continuos, ya que nos muestra, para cada columna, los valores mínimos, máximos, promedio, mediana y el 1er y 3er quartil.\n\nsummary(excel_clean)\n\n numero_de_muestra  numero_de_experimento  tratamiento     temperatura   \n Length:405         Min.   :1.000         Min.   :18.00   Min.   :18.00  \n Class :character   1st Qu.:2.000         1st Qu.:24.00   1st Qu.:18.00  \n Mode  :character   Median :3.000         Median :24.00   Median :18.00  \n                    Mean   :2.528         Mean   :26.04   Mean   :24.74  \n                    3rd Qu.:4.000         3rd Qu.:30.00   3rd Qu.:32.00  \n                    Max.   :4.000         Max.   :32.00   Max.   :32.00  \n                                                                         \n peso_humedo_g       buffer_ml      volumen_de_reaccion_ul concentracion_g_ml\n Min.   :0.02900   Min.   :0.2900   Min.   :10.00          Min.   :0.1       \n 1st Qu.:0.06700   1st Qu.:0.6700   1st Qu.:10.00          1st Qu.:0.1       \n Median :0.08500   Median :0.8500   Median :20.00          Median :0.1       \n Mean   :0.08387   Mean   :0.8387   Mean   :15.04          Mean   :0.1       \n 3rd Qu.:0.09900   3rd Qu.:0.9900   3rd Qu.:20.00          3rd Qu.:0.1       \n Max.   :0.18900   Max.   :1.8900   Max.   :20.00          Max.   :0.1       \n                                                                             \n   pendiente        pendiente_2    \n Min.   :0.00000   Min.   : 0.000  \n 1st Qu.:0.01480   1st Qu.: 1.632  \n Median :0.03500   Median : 4.594  \n Mean   :0.04949   Mean   : 5.205  \n 3rd Qu.:0.07290   3rd Qu.: 8.163  \n Max.   :0.31390   Max.   :25.233  \n                   NA's   :13      \n\n\nOtra herramienta un poco mas sofisticada pero bastante útil es la función gt_plt_summary() del paquete gtExtras, la cual nos permite gráficar cada una de las variables, nos muestra los valores promedio, mediana y desvicación, y ádemas nos muestra el % de valores faltantes (missing).\nPara utilizar esta herramienta, primero necesitamos instalar el paquete gtExtras y posteriormente cargar la librería.\n\ninstall.packages(\"gtExtras\")\n\n\nlibrary(gtExtras)\n\nWarning: package 'gtExtras' was built under R version 4.3.1\n\ngt_plt_summary(excel_clean)\n\nWarning: Computation failed in `stat_bin()`\nCaused by error in `bin_breaks_width()`:\n! The number of histogram bins must be less than 1,000,000.\nℹ Did you make `binwidth` too small?\n\n\n\n\n\n\n  \n    \n      excel_clean\n    \n    \n      405 rows x 10 cols\n    \n    \n      \n      Column\n      Plot Overview\n      Missing\n      Mean\n      Median\n      SD\n    \n  \n  \n    \nnumero_de_muestra\n                  96 categories\n0.0%\n—\n—\n—\n    \nnumero_de_experimento\n                  14\n0.0%\n2.5\n3.0\n1.1\n    \ntratamiento\n                  1832\n0.0%\n26.0\n24.0\n5.4\n    \ntemperatura\n                  1832\n0.0%\n24.7\n18.0\n7.0\n    \npeso_humedo_g\n                  0.030.19\n0.0%\n0.1\n0.1\n0.0\n    \nbuffer_ml\n                  0.31.9\n0.0%\n0.8\n0.8\n0.3\n    \nvolumen_de_reaccion_ul\n                  1020\n0.0%\n15.0\n20.0\n5.0\n    \nconcentracion_g_ml\n                  00\n0.0%\n0.1\n0.1\n0.0\n    \npendiente\n                  0.000.31\n0.0%\n0.0\n0.0\n0.0\n    \npendiente_2\n                  025\n3.2%\n5.2\n4.6\n4.2"
  },
  {
    "objectID": "3.Data_import.html#exportar-datos",
    "href": "3.Data_import.html#exportar-datos",
    "title": "Leccion 2: Importar y limpiar archivos",
    "section": "",
    "text": "Una vez terminado nuestro análisis debemos guardarlo. Siguiendo la recomendación que vimos anteriormente, lo ideal es guardar los datos ya procesados (ya sea que se haya realizado algún tipo de filtrado o transformación) en una carpeta diferente a la carpeta donde están los datos crudos, los cuales se recomienda que se preserven sin alteraciones.\nPodemos crear una nueva carpeta con Archivos &gt; Nuevo directorio o desde la línea de comando usando la función dir.create()\n\ndir.create(\"resultados/tablas\", recursive = TRUE)\n\nWarning in dir.create(\"resultados/tablas\", recursive = TRUE):\n'resultados\\tablas' already exists\n\n\nPara guardar nuestros datos, las funciones que utilizaremos mas frecuentemente son write.table y write_csv()\nPor ejemplo, vamos a tomar las primeras filas de nuestro objeto excel_clean con la función head()\n\nexcel_subset &lt;- head(excel_clean)\nexcel_subset\n\n# A tibble: 6 × 10\n  numero_de_muestra numero_de_experimento tratamiento temperatura peso_humedo_g\n  &lt;chr&gt;                             &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;\n1 Hf100U                                3          24          18         0.093\n2 Hf100U                                3          24          18         0.093\n3 Hf100U                                3          24          32         0.093\n4 Hf100U                                3          24          32         0.093\n5 Hf101U                                3          30          18         0.114\n6 Hf101U                                3          30          18         0.114\n# ℹ 5 more variables: buffer_ml &lt;dbl&gt;, volumen_de_reaccion_ul &lt;dbl&gt;,\n#   concentracion_g_ml &lt;dbl&gt;, pendiente &lt;dbl&gt;, pendiente_2 &lt;dbl&gt;\n\n\nAhora lo guardamos en la carpeta que acabamos de crear usando la función write_csv()\n\nwrite_csv(excel_subset, file = \"resultados/tablas/excel_subset.csv\")\n\no con write.table() la cual nos permite usar una mayor diversidad de formatos\n\nwrite.table(excel_subset, file = \"resultados/tablas/excel_subset.txt\", sep = \"\\t\")"
  },
  {
    "objectID": "4.data_wrangling.html",
    "href": "4.data_wrangling.html",
    "title": "Lección 3. Manipulación de datos con dplyr. pt I",
    "section": "",
    "text": "Tidy Data es un concepto fundamental dentro del ecosistema Tidyverse en R que se centra en la organización y manipulación eficiente de datos para análisis y visualización.\nEn el contexto de Tidy Data, se busca estructurar los conjuntos de datos de manera que cada observación sea una fila, cada variable sea una columna y cada valor tenga su propia celda. Esto permite que los datos estén organizados en un formato uniforme y consistente, lo que facilita su manipulación y análisis. En resumen, los principios de Tidy Data son:\nEn resumen, un tidy data sigue las siguientes características:\n\nCada variable debe tener su propia columna\nCada observación debe tener su propia fila\nCada valor debe tener su propia celda"
  },
  {
    "objectID": "4.data_wrangling.html#seleccionar-columnas-con-select",
    "href": "4.data_wrangling.html#seleccionar-columnas-con-select",
    "title": "Lección 3. Manipulación de datos con dplyr. pt I",
    "section": "2.1 Seleccionar columnas con select()",
    "text": "2.1 Seleccionar columnas con select()\nPermite seleccionar una o varias columnas de un tibble o data.frame.\nPor ejemplo, si queremos seleccionar solamente las columnas Name, y Attack\n\nselect(pokemon, name, attack)\n\n# A tibble: 801 × 2\n   name       attack\n   &lt;chr&gt;       &lt;dbl&gt;\n 1 Bulbasaur      49\n 2 Ivysaur        62\n 3 Venusaur      100\n 4 Charmander     52\n 5 Charmeleon     64\n 6 Charizard     104\n 7 Squirtle       48\n 8 Wartortle      63\n 9 Blastoise     103\n10 Caterpie       30\n# ℹ 791 more rows\n\n\nRecuerda que si queremos generar un nuevo objeto con ese subset de datos tenemos que asignarlo a otro objeto.\n\npokemon_sub &lt;- select(pokemon, name, attack)\npokemon_sub\n\n# A tibble: 801 × 2\n   name       attack\n   &lt;chr&gt;       &lt;dbl&gt;\n 1 Bulbasaur      49\n 2 Ivysaur        62\n 3 Venusaur      100\n 4 Charmander     52\n 5 Charmeleon     64\n 6 Charizard     104\n 7 Squirtle       48\n 8 Wartortle      63\n 9 Blastoise     103\n10 Caterpie       30\n# ℹ 791 more rows\n\n\nCon select() tambien podemos seleccionar todo menos una columna especifica con el operador -\n\npokemon_sub &lt;- select(pokemon, -attack)\npokemon_sub\n\n# A tibble: 801 × 12\n   pokedex_number name  defense    hp percentage_male sp_attack sp_defense speed\n            &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n 1              1 Bulb…      49    45            88.1        65         65    45\n 2              2 Ivys…      63    60            88.1        80         80    60\n 3              3 Venu…     123    80            88.1       122        120    80\n 4              4 Char…      43    39            88.1        60         50    65\n 5              5 Char…      58    58            88.1        80         65    80\n 6              6 Char…      78    78            88.1       159        115   100\n 7              7 Squi…      65    44            88.1        50         64    43\n 8              8 Wart…      80    59            88.1        65         80    58\n 9              9 Blas…     120    79            88.1       135        115    78\n10             10 Cate…      35    45            50          20         20    45\n# ℹ 791 more rows\n# ℹ 4 more variables: type1 &lt;chr&gt;, weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;,\n#   is_legendary &lt;dbl&gt;\n\n\no podemos seleccionar un intervalo de columnas\n\npokemon_sub &lt;- select(pokemon, name, attack:hp)\npokemon_sub\n\n# A tibble: 801 × 4\n   name       attack defense    hp\n   &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n 1 Bulbasaur      49      49    45\n 2 Ivysaur        62      63    60\n 3 Venusaur      100     123    80\n 4 Charmander     52      43    39\n 5 Charmeleon     64      58    58\n 6 Charizard     104      78    78\n 7 Squirtle       48      65    44\n 8 Wartortle      63      80    59\n 9 Blastoise     103     120    79\n10 Caterpie       30      35    45\n# ℹ 791 more rows\n\n\no lo inverso para descargar un intervalo de columnas\n\npokemon_sub &lt;- select(pokemon, -(attack:hp))\npokemon_sub\n\n# A tibble: 801 × 10\n   pokedex_number name       percentage_male sp_attack sp_defense speed type1\n            &lt;dbl&gt; &lt;chr&gt;                &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n 1              1 Bulbasaur             88.1        65         65    45 grass\n 2              2 Ivysaur               88.1        80         80    60 grass\n 3              3 Venusaur              88.1       122        120    80 grass\n 4              4 Charmander            88.1        60         50    65 fire \n 5              5 Charmeleon            88.1        80         65    80 fire \n 6              6 Charizard             88.1       159        115   100 fire \n 7              7 Squirtle              88.1        50         64    43 water\n 8              8 Wartortle             88.1        65         80    58 water\n 9              9 Blastoise             88.1       135        115    78 water\n10             10 Caterpie              50          20         20    45 bug  \n# ℹ 791 more rows\n# ℹ 3 more variables: weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\nLa función everything() se puede seleccionar todo, y con esto es factible combiar el orden de las columnas. Por ejemplo, si queremos que la primera columna sea type ejecutamos:\n\nselect(pokemon, type1, everything())\n\n# A tibble: 801 × 13\n   type1 pokedex_number name      attack defense    hp percentage_male sp_attack\n   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1 grass              1 Bulbasaur     49      49    45            88.1        65\n 2 grass              2 Ivysaur       62      63    60            88.1        80\n 3 grass              3 Venusaur     100     123    80            88.1       122\n 4 fire               4 Charmand…     52      43    39            88.1        60\n 5 fire               5 Charmele…     64      58    58            88.1        80\n 6 fire               6 Charizard    104      78    78            88.1       159\n 7 water              7 Squirtle      48      65    44            88.1        50\n 8 water              8 Wartortle     63      80    59            88.1        65\n 9 water              9 Blastoise    103     120    79            88.1       135\n10 bug               10 Caterpie      30      35    45            50          20\n# ℹ 791 more rows\n# ℹ 5 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, weight_kg &lt;dbl&gt;,\n#   generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n2.1.1 Seleccionar variables con un patrón\nEstas funcionen ayudad a seleccionar variables según un patrón determinado\n\nstarts_with(): Inicia con un prefijo exacto\nends_with(): Finaliza con un sufijo exacto\ncontains(): Contiene una cadena literal\n\nPor ejemplo, podemos seleccionar las columnas de Sp attack y Sp deffense utilizando el prefijo sp\n\nselect(pokemon, name, starts_with(\"sp_\"))\n\n# A tibble: 801 × 3\n   name       sp_attack sp_defense\n   &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt;\n 1 Bulbasaur         65         65\n 2 Ivysaur           80         80\n 3 Venusaur         122        120\n 4 Charmander        60         50\n 5 Charmeleon        80         65\n 6 Charizard        159        115\n 7 Squirtle          50         64\n 8 Wartortle         65         80\n 9 Blastoise        135        115\n10 Caterpie          20         20\n# ℹ 791 more rows\n\n\nO podemos seleccionar las variables relacionadas con ataque (attack)\n\nselect(pokemon, name, contains(\"attack\"))\n\n# A tibble: 801 × 3\n   name       attack sp_attack\n   &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n 1 Bulbasaur      49        65\n 2 Ivysaur        62        80\n 3 Venusaur      100       122\n 4 Charmander     52        60\n 5 Charmeleon     64        80\n 6 Charizard     104       159\n 7 Squirtle       48        50\n 8 Wartortle      63        65\n 9 Blastoise     103       135\n10 Caterpie       30        20\n# ℹ 791 more rows"
  },
  {
    "objectID": "4.data_wrangling.html#filtrar-variables-con-filter",
    "href": "4.data_wrangling.html#filtrar-variables-con-filter",
    "title": "Lección 3. Manipulación de datos con dplyr. pt I",
    "section": "2.2 Filtrar variables con filter()",
    "text": "2.2 Filtrar variables con filter()\n\nLa función filter() nos permite filtrar los elementos de una variable (columna) que cumplan con una condición especifica.\nPor ejemplo, para filtrar pokemon que tengan un nivel de ataque (Attack) superior a 100 usariamos\n\nfilter(pokemon, attack &gt; 100)\n\n# A tibble: 169 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              6 Charizard     104      78    78            88.1       159\n 2              9 Blastoise     103     120    79            88.1       135\n 3             15 Beedrill      150      40    65            50          15\n 4             34 Nidoking      102      77    81           100          85\n 5             57 Primeape      105      60    65            50          60\n 6             59 Arcanine      110      80    90            75.4       100\n 7             68 Machamp       130      80    90            75.4        65\n 8             71 Victreebel    105      65    80            50         100\n 9             76 Golem         120     130    80            50          55\n10             85 Dodrio        110      70    60            50          60\n# ℹ 159 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\nPara establecer varios condiciones, simplemente las podemos separar por una ,. Por ejemplo, si queremos filtrar a los pokemon que tengan un nivel de ataque mayor a 100 y que sea de tipo fuego (fire)\n\nfilter(pokemon, attack &gt; 100, type1 == \"fire\")\n\n# A tibble: 11 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              6 Charizard     104      78    78            88.1       159\n 2             59 Arcanine      110      80    90            75.4       100\n 3            136 Flareon       130      60    65            88.1        95\n 4            244 Entei         115      85   115            NA          90\n 5            250 Ho-Oh         130      90   106            NA         110\n 6            257 Blaziken      160      80    80            88.1       130\n 7            323 Camerupt      120     100    70            50         145\n 8            392 Infernape     104      71    76            88.1       104\n 9            500 Emboar        123      65   110            88.1       100\n10            721 Volcanion     110     120    80            NA         130\n11            727 Incineroar    115      90    95            88.1        80\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nSi tienes muchas condiciones, puedes escribir cada condición en una línea diferente.\n\nfilter(pokemon, attack &gt; 100,\n       type1 == \"fire\",\n       generation == 1, \n       speed &gt; 50)\n\n\n\nSi queremos filtrar distintas condiciones de una misma variable (columna) podemos usar el operador %in%.\nPor ejemplo, para filtar los pokemon que sean de tipo fuego y agua\n\nfilter(pokemon, type1 %in% c(\"fire\", \"water\"))\n\n# A tibble: 166 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              4 Charmander     52      43    39            88.1        60\n 2              5 Charmeleon     64      58    58            88.1        80\n 3              6 Charizard     104      78    78            88.1       159\n 4              7 Squirtle       48      65    44            88.1        50\n 5              8 Wartortle      63      80    59            88.1        65\n 6              9 Blastoise     103     120    79            88.1       135\n 7             37 Vulpix         41      40    38            24.6        50\n 8             38 Ninetales      67      75    73            24.6        81\n 9             54 Psyduck        52      48    50            50          65\n10             55 Golduck        82      78    80            50          95\n# ℹ 156 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\nNota\n\n\n\nSi tienes muchas condiciones o si tienes las mismas condiciones que quieres filtrar en distintos sets de datos, puedes hacer un vector y despues incorporarlo en la funcion filter. Por ejemplo\n\ntipos &lt;- c(\"fire\", \"normal\", \"water\")\n\nfilter(pokemon, type1 %in% tipos)\n\n# A tibble: 271 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              4 Charmander     52      43    39            88.1        60\n 2              5 Charmeleon     64      58    58            88.1        80\n 3              6 Charizard     104      78    78            88.1       159\n 4              7 Squirtle       48      65    44            88.1        50\n 5              8 Wartortle      63      80    59            88.1        65\n 6              9 Blastoise     103     120    79            88.1       135\n 7             16 Pidgey         45      40    40            50          35\n 8             17 Pidgeotto      60      55    63            50          50\n 9             18 Pidgeot        80      80    83            50         135\n10             19 Rattata        56      35    30            50          25\n# ℹ 261 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\nEs posbile filtrar un intervalo de valores utilizando la función between(). Esta función requiere como argumentos el nombre de la variable que queremos filtrar, el límite inferior y el límite superior.\nPor ejemplo, si queremos filtrar los pokemon que tengan un nivel de ataque (attack) mayor a 100 pero menor a 150\n\nfilter(pokemon, between(attack, 100, 150))\n\n# A tibble: 191 × 13\n   pokedex_number name      attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              3 Venusaur     100     123    80            88.1       122\n 2              6 Charizard    104      78    78            88.1       159\n 3              9 Blastoise    103     120    79            88.1       135\n 4             15 Beedrill     150      40    65            50          15\n 5             28 Sandslash    100     120    75            50          25\n 6             34 Nidoking     102      77    81           100          85\n 7             51 Dugtrio      100      60    35            50          50\n 8             57 Primeape     105      60    65            50          60\n 9             59 Arcanine     110      80    90            75.4       100\n10             67 Machoke      100      70    80            75.4        50\n# ℹ 181 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\nPodemos usar la operación opuesta utilizando el operado !\n\nfilter(pokemon, !between(attack, 100, 150))\n\n# A tibble: 610 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              1 Bulbasaur      49      49    45            88.1        65\n 2              2 Ivysaur        62      63    60            88.1        80\n 3              4 Charmander     52      43    39            88.1        60\n 4              5 Charmeleon     64      58    58            88.1        80\n 5              7 Squirtle       48      65    44            88.1        50\n 6              8 Wartortle      63      80    59            88.1        65\n 7             10 Caterpie       30      35    45            50          20\n 8             11 Metapod        20      55    50            50          25\n 9             12 Butterfree     45      50    60            50          90\n10             13 Weedle         35      50    40            50          20\n# ℹ 600 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\nEjercicio: ¿¡QUIEN ES ESE POKEMON!? 📣\n\n\n\n\nNuestro pokémon tiene un valor de HP entre 100 y 200; valor de velocidad menor a 50; es del tipo1 Normal; tiene un valor de defensa menor a 40 y pertenece a la primera generación\n\n\nver codigo\nfilter(pokemon, between(hp, 100, 200),\n       speed &lt; 50,\n       type1 == \"normal\",\n       defense &lt; 40,\n       generation == 1)\n\n\n\n\n\n\n\n\n\n\n\n2.2.1 Filtrar variables con un patrón; str_detec()\nTambien es posible filtrar una variable a partir de un caracter en especifico usando la función str_detect().\n\nfilter(pokemon, str_detect(name, \"eon\"))\n\n# A tibble: 13 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              5 Charmeleon     64      58    58            88.1        80\n 2            134 Vaporeon       65      60   130            88.1       110\n 3            135 Jolteon        65      60    65            88.1       110\n 4            136 Flareon       130      60    65            88.1        95\n 5            196 Espeon         65      60    65            88.1       130\n 6            197 Umbreon        65     110    95            88.1        60\n 7            352 Kecleon        90      70    60            50          60\n 8            395 Empoleon       86      88    84            88.1       111\n 9            456 Finneon        49      56    49            50          49\n10            457 Lumineon       69      76    69            50          69\n11            470 Leafeon       110     130    65            88.1        60\n12            471 Glaceon        60     110    65            88.1       130\n13            700 Sylveon        65      65    95            88.1       110\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\nSi buscamos multiples patrones dentro de nuestra variable con caracteres, podemos separarlas dentro de las comillas usando el símbolo “|”. Por ejemplo, si queremos buscar los Pokemon cuyo nombre termine con “saur” o que empieza con “Char”:\n\nfilter(pokemon, str_detect(name, \"saur|Char\"))\n\n# A tibble: 7 × 13\n  pokedex_number name  attack defense    hp percentage_male sp_attack sp_defense\n           &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n1              1 Bulb…     49      49    45            88.1        65         65\n2              2 Ivys…     62      63    60            88.1        80         80\n3              3 Venu…    100     123    80            88.1       122        120\n4              4 Char…     52      43    39            88.1        60         50\n5              5 Char…     64      58    58            88.1        80         65\n6              6 Char…    104      78    78            88.1       159        115\n7            737 Char…     82      95    57            50          55         75\n# ℹ 5 more variables: speed &lt;dbl&gt;, type1 &lt;chr&gt;, weight_kg &lt;dbl&gt;,\n#   generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;\n\n\n\n\n\n\n\n\nEjercicio: Una galaxía muy lejana…\n\n\n\nAbre la tabla starwars que se encuentra en el directorio de databases y genera los siguientes objetos:\n\nUna tabla que incluya solamente el nombre del personaje y todas las variables relacionadas con colores.\nUna tabla que incluya solamente los personajes femeninos del planeta Naboo.\nUna tabla con los personajes que hayan aparecido en Attack of the Clones."
  },
  {
    "objectID": "4.data_wrangling.html#transformar-o-crear-columnas-con-mutate",
    "href": "4.data_wrangling.html#transformar-o-crear-columnas-con-mutate",
    "title": "Lección 3. Manipulación de datos con dplyr. pt I",
    "section": "2.3 Transformar o crear columnas con mutate()",
    "text": "2.3 Transformar o crear columnas con mutate()\n\n\n\n\n\nLa función mutate() es una función versatil en el sentido que nos permite crear nuevas variables que contengan alguna operación a partir de las que ya tenemos, añadir una nueva variable o transformar una variable ya existente\nPor ejemplo, podemos generar una nueva columna llamada “at_df_ratio” con la propoción de los valores de Ataque sobre Defensa\n\npokemon_mutate &lt;- mutate(pokemon, at_df_ratio = attack/defense )\n\nhead(pokemon_mutate$at_df_ratio)\n\n[1] 1.0000000 0.9841270 0.8130081 1.2093023 1.1034483 1.3333333\n\n\nDe igual manera, se pueden generar diversas nuevas columnas en una misma función separadas por comas.\n\npokemon_mutate &lt;- mutate(pokemon, \n                         at_df_ratio = attack/defense,\n                         at_df_per = at_df_ratio * 100,\n                         nueva_col = \"nueva columna\")\n\npokemon_mutate\n\n# A tibble: 801 × 16\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              1 Bulbasaur      49      49    45            88.1        65\n 2              2 Ivysaur        62      63    60            88.1        80\n 3              3 Venusaur      100     123    80            88.1       122\n 4              4 Charmander     52      43    39            88.1        60\n 5              5 Charmeleon     64      58    58            88.1        80\n 6              6 Charizard     104      78    78            88.1       159\n 7              7 Squirtle       48      65    44            88.1        50\n 8              8 Wartortle      63      80    59            88.1        65\n 9              9 Blastoise     103     120    79            88.1       135\n10             10 Caterpie       30      35    45            50          20\n# ℹ 791 more rows\n# ℹ 9 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;, at_df_ratio &lt;dbl&gt;,\n#   at_df_per &lt;dbl&gt;, nueva_col &lt;chr&gt;\n\n\nCon mutate(), también es posible cambiar el tipo de dato de cada columna. Por ejemplo, cambiar la columna “Type1” de carácter a factor:\n\npokemon_mutate &lt;- mutate(pokemon, type1 = factor(type1))\npokemon_mutate\n\n# A tibble: 801 × 13\n   pokedex_number name       attack defense    hp percentage_male sp_attack\n            &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1              1 Bulbasaur      49      49    45            88.1        65\n 2              2 Ivysaur        62      63    60            88.1        80\n 3              3 Venusaur      100     123    80            88.1       122\n 4              4 Charmander     52      43    39            88.1        60\n 5              5 Charmeleon     64      58    58            88.1        80\n 6              6 Charizard     104      78    78            88.1       159\n 7              7 Squirtle       48      65    44            88.1        50\n 8              8 Wartortle      63      80    59            88.1        65\n 9              9 Blastoise     103     120    79            88.1       135\n10             10 Caterpie       30      35    45            50          20\n# ℹ 791 more rows\n# ℹ 6 more variables: sp_defense &lt;dbl&gt;, speed &lt;dbl&gt;, type1 &lt;fct&gt;,\n#   weight_kg &lt;dbl&gt;, generation &lt;dbl&gt;, is_legendary &lt;dbl&gt;"
  },
  {
    "objectID": "4.data_wrangling.html#operaciones-agrupadas",
    "href": "4.data_wrangling.html#operaciones-agrupadas",
    "title": "Lección 3. Manipulación de datos con dplyr. pt I",
    "section": "5.1 Operaciones agrupadas",
    "text": "5.1 Operaciones agrupadas\nConsiderando la base de datos, seria mas informativo obtener el promedio por especie o por isla. La función group_by() permite agrupar los datos de acuerdo a alguna variable (factor).\nPor ejemplo, para obtener el peso promedio por especie:\n\npenguins %&gt;% \n  group_by(species) %&gt;% \n  summarise(promedio_peso = mean(body_mass_g, na.rm = TRUE))\n\n# A tibble: 3 × 2\n  species   promedio_peso\n  &lt;chr&gt;             &lt;dbl&gt;\n1 Adelie            3701.\n2 Chinstrap         3733.\n3 Gentoo            5076.\n\n\nPodemos agrupar utilizando mas variables separadas por una coma:\n\npenguins %&gt;% \n  group_by(island, species, sex) %&gt;% \n  summarise(promedio_peso = mean(body_mass_g, na.rm = TRUE),\n            desviacion = sd(body_mass_g, na.rm = TRUE),\n            N = n())\n\n`summarise()` has grouped output by 'island', 'species'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 13 × 6\n# Groups:   island, species [5]\n   island    species   sex    promedio_peso desviacion     N\n   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt;\n 1 Biscoe    Adelie    female         3369.       343.    22\n 2 Biscoe    Adelie    male           4050        356.    22\n 3 Biscoe    Gentoo    female         4680.       282.    58\n 4 Biscoe    Gentoo    male           5485.       313.    61\n 5 Biscoe    Gentoo    &lt;NA&gt;           4588.       338.     5\n 6 Dream     Adelie    female         3344.       212.    27\n 7 Dream     Adelie    male           4046.       331.    28\n 8 Dream     Adelie    &lt;NA&gt;           2975         NA      1\n 9 Dream     Chinstrap female         3527.       285.    34\n10 Dream     Chinstrap male           3939.       362.    34\n11 Torgersen Adelie    female         3396.       259.    24\n12 Torgersen Adelie    male           4035.       372.    23\n13 Torgersen Adelie    &lt;NA&gt;           3681.       413.     5\n\n\nExisten otras funciones útiles por las que nos podría interesar agrupar\n\ncount()\nmean()\nmedian()\nmin()\nmax()\nquantile(x, 0.25)\nIQR()\n\nEl uso de la función group_by() tambien nos permite transformar una variable e incluirla en una columna en conjunto con la función mutate()\n\npenguins %&gt;% \n  group_by(species, island,sex) %&gt;% \n  mutate(promedio_peso_grupo = mean(body_mass_g, na.rm = TRUE)) %&gt;% \n  select(promedio_peso_grupo, everything())\n\n# A tibble: 344 × 9\n# Groups:   species, island, sex [13]\n   promedio_peso_grupo species island    bill_length_mm bill_depth_mm\n                 &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;\n 1               4035. Adelie  Torgersen           39.1          18.7\n 2               3396. Adelie  Torgersen           39.5          17.4\n 3               3396. Adelie  Torgersen           40.3          18  \n 4               3681. Adelie  Torgersen           NA            NA  \n 5               3396. Adelie  Torgersen           36.7          19.3\n 6               4035. Adelie  Torgersen           39.3          20.6\n 7               3396. Adelie  Torgersen           38.9          17.8\n 8               4035. Adelie  Torgersen           39.2          19.6\n 9               3681. Adelie  Torgersen           34.1          18.1\n10               3681. Adelie  Torgersen           42            20.2\n# ℹ 334 more rows\n# ℹ 4 more variables: flipper_length_mm &lt;dbl&gt;, body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;,\n#   year &lt;dbl&gt;"
  },
  {
    "objectID": "4.data_wrangling.html#resumir-todas-las-variables-con-summarise_all",
    "href": "4.data_wrangling.html#resumir-todas-las-variables-con-summarise_all",
    "title": "Lección 3. Manipulación de datos con dplyr. pt I",
    "section": "5.2 Resumir todas las variables con summarise_all()",
    "text": "5.2 Resumir todas las variables con summarise_all()\nLa función summarise_all() requiere una función como argumento, la cual aplica a todas las columnas de la tabla. En este ejemplo se agrego el argumento na.rm = TRUE el cual ignora los NAs\n\npenguins %&gt;% \n  group_by(species, island, sex) %&gt;% \n  summarise_all(mean, na.rm = TRUE) \n\n# A tibble: 13 × 8\n# Groups:   species, island [5]\n   species   island    sex    bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1 Adelie    Biscoe    female           37.4          17.7              187.\n 2 Adelie    Biscoe    male             40.6          19.0              190.\n 3 Adelie    Dream     female           36.9          17.6              188.\n 4 Adelie    Dream     male             40.1          18.8              192.\n 5 Adelie    Dream     &lt;NA&gt;             37.5          18.9              179 \n 6 Adelie    Torgersen female           37.6          17.6              188.\n 7 Adelie    Torgersen male             40.6          19.4              195.\n 8 Adelie    Torgersen &lt;NA&gt;             37.9          18.2              187.\n 9 Chinstrap Dream     female           46.6          17.6              192.\n10 Chinstrap Dream     male             51.1          19.3              200.\n11 Gentoo    Biscoe    female           45.6          14.2              213.\n12 Gentoo    Biscoe    male             49.5          15.7              222.\n13 Gentoo    Biscoe    &lt;NA&gt;             45.6          14.6              216.\n# ℹ 2 more variables: body_mass_g &lt;dbl&gt;, year &lt;dbl&gt;"
  },
  {
    "objectID": "5_visualization_ggplot.html",
    "href": "5_visualization_ggplot.html",
    "title": "Visualización de datos con ggplot2",
    "section": "",
    "text": "La visualización es uno de los aspectos mas importantes para comunicar una idea a partir de un set de datos. R base contiene una serie de herramientas bastante poderosas para crear visualizaciones atractivas y eficientes de manera muy flexible. Sin embargo, dentro de esta flexibilidad se puede crear confusión en el lenguaje para crear un gráfico.\nSi bien muchos tipos de visualizaciones en R base son relativamente intuitivos, por ejemplo hist(), barplot(), bowplot(), la cosa se complica cuando se quiere incluir distintas capas o diferenciar grupos (por ejemplo, abline(), par(), etc.)\nPor otro lado, ggplot2 es un motor gráfico basado en la gramática grafica de Wilkinson. Bajo este contexto, un gráfico es una serie de capas (layers) similares a una transparecia, con algo impreso en ellas, que puede ser texto, puntos, lineas, barras, o cualquier otro tipo de representación. La imagen final, cada una de estas capas se colocan una sobre otra.\n\n\n\nImagen adaptada de The Grammar of Graphics\n\n\nAdemás, ggplot2 se desarrolla dentro de la filosofia de Tidyverse por lo que usa una sintaxis mas simple e intuitiva para el usuario.\nTomemos como ejemplo la base de datos de penguins. Si queremos graficar un boxplot con la longitud del pico de los pingüinos Adelie en todas las islas, en R base seria algo como esto:\n\npenguins &lt;- read_csv(\"data/palmer_penguins.csv\") %&gt;% \n  na.omit()\n\npenguins_adeline &lt;- penguins[penguins$species == \"Adelie\", ]\n\npar(mfrow = c(1,3), oma = c(0, 0, 2, 0))\n\nboxplot(bill_length_mm ~ sex, data = penguins_adeline, main= \"isla1\")\nboxplot(bill_length_mm ~ sex, data = penguins_adeline, main = \"isla2\")\nboxplot(bill_length_mm ~ sex, data = penguins_adeline, main = \"isla3\")\nmtext(\"Datos de longitud del culmen\", outer = TRUE)\n\n\n\ndev.off()\n\nnull device \n          1 \n\n\n…mientras que con ggplot podemos usar la siguiente sintaxis:\n\npenguins %&gt;% \n  filter(species == \"Adelie\") %&gt;% \n  ggplot(aes(x = sex, y = bill_length_mm))+\n  geom_boxplot()+\n  facet_wrap(~island)+\n  labs(title = \"Datos de longitud del culmen\")"
  },
  {
    "objectID": "5_visualization_ggplot.html#poniendo-capas-ggplot",
    "href": "5_visualization_ggplot.html#poniendo-capas-ggplot",
    "title": "Visualización de datos con ggplot2",
    "section": "2.1 Poniendo capas: ggplot()",
    "text": "2.1 Poniendo capas: ggplot()\nPara crear un gráfico con ggplot se usa el comando ggplot()\n\nggplot(data = penguins)\n\n\n\n\nAl ejecutar la función, no da error pero no vemos ninguna gráfica. Esto se debe a que no hemos indicado a ggplot cuales son las coordenadas y ni las geometrías que queremos gráficar.\nPara designar los estéticos, definimos el plano usando los datos de la longitud del culmen y la masa corporal ejecutando:\n\nggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g))\n\n\n\n\nEl argumento aes() es sinónimo de estética. ggplot2 considera que el eje x y y de la gráfica es estético, junto con el color, el tamaño, la forma, el relleno, etc. Se puede agregar cualquier estética que se desee dentro del argumento aes(), como por ejemplo indicar los ejes x y y, especificando las variables respectivas del conjunto de datos.\nLa variable en función de la cual el color, tamaño, forma y trazo debe cambiar también se puede especificar aquí mismo. Debes tener en cuenta que la estética especificada aquí será heredada por todas las capas geom() que se agregarán posteriormente.\nSin embargo, aún no vemos ninguna gráfica, ya que para esto es necesario indicar que tipo de geometría (geom()) de gráfica queremos utilizar.\nPara crear un diagrama, por ejemplo, de dispersión es necesario agregarle la geometria geom_point(). Es importante recalcar que cada nueva capa que agreguemos al gráfico se agrega con el símbolo +.\n\nggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g))+\n  geom_point()\n\n\n\n\n\n\n\n\n\n\n\n\nDonde poner los aes?\n\n\n\nLos aes() se pueden definir desde que se inicia la función ggplot()pero estos aes se heredaran al resto de las capas. Por otro lado, se pueden definir los aes dentro de cada geom()\n\nggplot(data = data, aes(x = x, y = y))+\n  geom_point()\n\nes igual que\n\nggplot()+\n  geom_point(data = data, aes(x = x, y = y))"
  },
  {
    "objectID": "5_visualization_ggplot.html#aesthetics",
    "href": "5_visualization_ggplot.html#aesthetics",
    "title": "Visualización de datos con ggplot2",
    "section": "2.2 Aesthetics()",
    "text": "2.2 Aesthetics()\nComo mencionamos, es posible agregar diferentes estéticos a la gráfica para controlar diversos aspectos como color, tamaño, forma, etc. Esto nos permite asignarle un estético a los grupos.\npor ejemplo, podemos asignarle un color diferente a cada especie con el argumento color\n\nggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g, color = species))+\n  geom_point()\n\n\n\n\nY asignarle una forma diferente a por sexo con el argumento shape\n\nggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g, color = species, shape = sex))+\n  geom_point()\n\n\n\n\no cambiar el tamaño con size\n\nggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g, color = species, shape = sex, size = bill_length_mm))+\n  geom_point()\n\n\n\n\n\nggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g, color = species))+\n  geom_point()+\n  geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nggplot(data = penguins)+\n  geom_point(aes(x = bill_length_mm, y = body_mass_g, color = species))+\n  geom_smooth(aes(x = bill_length_mm, y = body_mass_g), method = \"lm\", color = \"grey75\")+\n  geom_smooth(aes(x = bill_length_mm, y = body_mass_g, color = species), method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "5_visualization_ggplot.html#breve-tour-por-las-distintas-geometrias",
    "href": "5_visualization_ggplot.html#breve-tour-por-las-distintas-geometrias",
    "title": "Visualización de datos con ggplot2",
    "section": "2.3 Breve tour por las distintas geometrias",
    "text": "2.3 Breve tour por las distintas geometrias\nLos nombres de las funciones de geometría siguen el patrón: geom_X donde X es el nombre de la geometría. Algunos ejemplos incluyen geom_point, geom_bar y geom_histogram.\nA continuación repasaremos algunas de las geometrías mas comunes:\n\n2.3.1 Visualización de una variable continua\nPara facilitar el tour, vamos a generar un objeto con las coordenadas de la longitud del pico\n\nbase &lt;- ggplot(penguins, aes(x = bill_length_mm, fill = species))\n\n\ngeom_histogram()\n\nbase + \n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\ngeom_density()\n\nbase +\n  geom_density()\n\n\n\n\n\n\ngeom_qqplot()\n\nggplot(penguins, aes(sample = bill_length_mm, color = species)) +\n  geom_qq()\n\n\n\n\n\n\n\n2.3.2 Visualización de variables discretas\n\ngeom_bar() y geom_col()\nLas gráficas de barras son una de las visualizaciones mas comunes. ggplot ofrece dos alternativas dependiendo del formato de los datos que se vayan a graficar. Una descripción mas detallada sobre la diferencia entre ambos se puede encontrar aquí.\nRecordemos en nuestra sesión pasada que podemos contar el número de apariciones de un elemento dentro de un grupo con la función count()\n\npenguins %&gt;% \n  count(species)\n\n# A tibble: 3 × 2\n  species       n\n  &lt;chr&gt;     &lt;int&gt;\n1 Adelie      146\n2 Chinstrap    68\n3 Gentoo      119\n\n\nDe manera análoga, geom_bar() calculará el número de ocurrencias en cada nivel de una variable categórica.\n\nggplot(penguins, aes(x = species))+\n  geom_bar()\n\n\n\n\nPor el contrario, si queremos que gráfique un valor ya establecido en los datos, tenemos que incorporar el parámetro stat = \"identity\".\n\npenguins %&gt;%  \n  count(species) %&gt;%  \nggplot(., aes(x = species, y = n))+\n  geom_bar(stat = \"identity\")\n\n\n\n\nPor otro lado, geom_col() es lo mismo que geom_bar(stat = \"identity\"), por lo que si tus datos contienen groups y el número de apariciones de cada uno de estos, puedes utilizar esta función\n\npenguins %&gt;% \n  count(species) %&gt;% \n  ggplot(.,aes(x = species, y = n))+\n  geom_col()\n\n\n\n\nPodemos incorporar mas variables discretas dentro de los aes() incorporando la variable fill=\n\nggplot(penguins, aes(x = species, fill = sex)) +\n  geom_bar()\n\n\n\n\nPor default, geom_bar() nos arrojará una gráfica de barras apiladas. Si queremos poner cada grupo por separado, incorporamos el parametro position = \"dodge\"\n\nggplot(penguins, aes(x = species, fill = sex)) +\n  geom_bar(position = \"dodge\")\n\n\n\n\nO usar position=\"fill\" para que nos arroje valores proporcionales\n\nggplot(penguins, aes(x = species, fill = sex)) +\n  geom_bar(position = \"fill\")\n\n\n\n\n\n\n\n\n\n\nEjercicio: Star Wars\n\n\n\n\nAbre la tabla starwars.csv que se encuentra en el directorio de databases y utilizando pipes genera los siguientes objetos:\n\nUna gráfico de densidad donde se compare la distribución de los valore sde altura height de los planetas Tatooine y Naboo, excluyendo los androides.\nUna gráfica de barras de los mismas planetas y excluyendo androides donde se muestre la proporción de sexos.\nUna gráfica de barras donde se muestre el número de personajes de cada planeta del filme A New Hope\n\n\n\nver codigo\nstarwars &lt;- read_csv(\"data/starwars.csv\")\n\n#ejercicio e1\nstarwars %&gt;% \n  filter(homeworld %in% c(\"Tatooine\", \"Naboo\")) %&gt;% \n  filter(species != \"droid\") %&gt;% \n  ggplot(., aes(x = height, fill = homeworld))+\n  geom_density()\n\n\n# ejercicio e2\nstarwars %&gt;% \n  filter(homeworld %in% c(\"Tatooine\", \"Naboo\")) %&gt;% \n  filter(species != \"droid\") %&gt;% \n  ggplot(.,aes(x = homeworld, fill = sex))+\n  geom_bar(position = \"fill\")\n\n# ejercicio e3\nstarwars %&gt;% \n  filter(str_detect(films, \"A New Hope\")) %&gt;% \n  ggplot(., aes(x = homeworld)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.3.3 Visualización de una variable discreta + una continua\n\nBoxplot (diagrama de cajas y bigotes)\nUn diagrama de cajas y bigotes, también conocido como boxplot, es una representación gráfica que proporciona una descripción visual de la distribución de un conjunto de datos. Este tipo de gráfico es particularmente útil para resumir la variabilidad y la dispersión de los datos, así como para identificar la presencia de valores atípicos.\nLa caja de un boxplot comienza en el primer cuartil Q1 (25%) y termina en el tercero Q3 (75%). Por lo tanto, la caja representa el 50% de los datos centrales, con una línea que representa la mediana. A cada lado de la caja se dibuja un segmento con los datos más lejanos sin contar los valores atípicos (outliers) del boxplot, que en caso de existir, se representarán con círculos.\n\n\n\nPartes de un boxplot de una distribución normal. Imagen tomada de Byjus.com\n\n\n\nggplot(data = penguins, aes(x = species, y = bill_length_mm, fill = sex))+\n  geom_boxplot()\n\n\n\n\nOtra opción para visualizar la dispersión de los datos es utilizando gráficos de violin. Esto es particularmente útil cuando se tienen muchos datos.\n\nggplot(data = penguins, aes(x = species, y = bill_length_mm, fill = sex))+\n  geom_violin()\n\n\n\n\n\n\ngeom_point() y geom_jitter()\nLa función geom_point() es una función versatil ya que nos permite crear gráficos de dispersión (mas adelante) o para vidualizar la dispersión real de los datos categóricos\n\nggplot(data = penguins, aes(x = species, y = bill_length_mm, color = sex))+\n  geom_point()\n\n\n\n\nEsta visualización es poco útil ya que todos los puntos se traslapan. Para poder separar cada uno de los grupos (sexo) necesitamos incluir el parámetro position = para darle espacio entre cada grupo\n\nggplot(data = penguins, aes(x = species, y = bill_length_mm, color = sex))+\n  geom_point(position = position_dodge(0.2))\n\n\n\n\nEl parámetro posiiton = se puede incluir en cualquier tipo de geoms, no solo en los puntos, y permite ajustar el traslape entre grupos. Tiene varias opciones. Entre las mas útiles que utilizaremos en este curso se encuentra:\n\nposition_dodge(): Esquiva el traslape lado a lado entre objettos\nposition_jitter(): Agrega una dispersión aleatoria en el eje x a los puntos para eviar que se traslape\nposition_jitterdodge(): Agrega de forma simultanea un jitter y dodge a los puntos\nposition_identity(): No ajusta la posición de los puntos\n\nEntonces, podemos incorporar el parámetro position_jitterdodge() para disminuir el traslape entre los puntos entre y dentor de cada grupo\n\nggplot(data = penguins, aes(x = species, y = bill_length_mm, color = sex))+\n  geom_point(position = position_jitterdodge(0.1))\n\n\n\n\n\n\n\n\n\n\n\n\n¿Jitter? 🤷️\n\n\n\nEn dotplots, el jitter se refiere al desplazamiento aleatorio de puntos de datos individuales a lo largo del eje para evitar superposiciones, proporcionando una representación más clara de la distribución de datos.\nDado que el valor es aleatorio, cada que se genere la gráfica, el desplazamiento de cada puto puede variar un poco sobre el eje x, pero su valor real (eje y) no se verá afectado.\n\n\n\n\n\n2.3.4 Visualización de una variable continua + una continua\nEste tipo de visualizaciones nos permite ver la relación entre dos variables continuas. Hay diversos geoms que podemos implementar, pero el más común es nuevamente geom_point().\n\nggplot(data = penguins, aes(x = body_mass_g, y = bill_length_mm, color = sex))+\n  geom_point()\n\n\n\n\n\n\n2.3.5 Visualización de resumenes estadisticos: geom_errorbar()\nMuchas veces queremos mostrar de forma clara y sencilla como se comportan nuestro datos, por lo que podemos mostrar solamente algunos estadisticos básicos, como el promedio y el grado de dispersión de los datos usando ya sea la desviación estandar o el error estandar. Esto lo podemos lograr utilizando funciones como geom_point() en conjunto con barras de dispersión con la función geom_errorbar().\nal igual que otros geoms, geom_errorbar() requiere que indiquemos su posición en el eje x, pero también requiere que indiquemos sus limites superior e inferior sobre el eje y con los parámetros ymax = y ymin =, respectivamente.\nPara esto, primero necesitamos calcular estos estadísticos antes de gráficarlos.\nPor ejemplo, calculemos el promedio y la desviación estándar de la longitud del pico para cada especie de pingüinos, por sexo.\n\npenguins_estat &lt;- penguins %&gt;% \n  group_by(species) %&gt;% \n  summarise(promedio = mean(bill_length_mm, na.rm = TRUE),\n            desvest = sd(bill_length_mm, na.rm = TRUE)) %&gt;% \n  ungroup()\n\nggplot(penguins_estat, aes(x = species, y = promedio))+\n  geom_point() +\n  geom_errorbar(aes(ymin = promedio - desvest, ymax = promedio + desvest))\n\n\n\n\nEn este caso utilizamos un punto para indicar el promedio, pero también podemos utilizar un gráfico de barras.\n\nggplot(penguins_estat, aes(x = species, y = promedio))+\n  geom_col() +\n  geom_errorbar(aes(ymin = promedio - desvest, \n                    ymax = promedio + desvest), \n                width = 0.5)\n\n\n\n\n\n\n\n\n\n\nDesafio pingüinos\n\n\n\nRealiza una gráfica de barras donde se muestre el promedio \\(\\pm\\) desviación estandar de la longitud del pico de cada especie y sexo. Distingue los sexos por el color de relleno de las barras.\nRecuerda que puedes incluir el parámetros position = position_dodge() para separar las barras entre grupos\n\n\nver codigo\npenguins %&gt;% \n  group_by(species, sex) %&gt;% \n  summarise(promedio = mean(bill_length_mm, na.rm = TRUE),\n            desvest = sd(bill_length_mm, na.rm= TRUE), \n            .groups = \"drop\") %&gt;% \n  ggplot(., aes(x = species, y = promedio, fill = sex)) +\n  geom_col(position = position_dodge(), color = \"black\")+\n  geom_errorbar(aes(ymin = promedio - desvest, ymax = promedio + desvest),\n                width = 0.5, position = position_dodge(0.9))\n\n\n\n\n\n\n\n\n\n\nLos amigos no permiten que sus amigos hagan gráficas de barras\n\n\n\nMuchas veces al presentar los datos de una investigación nos vamos directamente a mostrar el promedio \\(\\pm\\) desviación estandar o algún otro valor de dispersión pero puede que esto no muestre toda la verdad sobre la distribución de los datos. Como demostración haz el siguiente ejercicio:\n\nAbre la tabla datos_demo.csv que se encuentra en la carpeta de datos\nSin hacer ningún tipo de observación previa, has una gráfica donde se muestra el promedio \\(\\pm\\) desviación estándar. Para ello utiliza las funciones group0_by() y summarise() que hemos visto anteriormente.\nAhora, utilizando el set de datos completo gráfica la dispersión de los datos y añade un boxplot.\n\n\n\nver codigo\ndemo &lt;- read_csv(\"data/datos_demo.csv\")\n\n\n# promedios\ndemo %&gt;% \n  group_by(grupo) %&gt;% \n  summarise(promedio = mean(valor),\n            desvest = sd(valor)) %&gt;% \n  ggplot(.,aes(x = grupo, y = promedio, fill = grupo))+\n  geom_col()+\n  geom_errorbar(aes(ymin = promedio - desvest, ymax = promedio + desvest),\n                width = 0.3)\n\n# datos completos\ndemo %&gt;% \n  ggplot(.,aes(x = grupo, y = valor, color = grupo))+\n  geom_boxplot()+\n  geom_point(position = position_jitterdodge(0.2))\n\n\n¿Que conclusiones puedes sacar de ambas gráficas?\nEl uso de histogramas, densidades o gráficas de dispersión nos permite hacer un análisis exploratorio de los datos, permitiendo tomar mejores decisiones sobre el tipo de estadisticos o procesamiento que se van a utilizar.\nPuedes encontrar una discusión mas profunda sobra la importancia de la correcta presentación e interpretación de datos en publicaciones científicas aquí"
  },
  {
    "objectID": "5.visualization_ggplot.html",
    "href": "5.visualization_ggplot.html",
    "title": "Visualización de datos con ggplot2",
    "section": "",
    "text": "La visualización es uno de los aspectos mas importantes para comunicar una idea a partir de un set de datos. R base contiene una serie de herramientas bastante poderosas para crear visualizaciones atractivas y eficientes de manera muy flexible. Sin embargo, dentro de esta flexibilidad se puede crear confusión en el lenguaje para crear un gráfico.\nSi bien muchos tipos de visualizaciones en R base son relativamente intuitivos, por ejemplo hist(), barplot(), bowplot(), la cosa se complica cuando se quiere incluir distintas capas o diferenciar grupos (por ejemplo, abline(), par(), etc.)\nPor otro lado, ggplot2 es un motor gráfico basado en la gramática grafica de Wilkinson. Bajo este contexto, un gráfico es una serie de capas (layers) similares a una transparecia, con algo impreso en ellas, que puede ser texto, puntos, lineas, barras, o cualquier otro tipo de representación. La imagen final, cada una de estas capas se colocan una sobre otra.\n\n\n\nImagen adaptada de The Grammar of Graphics\n\n\nAdemás, ggplot2 se desarrolla dentro de la filosofia de Tidyverse por lo que usa una sintaxis mas simple e intuitiva para el usuario.\nTomemos como ejemplo la base de datos de penguins. Si queremos graficar un boxplot con la longitud del pico de los pingüinos Adelie en todas las islas, en R base seria algo como esto:\n\npenguins &lt;- read_csv(\"data/palmer_penguins.csv\") %&gt;% \n  na.omit()\n\npenguins_adeline &lt;- penguins[penguins$species == \"Adelie\", ]\n\npar(mfrow = c(1,3), oma = c(0, 0, 2, 0))\n\nboxplot(bill_length_mm ~ sex, data = penguins_adeline, main= \"isla1\")\nboxplot(bill_length_mm ~ sex, data = penguins_adeline, main = \"isla2\")\nboxplot(bill_length_mm ~ sex, data = penguins_adeline, main = \"isla3\")\nmtext(\"Datos de longitud del culmen\", outer = TRUE)\n\n\n\ndev.off()\n\nnull device \n          1 \n\n\n…mientras que con ggplot podemos usar la siguiente sintaxis:\n\npenguins %&gt;% \n  filter(species == \"Adelie\") %&gt;% \n  ggplot(aes(x = sex, y = bill_length_mm))+\n  geom_boxplot()+\n  facet_wrap(~island)+\n  labs(title = \"Datos de longitud del culmen\")"
  },
  {
    "objectID": "5.visualization_ggplot.html#poniendo-capas-ggplot",
    "href": "5.visualization_ggplot.html#poniendo-capas-ggplot",
    "title": "Visualización de datos con ggplot2",
    "section": "2.1 Poniendo capas: ggplot()",
    "text": "2.1 Poniendo capas: ggplot()\nPara crear un gráfico con ggplot se usa el comando ggplot()\n\nggplot(data = penguins)\n\n\n\n\nAl ejecutar la función, no da error pero no vemos ninguna gráfica. Esto se debe a que no hemos indicado a ggplot cuales son las coordenadas y ni las geometrías que queremos gráficar.\nPara designar los estéticos, definimos el plano usando los datos de la longitud del culmen y la masa corporal ejecutando:\n\nggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g))\n\n\n\n\nEl argumento aes() es sinónimo de estética. ggplot2 considera que el eje x y y de la gráfica es estético, junto con el color, el tamaño, la forma, el relleno, etc. Se puede agregar cualquier estética que se desee dentro del argumento aes(), como por ejemplo indicar los ejes x y y, especificando las variables respectivas del conjunto de datos.\nLa variable en función de la cual el color, tamaño, forma y trazo debe cambiar también se puede especificar aquí mismo. Debes tener en cuenta que la estética especificada aquí será heredada por todas las capas geom() que se agregarán posteriormente.\nSin embargo, aún no vemos ninguna gráfica, ya que para esto es necesario indicar que tipo de geometría (geom()) de gráfica queremos utilizar.\nPara crear un diagrama, por ejemplo, de dispersión es necesario agregarle la geometria geom_point(). Es importante recalcar que cada nueva capa que agreguemos al gráfico se agrega con el símbolo +.\n\nggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g))+\n  geom_point()\n\n\n\n\n\n\n\n\n\n\n\n\nDonde poner los aes?\n\n\n\nLos aes() se pueden definir desde que se inicia la función ggplot()pero estos aes se heredaran al resto de las capas. Por otro lado, se pueden definir los aes dentro de cada geom()\n\nggplot(data = data, aes(x = x, y = y))+\n  geom_point()\n\nes igual que\n\nggplot()+\n  geom_point(data = data, aes(x = x, y = y))"
  },
  {
    "objectID": "5.visualization_ggplot.html#aesthetics",
    "href": "5.visualization_ggplot.html#aesthetics",
    "title": "Visualización de datos con ggplot2",
    "section": "2.2 Aesthetics()",
    "text": "2.2 Aesthetics()\nComo mencionamos, es posible agregar diferentes estéticos a la gráfica para controlar diversos aspectos como color, tamaño, forma, etc. Esto nos permite asignarle un estético a los grupos.\npor ejemplo, podemos asignarle un color diferente a cada especie con el argumento color\n\nggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g, color = species))+\n  geom_point()\n\n\n\n\nY asignarle una forma diferente a por sexo con el argumento shape\n\nggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g, color = species, shape = sex))+\n  geom_point()\n\n\n\n\no cambiar el tamaño con size\n\nggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g, color = species, shape = sex, size = bill_length_mm))+\n  geom_point()\n\n\n\n\n\nggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g, color = species))+\n  geom_point()+\n  geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nggplot(data = penguins)+\n  geom_point(aes(x = bill_length_mm, y = body_mass_g, color = species))+\n  geom_smooth(aes(x = bill_length_mm, y = body_mass_g), method = \"lm\", color = \"grey75\")+\n  geom_smooth(aes(x = bill_length_mm, y = body_mass_g, color = species), method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "5.visualization_ggplot.html#breve-tour-por-las-distintas-geometrias",
    "href": "5.visualization_ggplot.html#breve-tour-por-las-distintas-geometrias",
    "title": "Visualización de datos con ggplot2",
    "section": "2.3 Breve tour por las distintas geometrias",
    "text": "2.3 Breve tour por las distintas geometrias\nLos nombres de las funciones de geometría siguen el patrón: geom_X donde X es el nombre de la geometría. Algunos ejemplos incluyen geom_point, geom_bar y geom_histogram.\nA continuación repasaremos algunas de las geometrías mas comunes:\n\n2.3.1 Visualización de una variable continua\nPara facilitar el tour, vamos a generar un objeto con las coordenadas de la longitud del pico\n\nbase &lt;- ggplot(penguins, aes(x = bill_length_mm, fill = species))\n\n\ngeom_histogram()\n\nbase + \n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\ngeom_density()\n\nbase +\n  geom_density()\n\n\n\n\n\n\ngeom_qqplot()\n\nggplot(penguins, aes(sample = bill_length_mm, color = species)) +\n  geom_qq()\n\n\n\n\n\n\n\n2.3.2 Visualización de variables discretas\n\ngeom_bar() y geom_col()\nLas gráficas de barras son una de las visualizaciones mas comunes. ggplot ofrece dos alternativas dependiendo del formato de los datos que se vayan a graficar. Una descripción mas detallada sobre la diferencia entre ambos se puede encontrar aquí.\nRecordemos en nuestra sesión pasada que podemos contar el número de apariciones de un elemento dentro de un grupo con la función count()\n\npenguins %&gt;% \n  count(species)\n\n# A tibble: 3 × 2\n  species       n\n  &lt;chr&gt;     &lt;int&gt;\n1 Adelie      146\n2 Chinstrap    68\n3 Gentoo      119\n\n\nDe manera análoga, geom_bar() calculará el número de ocurrencias en cada nivel de una variable categórica.\n\nggplot(penguins, aes(x = species))+\n  geom_bar()\n\n\n\n\nPor el contrario, si queremos que gráfique un valor ya establecido en los datos, tenemos que incorporar el parámetro stat = \"identity\".\n\npenguins %&gt;%  \n  count(species) %&gt;%  \nggplot(., aes(x = species, y = n))+\n  geom_bar(stat = \"identity\")\n\n\n\n\nPor otro lado, geom_col() es lo mismo que geom_bar(stat = \"identity\"), por lo que si tus datos contienen groups y el número de apariciones de cada uno de estos, puedes utilizar esta función\n\npenguins %&gt;% \n  count(species) %&gt;% \n  ggplot(.,aes(x = species, y = n))+\n  geom_col()\n\n\n\n\nPodemos incorporar mas variables discretas dentro de los aes() incorporando la variable fill=\n\nggplot(penguins, aes(x = species, fill = sex)) +\n  geom_bar()\n\n\n\n\nPor default, geom_bar() nos arrojará una gráfica de barras apiladas. Si queremos poner cada grupo por separado, incorporamos el parametro position = \"dodge\"\n\nggplot(penguins, aes(x = species, fill = sex)) +\n  geom_bar(position = \"dodge\")\n\n\n\n\nO usar position=\"fill\" para que nos arroje valores proporcionales\n\nggplot(penguins, aes(x = species, fill = sex)) +\n  geom_bar(position = \"fill\")\n\n\n\n\n\n\n\n\n\n\nEjercicio: Star Wars\n\n\n\n\nAbre la tabla starwars.csv que se encuentra en el directorio de databases y utilizando pipes genera los siguientes objetos:\n\nUna gráfico de densidad donde se compare la distribución de los valore sde altura height de los planetas Tatooine y Naboo, excluyendo los androides.\nUna gráfica de barras de los mismas planetas y excluyendo androides donde se muestre la proporción de sexos.\nUna gráfica de barras donde se muestre el número de personajes de cada planeta del filme A New Hope\n\n\n\nver codigo\nstarwars &lt;- read_csv(\"data/starwars.csv\")\n\n#ejercicio e1\nstarwars %&gt;% \n  filter(homeworld %in% c(\"Tatooine\", \"Naboo\")) %&gt;% \n  filter(species != \"droid\") %&gt;% \n  ggplot(., aes(x = height, fill = homeworld))+\n  geom_density()\n\n\n# ejercicio e2\nstarwars %&gt;% \n  filter(homeworld %in% c(\"Tatooine\", \"Naboo\")) %&gt;% \n  filter(species != \"droid\") %&gt;% \n  ggplot(.,aes(x = homeworld, fill = sex))+\n  geom_bar(position = \"fill\")\n\n# ejercicio e3\nstarwars %&gt;% \n  filter(str_detect(films, \"A New Hope\")) %&gt;% \n  ggplot(., aes(x = homeworld)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.3.3 Visualización de una variable discreta + una continua\n\nBoxplot (diagrama de cajas y bigotes)\nUn diagrama de cajas y bigotes, también conocido como boxplot, es una representación gráfica que proporciona una descripción visual de la distribución de un conjunto de datos. Este tipo de gráfico es particularmente útil para resumir la variabilidad y la dispersión de los datos, así como para identificar la presencia de valores atípicos.\nLa caja de un boxplot comienza en el primer cuartil Q1 (25%) y termina en el tercero Q3 (75%). Por lo tanto, la caja representa el 50% de los datos centrales, con una línea que representa la mediana. A cada lado de la caja se dibuja un segmento con los datos más lejanos sin contar los valores atípicos (outliers) del boxplot, que en caso de existir, se representarán con círculos.\n\n\n\nPartes de un boxplot de una distribución normal. Imagen tomada de Byjus.com\n\n\n\nggplot(data = penguins, aes(x = species, y = bill_length_mm, fill = sex))+\n  geom_boxplot()\n\n\n\n\nOtra opción para visualizar la dispersión de los datos es utilizando gráficos de violin. Esto es particularmente útil cuando se tienen muchos datos.\n\nggplot(data = penguins, aes(x = species, y = bill_length_mm, fill = sex))+\n  geom_violin()\n\n\n\n\n\n\ngeom_point() y geom_jitter()\nLa función geom_point() es una función versatil ya que nos permite crear gráficos de dispersión (mas adelante) o para vidualizar la dispersión real de los datos categóricos\n\nggplot(data = penguins, aes(x = species, y = bill_length_mm, color = sex))+\n  geom_point()\n\n\n\n\nEsta visualización es poco útil ya que todos los puntos se traslapan. Para poder separar cada uno de los grupos (sexo) necesitamos incluir el parámetro position = para darle espacio entre cada grupo\n\nggplot(data = penguins, aes(x = species, y = bill_length_mm, color = sex))+\n  geom_point(position = position_dodge(0.2))\n\n\n\n\nEl parámetro posiiton = se puede incluir en cualquier tipo de geoms, no solo en los puntos, y permite ajustar el traslape entre grupos. Tiene varias opciones. Entre las mas útiles que utilizaremos en este curso se encuentra:\n\nposition_dodge(): Esquiva el traslape lado a lado entre objettos\nposition_jitter(): Agrega una dispersión aleatoria en el eje x a los puntos para eviar que se traslape\nposition_jitterdodge(): Agrega de forma simultanea un jitter y dodge a los puntos\nposition_identity(): No ajusta la posición de los puntos\n\nEntonces, podemos incorporar el parámetro position_jitterdodge() para disminuir el traslape entre los puntos entre y dentor de cada grupo\n\nggplot(data = penguins, aes(x = species, y = bill_length_mm, color = sex))+\n  geom_point(position = position_jitterdodge(0.1))\n\n\n\n\n\n\n\n\n\n\n\n\n¿Jitter? 🤷️\n\n\n\nEn dotplots, el jitter se refiere al desplazamiento aleatorio de puntos de datos individuales a lo largo del eje para evitar superposiciones, proporcionando una representación más clara de la distribución de datos.\nDado que el valor es aleatorio, cada que se genere la gráfica, el desplazamiento de cada puto puede variar un poco sobre el eje x, pero su valor real (eje y) no se verá afectado.\n\n\n\n\n\n2.3.4 Visualización de una variable continua + una continua\nEste tipo de visualizaciones nos permite ver la relación entre dos variables continuas. Hay diversos geoms que podemos implementar, pero el más común es nuevamente geom_point().\n\nggplot(data = penguins, aes(x = body_mass_g, y = bill_length_mm, color = sex))+\n  geom_point()\n\n\n\n\n\n\n2.3.5 Visualización de resumenes estadisticos: geom_errorbar()\nMuchas veces queremos mostrar de forma clara y sencilla como se comportan nuestro datos, por lo que podemos mostrar solamente algunos estadisticos básicos, como el promedio y el grado de dispersión de los datos usando ya sea la desviación estandar o el error estandar. Esto lo podemos lograr utilizando funciones como geom_point() en conjunto con barras de dispersión con la función geom_errorbar().\nal igual que otros geoms, geom_errorbar() requiere que indiquemos su posición en el eje x, pero también requiere que indiquemos sus limites superior e inferior sobre el eje y con los parámetros ymax = y ymin =, respectivamente.\nPara esto, primero necesitamos calcular estos estadísticos antes de gráficarlos.\nPor ejemplo, calculemos el promedio y la desviación estándar de la longitud del pico para cada especie de pingüinos, por sexo.\n\npenguins_estat &lt;- penguins %&gt;% \n  group_by(species) %&gt;% \n  summarise(promedio = mean(bill_length_mm, na.rm = TRUE),\n            desvest = sd(bill_length_mm, na.rm = TRUE)) %&gt;% \n  ungroup()\n\nggplot(penguins_estat, aes(x = species, y = promedio))+\n  geom_point() +\n  geom_errorbar(aes(ymin = promedio - desvest, ymax = promedio + desvest))\n\n\n\n\nEn este caso utilizamos un punto para indicar el promedio, pero también podemos utilizar un gráfico de barras.\n\nggplot(penguins_estat, aes(x = species, y = promedio))+\n  geom_col() +\n  geom_errorbar(aes(ymin = promedio - desvest, \n                    ymax = promedio + desvest), \n                width = 0.5)\n\n\n\n\n\n\n\n\n\n\nDesafio pingüinos\n\n\n\nRealiza una gráfica de barras donde se muestre el promedio \\(\\pm\\) desviación estandar de la longitud del pico de cada especie y sexo. Distingue los sexos por el color de relleno de las barras.\nRecuerda que puedes incluir el parámetros position = position_dodge() para separar las barras entre grupos\n\n\nver codigo\npenguins %&gt;% \n  group_by(species, sex) %&gt;% \n  summarise(promedio = mean(bill_length_mm, na.rm = TRUE),\n            desvest = sd(bill_length_mm, na.rm= TRUE), \n            .groups = \"drop\") %&gt;% \n  ggplot(., aes(x = species, y = promedio, fill = sex)) +\n  geom_col(position = position_dodge(), color = \"black\")+\n  geom_errorbar(aes(ymin = promedio - desvest, ymax = promedio + desvest),\n                width = 0.5, position = position_dodge(0.9))\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n\n\n3 Los amigos no permiten que sus amigos hagan gráficas de barras\nMuchas veces al presentar los datos de una investigación nos vamos directamente a mostrar el promedio \\(\\pm\\) desviación estandar o algún otro valor de dispersión pero puede que esto no muestre toda la verdad sobre la distribución de los datos. Como demostración haz el siguiente ejercicio:\n\nAbre la tabla datos_demo.csv que se encuentra en la carpeta de datos\nSin hacer ningún tipo de observación previa, haz una gráfica donde se muestre el promedio \\(\\pm\\) desviación estándar. Para ello, utiliza las funciones group_by() y summarise() que hemos visto anteriormente.\nAhora, utilizando el set de datos completo, gráfica la dispersión de los datos con geom_point() y añade un boxplot con geom_boxplot().\n\n\n\nver codigo\ndemo &lt;- read_csv(\"data/datos_demo.csv\")\n\n\n# promedios\ndemo %&gt;% \n  group_by(grupo) %&gt;% \n  summarise(promedio = mean(valor),\n            desvest = sd(valor)) %&gt;% \n  ggplot(.,aes(x = grupo, y = promedio, fill = grupo))+\n  geom_col()+\n  geom_errorbar(aes(ymin = promedio - desvest, ymax = promedio + desvest),\n                width = 0.3)\n\n# datos completos\ndemo %&gt;% \n  ggplot(.,aes(x = grupo, y = valor, color = grupo))+\n  geom_boxplot()+\n  geom_point(position = position_jitterdodge(0.2))\n\n\n¿Que conclusiones puedes sacar de ambas gráficas?\nEl uso de histogramas, densidades o gráficas de dispersión nos permite hacer un análisis exploratorio de los datos, permitiendo tomar mejores decisiones sobre el tipo de estadisticos o procesamiento que se van a utilizar.\nPuedes encontrar una discusión mas profunda sobra la importancia de la correcta presentación e interpretación de datos en publicaciones científicas aquí."
  },
  {
    "objectID": "6.visualization_ggplot_pt2.html",
    "href": "6.visualization_ggplot_pt2.html",
    "title": "Leccion 5: Visualización con ggplot2; Edición",
    "section": "",
    "text": "En la sección anterior ya habíamos mencionado como el formato de los geoms para distinguir grupos, clases o estructuras:\n\n\n\n\n\n\n\n(a) Color\n\n\n\n\n\n\n\n(b) Forma\n\n\n\n\n\n\n\n\n\n(c) Transparencia\n\n\n\n\n\n\n\n(d) Tamaño\n\n\n\n\n\n\n\n\n\n(e) Relleno\n\n\n\n\n\n\n\n(f) Agrupamiento\n\n\n\n\nFigure 1: Los Aesthetics nos permiten representar diferentes variables en un solo gráfico"
  },
  {
    "objectID": "6.visualization_ggplot_pt2.html#ajuste-manual-global",
    "href": "6.visualization_ggplot_pt2.html#ajuste-manual-global",
    "title": "Leccion 5: Visualización con ggplot2; Edición",
    "section": "2.1 Ajuste manual global",
    "text": "2.1 Ajuste manual global\nDentro de los aes podemos asignar un color diferente a cada grupo, pero también es posible asignar un color arbitrario a todas los geoms. Para esto, tenemos que establecer el color afuera del aes().\npor ejemplo\n\nlibrary(tidyverse)\n\n#abrir la base de datos de pingüinos\npenguins &lt;- read_csv(\"data/palmer_penguins.csv\") |&gt; \n  na.omit()\n\n\nggplot(data = penguins)+\n  geom_point(aes(x = bill_length_mm, y = body_mass_g), \n             color = \"darkblue\")\n\n\n\n\nDe la misma manera, podemos ajustar la transparencia (alpha) o la forma (shape) para todos los puntos u otro geom al establecer este parámetro afuera del aes()\n\nggplot(data = penguins)+\n  geom_point(aes(x = bill_length_mm, y = body_mass_g), \n             shape = 15)\n\n\n\n\n\n\n\n\n\n\nEstilos de puntos disponibles\n\n\n\nA continuación se muestran los tipos de figuras disponibles para gráficos de puntos (p. ej. geom_point(). Para modificar el punto se usa el parametro shape = nn)\n\n\n\n\n\n\n\n\n\n\nNota que los puntos del 21 al 25 son simbolos abiertos por lo que pueden ser rellenados por un color (fill)."
  },
  {
    "objectID": "6.visualization_ggplot_pt2.html#ajuste-manual-por-grupo",
    "href": "6.visualization_ggplot_pt2.html#ajuste-manual-por-grupo",
    "title": "Leccion 5: Visualización con ggplot2; Edición",
    "section": "2.2 Ajuste manual por grupo",
    "text": "2.2 Ajuste manual por grupo\nEn ejemplos anteriores, donde usamos el argumento color dentro de los _aes()_ ggplot2 asigna una paleta de colores default. Si queremos asignar colores específicos, podemos añadirlos manualmente usando las funciones:\n\nscale_color_manual()\nscale_fill_manual()\n\n\npp &lt;- ggplot(penguins)+\n  geom_point(aes(x = bill_length_mm, y = body_mass_g, color = species))\n\n# ajustamos el color con scale_color_manual()\npp +\n  scale_color_manual(values = c(\"grey55\", \"orange\", \"lightblue\"))\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nDado que se requiere un vector con los colores que se deseen utilizar, es posible hacer un objeto con un vector de colores y utilizarlo de forma recurrente en distintas figuras. Por ejemplo\n\n# crear un vector con colores\ncolores &lt;- c(\"grey55\", \"orange\", \"lightblue\")\n\n# incluir el vector dentra de la función\npp +\n  scale_color_manual(values = colores)"
  },
  {
    "objectID": "6.visualization_ggplot_pt2.html#ajuste-manual-de-gradientes",
    "href": "6.visualization_ggplot_pt2.html#ajuste-manual-de-gradientes",
    "title": "Leccion 5: Visualización con ggplot2; Edición",
    "section": "2.3 Ajuste manual de gradientes",
    "text": "2.3 Ajuste manual de gradientes\nTambién es posible hacer ajuste manual de gradientes de color utilizando la función scale_color_gradient()\nPor ejemplo, podemos gráficar la relación entre la longitud del pico y el peso corporal, con un gradiente de color por el peso corporal\n\npp2 &lt;- ggplot(penguins)+\n  geom_point(aes(x = bill_length_mm, y = body_mass_g, \n                 color = body_mass_g))\npp2\n\n\n\n# ajustar manualmente el gradiente\npp2 +\n  scale_color_gradient(low = \"blue\", high = \"red\")"
  },
  {
    "objectID": "6.visualization_ggplot_pt2.html#seleccionar-una-nueva-paleta-de-colores",
    "href": "6.visualization_ggplot_pt2.html#seleccionar-una-nueva-paleta-de-colores",
    "title": "Leccion 5: Visualización con ggplot2; Edición",
    "section": "2.4 Seleccionar una nueva paleta de colores",
    "text": "2.4 Seleccionar una nueva paleta de colores\nEscoger los colores adecuados para una figura es mas complejo de lo que pudiera parecer y hay varios aspectos que se deben considerar. Puedes encontrar algunas recomendaciones aquí.\nAfortunadamente, es posible encontrar diversas paletas prediseñadas, ya sea para datos categóricos, divergentes o secuenciales. Entre las mas comunes están los paquetes:\n\nRColorBrewer\nViridis\n\n\n2.4.1 RColorBrewer\n\n\n\n\n\nPaleta de colores de RColorBrewer\n\n\n\n\n\n\n2.4.2 viridis\n\nHay varias opciones de como usar estas paletas de colores:\n\nGenerar un vector con los colores de una paleta en especifico. Esto es mas útil para variables discretas\n\n\nlibrary(RColorBrewer)\nlibrary(viridis)\n\npaleta_brewer &lt;- brewer.pal(name = \"Dark2\", n = 3)\npaleta_virids &lt;- viridis(n = 3)\n\n# usar paleta de RColorBrewer\npp +\n  scale_color_manual(values = paleta_brewer)\n\n\n\n# Usar paletta de Viridis\npp + \n  scale_color_manual(values = paleta_virids)\n\n\n\n\n\nUtilizar alguna de las funciones de cada paquete dentro de la figura. Por ejemplo scale_color_brewer() o scale_color_viridids()\n\n\n# usar RColorBrewer\npp +\n  scale_color_brewer(palette = \"Dark2\")\n\n\n\n# usar Viridis\npp +\n  scale_color_viridis(discrete = TRUE,option = \"viridis\")\n\n\n\n\nPara gradientes\n\npp2 +\n  scale_color_distiller(palette = 5)\n\n\n\npp2 +\n  scale_colour_viridis_c(option = \"magma\")\n\n\n\n\n\n\n\n\n\n\n\n\n¿Quieres mas colores?\n\n\n\nExisten numerosas opciones en línea para escoger colores y paletas de colores. Una herramienta básica es el Selector de color de Google que te permite generar el código HEX de un color en específico, o la herramienta R Color Palettes que te permite generar un vector con una paleta de colores.\n\n\n\n\n\n\n\n\nEjercicio: Colores y formas\n\n\n\n\nAbre la tabla de pokemon que se encuentra en la carpeta de data y genera:\n\nUn gráfico de dispersión de los valores de ataque (attack) y defensa (defense) cambiando el color y la forma de acuerdo a si es legendario o no. Elige los colores y formas que gustes.\nCalcula el promedio de porcentaje de machos (percentage_male) por tipo de pokemon (type1) y genera una gráfica de barras con los valores promedio y con el colores de las barras en función del valor promedio. Cambia la paleta de colores a una de tu preferencia\n\n\n\nver codigo\npokemon &lt;- read_csv(\"data/pokemon.csv\")\n\n# Ejercicio e1\npokemon %&gt;% \n  janitor::clean_names() %&gt;% \n  mutate(generation = factor(generation)) %&gt;% \n  mutate(is_legendary = factor(is_legendary)) %&gt;% \n  ggplot(aes(x = attack, y = defense, \n             color = is_legendary, \n             shape = is_legendary)) +\n  geom_point()+\n  geom_smooth(method = \"lm\")+\n  scale_color_brewer(palette = \"Set1\") +\n  scale_shape_manual(values = c(1,15))\n\n\n# Ejercicio e2\npokemon %&gt;% \n  group_by(type1) %&gt;% \n  summarise(mean_male_pct = mean(percentage_male, na.rm = TRUE)) %&gt;% \n  ggplot(aes(x = type1, y = mean_male_pct, fill = mean_male_pct))+\n  geom_col()+\n  scale_fill_viridis_c()"
  },
  {
    "objectID": "6.visualization_ggplot_pt2.html#facet_wrap",
    "href": "6.visualization_ggplot_pt2.html#facet_wrap",
    "title": "Leccion 5: Visualización con ggplot2; Edición",
    "section": "3.1 facet_wrap()",
    "text": "3.1 facet_wrap()\nfacet_wrap() genera un listón de paneles de una variable determinada y las envuelve en un orden bidimensional. Es útil cuando se tiene una sola variable con varios niveles.\nVamos a utilizar nuestro objeto ppque generamos mas arriba y vamos a separar los registros de los pingüinos por sexo:\n\npp + \n  facet_wrap(~ sex)\n\n\n\n\no por isla\n\npp + \n  facet_wrap(~ island)\n\n\n\n\nPodemos controlar la orientación de los paneles con ncol y nrow\n\npp +\n  facet_wrap(~ island, ncol = 1)"
  },
  {
    "objectID": "6.visualization_ggplot_pt2.html#facet_grid",
    "href": "6.visualization_ggplot_pt2.html#facet_grid",
    "title": "Leccion 5: Visualización con ggplot2; Edición",
    "section": "3.2 facet_grid()",
    "text": "3.2 facet_grid()\nfacet_grid() despliega el gráfico en una gradilla de dos dimensiones definido por la formula x ~ y, en donde x se despliega en columnas y y en las filas. Usualmente se recomienda colocar la variable con el mayor número de niveles en las columnas, aunque esto dependerá del área de trazado.\nPor ejemplo, usando nuetro objeto pp podemos graficar la relación de longitud de pico y peso corporal por sexo y por isla.\n\npp +\n  facet_grid(sex ~ island)"
  },
  {
    "objectID": "6.visualization_ggplot_pt2.html#ajustar-las-escalas",
    "href": "6.visualization_ggplot_pt2.html#ajustar-las-escalas",
    "title": "Leccion 5: Visualización con ggplot2; Edición",
    "section": "3.3 Ajustar las escalas",
    "text": "3.3 Ajustar las escalas\nTanto para facet_wrap() como facet_grid()es posible ajustar las escalas en los ejes de manera que sea el mismo para todos los paneles (fixed) o que pueda variar entre los paneles (free) utilizando los parámetros:\n\nscales= \"fixed\": Las escalas en el eje x y y esta fijas en todos los paneles.\nscales = \"free_x\": La escala en el eje x es variable y fija en el eje y.\nscales = \"free_y\": La escala en el eje y es variable y fija en el eje x.\nscales = \"free\": Las escalas de ambos ejes son variables\n\n\npp + \n  facet_wrap(~ island, scales = \"free_y\")\n\n\n\n\n\npp + \n  facet_wrap(~ island, scale = \"free_x\")\n\n\n\n\n\npp + \n  facet_wrap(~ island, scales = \"fixed\")\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nLas escalas fijas facilitan visualizar patrones entre los paneles; las escalas variables facilitan ver patrones dentro de cada panel\n\n\n\n\n\n\n\n\nDesafio paneles\n\n\n\n\nRecrea la siguiente figura:\n\n\nver codigo\npenguins_noisland &lt;- penguins %&gt;% \n  select(-island)\n\nggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g))+\n  geom_point(data = penguins_noisland, color = \"grey75\")+\n  geom_point(aes(color = island))+\n  facet_wrap(~island) \n\n\n\n\n\n\nTip1: Tienes que utilizar dos geom_points(); una con la base de datos original y una con datos que no incluya la variable que vas a separar en paneles\nTip2: Presta atención en donde pones el parametro color para cada geom."
  },
  {
    "objectID": "6.visualization_ggplot_pt2.html#themes-prediseñados",
    "href": "6.visualization_ggplot_pt2.html#themes-prediseñados",
    "title": "Leccion 5: Visualización con ggplot2; Edición",
    "section": "4.1 Themes prediseñados",
    "text": "4.1 Themes prediseñados\nggplot2 viene con diversos temas (themes) prediseñados con diferencias en cuanto a los colores de fondo, el uso de retícula, borde exterior, etc.\nPara usar cualquiera de estos temas en nuestras gráfica simplemente agregamos la capa + theme_xx().\nAlgunas de las opciones son las siguientes:\n\n\n\n\n\n\n\n(a) grey\n\n\n\n\n\n\n\n(b) classic\n\n\n\n\n\n\n\n\n\n(c) bw\n\n\n\n\n\n\n\n(d) light\n\n\n\n\n\n\n\n\n\n(e) minimal\n\n\n\n\n\n\n\n(f) void\n\n\n\n\nFigure 2: Algunos ejemplos de los diferentes themes prediseñados"
  },
  {
    "objectID": "6.visualization_ggplot_pt2.html#modificar-componentes-del-tema",
    "href": "6.visualization_ggplot_pt2.html#modificar-componentes-del-tema",
    "title": "Leccion 5: Visualización con ggplot2; Edición",
    "section": "4.2 Modificar componentes del tema",
    "text": "4.2 Modificar componentes del tema\nSi quieres modificar un componente del tema, puedes usar la función theme() con una estructura como se muestra:\nplot + theme(element.name = element.function())\nEste cambio puntual de un elemento anulará los ajustes preestablecido en algunos de los themes que vimos anteriormente.\nPor ejemplo, si queremos utilizar un theme_minimal() pero quieres eliminar los grids secundarios, podemos utilizar el siguiente codigo:\n\npp + \n  theme_minimal()+\n  theme(panel.grid.minor = element_blank())\n\n\n\n\nO si queremos cambiar la posición de la legenda, podemos utilizar el parametro legend_position=\n\npp +\n  theme_minimal()+\n  theme(panel.grid.minor = element_blank(),\n        legend.position = \"top\")\n\n\n\n\nHay cuatro tipos básicos de funciones de elementos incorporados: texto, líneas, rectángulos y en blanco (blank). Cada función de elemento tiene un conjunto de parámetros que controlan la apariencia:\n\nelement_text() controla el tamaño, color, tipo de fuente y posición de los elementos de texto, como titulos, ejes, leyendas, etc.\n\n\npp + \n  theme(axis.title = element_text(size = 16, color = \"red\"))\n\n\n\n\n\nelement_line() controla el estilo y tamaño de las líneas dentro del área de trazado\n\n\npp +\n  theme(panel.grid = element_line(linetype = \"dashed\", color = \"red\"))\n\n\n\n\n\n|element_rect()dibuja y controla el estilo de rectángulos, principalmente para colores de fondo.\n\n\npp +\n  theme(panel.background = element_rect(fill = \"lightblue\", color = \"red\"))\n\n\n\n\n\nelement_blank()dibuja nada! Sin embargo, es un elemento que se utiliza muy a menudo para suprimir algún elemento no deseado, como por ejemplo los grids o marcas del eje.\n\n\npp +\n  theme(panel.grid.minor = element_blank())\n\n\n\n\nOtro elemento importante es el control de la posición de la leyenda. Por default, ggplot2 coloca la leyenda a la derecha del gráfico, pero podemos ajustar la posición con el parámetro legend.position = nn donde podemos usar los argumentos \"left\", \"right\", \"top\", \"bottom\" y \"none\".\n\npp +\n  theme(legend.position = \"top\")\npp + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\nRealmente existen muchos elementos que podemos controlar dentro de la función theme() que nos llevaria todo el día revisarlo, pero con los argumentos que vimos anteriormente puedes hacer los principales ajustes de desees. En la siguiente imagen se muestran los principales elementos que puedes modificar:\n\n\n\nEleméntos gráficos que se pueden modificar dentro de la función theme()"
  },
  {
    "objectID": "7.ggplot_sin_codigo.html",
    "href": "7.ggplot_sin_codigo.html",
    "title": "Lección 7: ggplot2 sin codigo",
    "section": "",
    "text": "Como hemos visto hasta este punto, ggplot2 es una poderosa herramienta para realizar gráficos de alta calidad y un alto grado de personalización. Esto último conlleva al problema de que puede resultar complicado escribir la grpamatica necesario para gráficar lo que deseamos, o incluso que lleve tiempo realizar un gráfico relativametne sencillo.\nAfortunadamente, existen algunas alternativas dentro de R que nos ´permiten generar gráficos con ggplot2 pero usando una interfaz gráfica."
  },
  {
    "objectID": "7.ggplot_sin_codigo.html#instalación.",
    "href": "7.ggplot_sin_codigo.html#instalación.",
    "title": "Lección 7: ggplot2 sin codigo",
    "section": "1.1 Instalación.",
    "text": "1.1 Instalación.\nEl addin de esquisse se instala como cualquier otro paquete usando la función install.package()\n\ninstall.packages(\"esquisse\")"
  },
  {
    "objectID": "7.ggplot_sin_codigo.html#esquisse-addin",
    "href": "7.ggplot_sin_codigo.html#esquisse-addin",
    "title": "Lección 7: ggplot2 sin codigo",
    "section": "1.2 esquisse addin",
    "text": "1.2 esquisse addin\nUna vez instalado, hay dos formas para correr esquisse:\n\nDesde la línea de comando usando la función esquisser()\n\n\nlibrary(esquisse)\nesquisser()\n\nlibrary(ggplot2)\n\n\nUtilizando las opciones de addins:\n\n\n\n\nAlt Text\n\n\n\n\n\n\n\n\nNote\n\n\n\nSi no tienes nada en tu ambiente, esquisser() abrirá un panel donde puedes seleccionar la base de datos a partir de un archivo, de un enlace, una hoja de google sheet o incluso copiar y pegar desde otro archivo.\nSi ya tienes datos en tu ambiente, puedes abrirlos directamente con esquisser de la siguiente forma:\n\nesquisser(penguins)\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nSi tienes problemas con la ventana de esquisser en el panel, puedes abrirla en una ventana del explorador usando el parámetro viewer = \"browser\"\n\nesquisser(viewer = \"browser\")\n\n\n\nUna vez seleccionados los datos, podemos proceder a arrastrar cada uno de las variables a los distintos aes. Dependiendo del tipo de datos, esquisser nos sugerirá una geometría (geom) adecuada para los datos o podemos seleccionar manualmente el tipo de gráfico.\n\n\n\nAlt Text\n\n\n\n\n\n\n\n\nDesafio: Etch a sketch\n\n\n\n\nRecrea el siguiente gráfico usando esquisser"
  },
  {
    "objectID": "7.ggplot_sin_codigo.html#instalación-de-ggplotgui-desde-el-ambiente-de-r",
    "href": "7.ggplot_sin_codigo.html#instalación-de-ggplotgui-desde-el-ambiente-de-r",
    "title": "Lección 7: ggplot2 sin codigo",
    "section": "2.1 Instalación de ggplotgui desde el ambiente de R",
    "text": "2.1 Instalación de ggplotgui desde el ambiente de R\n\n\n\n\n\n\nNote\n\n\n\nEs necesario tener instalada la libreria “devtools”\n\n\n\ninstall.packages(\"devtools\")\ndevtools::install_github(\"gertstulp/ggplotgui\")\nlibrary(\"ggplotgui\")\n\nUna vez instalado, corremos la función:\n\nggplot_shiny()\nggplot_shiny(pokemon)\n\nEn línea, se puede usar la herramienta en el siguiente enlace:\nhttps://shiny.gmw.rug.nl/ggplotgui/"
  },
  {
    "objectID": "7.ggplot_sin_codigo.html#instalación",
    "href": "7.ggplot_sin_codigo.html#instalación",
    "title": "Lección 7: ggplot2 sin codigo",
    "section": "3.1 Instalación",
    "text": "3.1 Instalación\nEste paquete se encuentra disponible en su versión mas estable en CRAN:\n\ninstall.packages(\"ggThemeAssist\")\n\nUna vez instalado, aparecera dentro de la lista de addins de RStudio"
  },
  {
    "objectID": "7.ggplot_sin_codigo.html#uso",
    "href": "7.ggplot_sin_codigo.html#uso",
    "title": "Lección 7: ggplot2 sin codigo",
    "section": "3.2 Uso",
    "text": "3.2 Uso\nUna vez instalado, para usarlo es necesario seleccionar un objeto ggplot que ya se haya generado y posteriormente abrir el addin desde el panel de RStudio."
  }
]