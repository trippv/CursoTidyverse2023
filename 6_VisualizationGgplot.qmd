---
title: "Visualizaci√≥n de datos con ggplot2"
author: "Miguel A. Tripp Valdez"
editor_options: 
  chunk_output_type: console
---

::: callout-objetivos
### üéìObjetivos

Al final de esta lecci√≥n ser√°s capaz de:

-   Utilizar `ggplot2` para gr√°ficar variables cualitativas y cuantitativas.
-   Reconocer los distintos elementos que componen un gr√°fico de `ggplot2`.
-   Utilizar distintos tipos de geometr√≠as (*geoms*) de acuerdo al tipo de variable.
:::

# Introducci√≥n

```{r}
#| echo: false
#| warning: false
#| message: false

library(tidyverse)
```

![](img/Horst_functions/ggplot.png){fig-align="center" width="472"}

La visualizaci√≥n es uno de los aspectos mas importantes para comunicar una idea a partir de un set de datos. R base contiene una serie de herramientas bastante poderosas para crear visualizaciones atractivas y eficientes de manera muy flexible. Sin embargo, dentro de esta flexibilidad se puede crear confusi√≥n en el lenguaje para crear un gr√°fico.

Si bien muchos tipos de visualizaciones en R base son relativamente intuitivos, por ejemplo `hist()`, `barplot()`, `boxplot()`, la cosa se complica cuando se quiere incluir distintas capas o diferenciar grupos (por ejemplo, `abline()`, `par()`, etc.)

Por otro lado, ggplot2 es un motor gr√°fico basado en la gram√°tica grafica de Wilkinson. Bajo este contexto, un gr√°fico es una serie de capas (layers) similares a una transparecia, con algo impreso en ellas, que puede ser texto, puntos, lineas, barras, o cualquier otro tipo de representaci√≥n. La imagen final, cada una de estas capas se colocan una sobre otra.

![Imagen adaptada de The Grammar of Graphics](img/gglayers.png){fig-align="center" width="589"}

Adem√°s, ggplot2 se desarrolla dentro de la filosofia de **Tidyverse** por lo que usa una sintaxis mas simple e intuitiva para el usuario.

Tomemos como ejemplo la base de datos de `penguins`. Si queremos graficar un boxplot con la longitud del pico de los ping√ºinos `Adelie` en todas las islas, en R base seria algo como esto:

```{r r_base_plot}
#| message: false
#| warning: false

penguins <- read_csv("data/palmer_penguins.csv") %>% 
  na.omit()

penguins_adeline <- penguins[penguins$species == "Adelie", ]

par(mfrow = c(1,3), oma = c(0, 0, 2, 0))

boxplot(bill_length_mm ~ sex, data = penguins_adeline, main= "isla1")
boxplot(bill_length_mm ~ sex, data = penguins_adeline, main = "isla2")
boxplot(bill_length_mm ~ sex, data = penguins_adeline, main = "isla3")
mtext("Datos de longitud del culmen", outer = TRUE)

dev.off()

```

...mientras que con ggplot podemos usar la siguiente sintaxis:

```{r ggplot_plot}
penguins %>% 
  filter(species == "Adelie") %>% 
  ggplot(aes(x = sex, y = bill_length_mm))+
  geom_boxplot()+
  facet_wrap(~island)+
  labs(title = "Datos de longitud del culmen")
```

# Gram√°tica de las gr√°ficas; geoms y aesthetics

Como se mencion√≥ anteriormente, `ggplot2()` se basa en la gram√°tica de gr√°ficas la cual consiste en una serie de capas que se superponen entre ellas, por lo que podemos construir los gr√°ficos paso a paso:

![](img/Layers_ggplot.png){fig-align="center" width="514"}

Dentro de estas capas, algunas de ellas son **necesarias** mientras que otras son opcionales

![](img/ggplot_basics.png){fig-align="center" width="505"}

Los elementos **necesarios** para realizar un gr√°fico con ggplot son los siguientes:

-   **data**:
    -   un data.frame o tibble que contiene los datos que se quieren visualizar. Este tiene que estar en formato **tidy**
-   **Aestetics** (*aes*): Lista de relaci√≥n entre las variables
    -   `x`, `y`: Variables en el eje x y y
    -   `color`: Color de las geometr√≠as de acuerdo a los datos
    -   `fill`: Color de relleno de las geometr√≠as
    -   `group`: A que grupo corresponde cada geometr√≠a
    -   `shape`: Figura utilizada para cada punto
    -   `linetype`: Tipo de l√≠nea
    -   `size`: Tama√±o de la geometr√≠a
    -   `alpha`: valor de transparencia de la geometr√≠a
-   **Objetos geom√©tricos** (*geom*; determina el tipo de gr√°fico) \_ `geom_point()`: Gr√°fico de dispersi√≥n
    -   `geom_line()`: L√≠neas conectando puntos por incrementos en el valor de x
    -   `geom_path()`: L√≠neas conectando puntos in una secuencia de aparici√≥n
    -   `geom_boxplot()`: gr√°fico de cajas y bigotes para variables categoricas
    -   `geom_bar()`: Gr√°fica de barras para variables categoricas
    -   `geom_histogram()`: Histograma para valores de x continuos
    -   `geom_smooth()`: L√≠eneas de regresi√≥n o correlaci√≥n entre variables

## Poniendo capas: ggplot()

Para empezar a hacer gr√°ficos, vamos a utilizar la base de datos de los ping√ºnios (*penguins*) que ya hemos utilizado anteriormente. Para crear un gr√°fico con ggplot se usa el comando `ggplot()`

Para esto, utilizaremos la base de datos de `penguins` que ya hemos utilizado anteriormente.

```{r}
#| warning: false
#| message: false


# cargar Tidyverse e importar los datos
library(tidyverse)

penguins <- read_csv("data/palmer_penguins.csv") %>% 
  na.omit()


```

```{r}
ggplot(data = penguins)
```

Al ejecutar la funci√≥n, no se genera ning√∫n error pero tampoco vemos ninguna gr√°fica. Esto se debe a que no hemos indicado a ggplot cuales son las coordenadas y ni las geometr√≠as que queremos graficar.

Para designar los est√©ticos, definimos el plano usando los datos de la longitud del culmen y la masa corporal ejecutando:

```{r}
ggplot(data = penguins, 
       mapping = aes(x = bill_length_mm, y = body_mass_g))
```

El argumento `aes()` es sin√≥nimo de est√©tica. ggplot2 considera que el eje *x* y *y* de la gr√°fica es est√©tico, junto con el color, el tama√±o, la forma, el relleno, etc. Se puede agregar cualquier est√©tica que se desee dentro del argumento `aes()`, como por ejemplo indicar los ejes *x* y *y*, especificando las variables respectivas del conjunto de datos.

La variable en funci√≥n de la cual el color, tama√±o, forma y trazo debe cambiar tambi√©n se puede especificar aqu√≠ mismo. Debes tener en cuenta que la est√©tica especificada aqu√≠ ser√° heredada por todas las capas `geom()` que se agregar√°n posteriormente.

Sin embargo, a√∫n no vemos ninguna gr√°fica, ya que para esto es necesario indicar que tipo de geometr√≠a (`geom()`) de gr√°fica queremos utilizar.

Para crear un diagrama, por ejemplo, de dispersi√≥n es necesario agregarle la geometria `geom_point()`. Es importante recalcar que cada nueva capa que agreguemos al gr√°fico se agrega con el s√≠mbolo `+`.

```{r}
ggplot(data = penguins, 
       mapping = aes(x = bill_length_mm, y = body_mass_g))+
  geom_point()
```

## Aesthetics()

Como mencionamos, es posible agregar diferentes est√©ticos a la gr√°fica para controlar diversos aspectos como color, tama√±o, forma, etc. Esto nos permite asignarle un est√©tico a los grupos.

por ejemplo, podemos asignarle un color diferente a cada especie con el argumento color

```{r}
ggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g, color = species))+
  geom_point()
```

En resumen, hasta la forma en que hemos *"mapeado"* nuestros datos al gr√°fico es:

-   `bill_length_mm` en el eje x
-   `body_mass_g` en el eje y
-   `species` como color de los puntos

Arriba ya hemos mencionado los tipos de *aesthetics* que podemos emplear en nuestra gr√°fica que puede ser:

-   `x`, `y`: Variables en el eje x y y
-   `color`: Color de las geometr√≠as de acuerdo a los datos
-   `fill`: Color de relleno de las geometr√≠as
-   `group`: A que grupo corresponde cada geometr√≠a
-   `shape`: Figura utilizada para cada punto
-   `linetype`: Tipo de l√≠nea
-   `size`: Tama√±o de la geometr√≠a
-   `alpha`: valor de transparencia de la geometr√≠a

De esta forma, podemos mapear mas variables utilizando distintos *aesthetics*. Por ejemplo, podemos distinguir el sexo de los ping√ºinos con diferentes formas usando *shape*

```{r}
ggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g, color = species, shape = sex))+
  geom_point()
```

o cambiar el tama√±o con *size*

```{r}
ggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g, color = species, shape = sex, size = bill_length_mm))+
  geom_point()
```

::: {.callout-tip icon="true"}
# Donde poner los aes?

Los *aes()* se pueden definir desde que se inicia la funci√≥n `ggplot()`pero estos aes se heredaran al resto de las capas. Por otro lado, se pueden definir los aes dentro de cada `geom()`

```{r tipi}
#| eval: false
ggplot(data = data, aes(x = x, y = y))+
  geom_point()
```

es igual que

```{r tipii}
#| eval: false
ggplot()+
  geom_point(data = data, aes(x = x, y = y))
```
:::

Dependiendo de lo que queramos comunicar con nuestra gr√°fica, podemos definir los *aesthetics* de forma global o espec√≠fico para cada geom. Por ejemplo:

```{r}
ggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g, color = species))+
  geom_point()+
  geom_smooth()
```

```{r}
ggplot(data = penguins)+
  geom_point(aes(x = bill_length_mm, y = body_mass_g, color = species))+
  geom_smooth(aes(x = bill_length_mm, y = body_mass_g))
```

### Diferencia entre aes() y par√°metros

Es importante distinguir entre los par√°metros que se definen dentro de `aes()` y los que se definen fuera de este. Los par√°metros dentro de `aes()` est√°n mapeando una variable del conjunto de datos a un est√©tico, mientras que los par√°metros fuera de `aes()` est√°n definiendo un valor fijo para ese est√©tico.

Por ejemplo, observa que pasa cuando definimos el color dentro y fuera de `aes()` en al siguiente gr√°fica:

```{r}
ggplot(data = penguins, aes(x = bill_length_mm,
                     y = bill_depth_mm,
                     color = "blue")) +
    geom_point()
```

Entonces, ¬øpor qu√© los puntos se ven rojos? ¬øNo deber√≠a ser azul?

Esto se debe a la distinci√≥n entre mapeo y configuraci√≥n de un est√©tico. Cuando definimos el color dentro de `aes()`, estamos mapeando el color a una variable del conjunto de datos, en este caso, a un valor constante "blue". Sin embargo, al no haber una columna llamada "blue" en el conjunto de datos, ggplot2 asigna un color por defecto (rojo) a los puntos.

Para hacer que los puntos sean azules, debemos definir el color fuera de `aes()` como un par√°metro:

```{r}
ggplot(data = penguins, aes(x = bill_length_mm,
                     y = bill_depth_mm)) +
    geom_point(color = "blue")
```

:::: {.callout-caution icon="false"}
# **Ejercicio: Un geom_point() es un geom_point() es un geom_point()**

::: column-margin
![](img/penguin_group.jpg){fig-align="center" width="500"}
:::

Utilizando tus conocimientos previos, crea un gr√°fico de dispersi√≥n con la base de datos de `penguins` donde se muestre la longitud del pico en el eje x y la profundidad del pico en el eje y. Utiliza el color para distinguir las especies.

Ademas, agrega un punto con el valor promedio de la longitud y profundidad del pico de cada especie en color gris.

```{r}
#| include: true
#| code-fold: true
#| code-summary: "ver codigo"
#| eval: true


#make a dataframe with mean values of bill_depth_mm and bill_length_mm
promedios <- penguins %>% 
  group_by(species) %>% 
  summarise(mean_bill_length = mean(bill_length_mm, na.rm = TRUE),
            mean_bill_depth = mean(bill_depth_mm, na.rm = TRUE))


ggplot()+
  geom_point(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) +
  geom_point(data = promedios, aes(x = mean_bill_length, y = mean_bill_depth), size = 5, color = "grey") 

```
::::

## Breve tour por las distintas geometrias

Los nombres de las funciones de geometr√≠a siguen el patr√≥n: *geom_X* donde *X* es el nombre de la geometr√≠a. Algunos ejemplos incluyen geom_point, geom_bar y geom_histogram.

A continuaci√≥n repasaremos algunas de las geometr√≠as mas comunes:

### Variables continuas

Para facilitar el tour, vamos a generar un objeto con las coordenadas de la longitud del pico distinguiendo en diferente color de relle

```{r}
base <- ggplot(penguins, aes(x = bill_length_mm, fill = species))
```

Los histogramas y los poligonos de frecuencia son dos formas comunes de visualizar la distribuci√≥n de una variable continua. Tanto los histogramas como lo pol√≠gonos de frecuencia trabajan de la misma forma: dividen el rango de valores de la variable en intervalos (o "bins") y cuentan cu√°ntos valores caen en cada intervalo. La diferencia principal entre ambos es que los histogramas muestran estos conteos como barras, mientras que las densidades representan la distribuci√≥n como una curva suave.

Es posible controlar el ancho de los `bins` con el par√°metro `binwidth =` dentro de `geom_histogram()`

#### geom_histogram()

```{r}
base + 
  geom_histogram()
```

#### geom_density()

El gr√°fico de densidad genera una estimaci√≥n de la densidad de probabilidad de una variable num√©rica. Es b√°sicamente una versi√≥n suavizada de un histograma: en lugar de mostrar barras por intervalos, dibuja una curva continua que representa d√≥nde se concentran m√°s los valores. Internamente usa el m√©todo KDE (Kernel Density Estimation) para suavizar la distribuci√≥n.

```{r}
base +
  geom_density()
```

#### geom_qqplot()

Un gr√°fico Q-Q (Quantile-Quantile) compara la distribuci√≥n de una variable con una distribuci√≥n te√≥rica, como la normal. En un gr√°fico Q-Q, los cuantiles de la variable se trazan contra los cuantiles de la distribuci√≥n te√≥rica. Si los puntos siguen aproximadamente una l√≠nea recta, indica que la variable sigue esa distribuci√≥n.

```{r}
ggplot(penguins, aes(sample = bill_length_mm, color = species)) +
  geom_qq()+
  geom_qq_line()
```

### Variables discretas

#### geom_bar() y geom_col()

Las gr√°ficas de barras son una de las visualizaciones mas comunes. ggplot ofrece dos alternativas dependiendo del formato de los datos que se vayan a graficar. Una descripci√≥n mas detallada sobre la diferencia entre ambos se puede encontrar [aqu√≠](https://r-charts.com/ranking/bar-plot-ggplot2/){target="_blank"}.

Recordemos en nuestra sesi√≥n pasada que podemos contar el n√∫mero de apariciones de un elemento dentro de un grupo con la funci√≥n `count()`

```{r}
penguins %>% 
  count(species)
```

De manera an√°loga, `geom_bar()` calcular√° el n√∫mero de ocurrencias en cada nivel de una variable categ√≥rica.

```{r}
ggplot(penguins, aes(x = species))+
  geom_bar()
```

Por el contrario, si queremos que muestre un valor ya establecido en los datos, tenemos que incorporar el par√°metro `stat = "identity"`.

```{r}
penguins %>%  
  count(species) %>%  
ggplot(aes(x = species, y = n))+
  geom_bar(stat = "identity")
```

Por otro lado, `geom_col()` es lo mismo que `geom_bar(stat = "identity")`, por lo que si tus datos contienen groupos y el n√∫mero de apariciones de cada uno de estos, puedes utilizar esta funci√≥n

```{r}
penguins %>% 
  count(species) %>% 
  ggplot(.,aes(x = species, y = n))+
  geom_col()
```

Podemos incorporar mas variables discretas dentro de los *aes()* incorporando la variable `fill=`

```{r}
ggplot(penguins, aes(x = species)) +
  geom_bar(aes(fill = sex))
```

Por default, `geom_bar()` nos arrojar√° una gr√°fica de barras apiladas. Si queremos poner cada grupo por separado, incorporamos el parametro `position = "dodge"`

```{r}
ggplot(penguins, aes(x = species)) +
  geom_bar(aes(fill = sex), position = "dodge")
```

O usar `position="fill"` para que nos arroje valores proporcionales

```{r}
ggplot(penguins, aes(x = species, fill = sex)) +
  geom_bar(position = "fill")
```

:::: {.callout-caution icon="false"}
# Ejercicio: Star Wars

::: column-margin
![](img/starwar_coding.jpeg){fig-align="center" width="316"}
:::

Abre la tabla `starwars.csv` que se encuentra en el directorio de *databases* y utilizando pipes genera los siguientes objetos:

1.  Una gr√°fico de densidad donde se compare la distribuci√≥n de los valore de altura `height` de los planetas **Tatooine** y **Naboo**, excluyendo los androides.
2.  Una gr√°fica de barras de los mismas planetas y excluyendo androides donde se muestre la proporci√≥n de sexos.
3.  Una gr√°fica de barras donde se muestre el n√∫mero de personajes de cada planeta del filme **A New Hope**

```{r}
#| include: true
#| code-fold: true
#| code-summary: "ver codigo"
#| eval: false

starwars <- read_csv("data/starwars.csv")

#ejercicio e1
starwars %>% 
  filter(homeworld %in% c("Tatooine", "Naboo")) %>% 
  filter(species != "droid") %>% 
  ggplot(., aes(x = height, fill = homeworld))+
  geom_density(alpha = 0.4)


# ejercicio e2
starwars %>% 
  filter(homeworld %in% c("Tatooine", "Naboo")) %>% 
  filter(species != "droid") %>% 
  ggplot(.,aes(x = homeworld, fill = sex))+
  geom_bar(position = "fill")

# ejercicio e3
starwars %>% 
  filter(str_detect(films, "A New Hope")) %>% 
  ggplot(., aes(x = homeworld)) +
  geom_bar()

### ejrcicio 3 alternativo
starwars %>%
  filter(str_detect(films, "A New Hope")) %>%
  count(homeworld,sort = TRUE) %>%
  ggplot(aes(x = homeworld, y = n)) +
  geom_col(fill = "steelblue")

```
::::

::: callout-tip
Un problema con el ejercicio 3 anterior es que las barras est√°n ordenadas en orden alfab√©tico, lo cual hace ggplot por default cuando utilizamos factores.

En lugar de ordenar lo factores a mano, podemos hacerlo de forma autom√°tica con la funci√≥n `reorder()` de R base en el eje x, es decir, en el *aes* x.

```{r}
#| warning: false
#| message: false


starwars %>%
  filter(str_detect(films, "A New Hope")) %>%
  count(homeworld,sort = TRUE) %>%
  ggplot(aes(x = reorder(homeworld, n), y = n)) +
  geom_col(fill = "steelblue")
```

Busca la documentaci√≥n de `reorder()`. Puedes leer mas sobre como ordenar factores en R \[aqu√≠\]https://guslipkin.medium.com/reordering-bar-and-column-charts-with-ggplot2-in-r-435fad1c643e){target="\_blank"}.
:::

### Variable discreta + variable continua

#### Boxplot (diagrama de cajas y bigotes)

Un diagrama de cajas y bigotes, tambi√©n conocido como boxplot, es una representaci√≥n gr√°fica que proporciona una descripci√≥n visual de la distribuci√≥n de un conjunto de datos. Este tipo de gr√°fico es particularmente √∫til para resumir la variabilidad y la dispersi√≥n de los datos, as√≠ como para identificar la presencia de valores at√≠picos.

La caja de un boxplot comienza en el primer cuartil Q1 (25%) y termina en el tercero Q3 (75%). Por lo tanto, la caja representa el 50% de los datos centrales, con una l√≠nea que representa la mediana. A cada lado de la caja se dibuja un segmento con los datos m√°s lejanos sin contar los valores at√≠picos (outliers) del boxplot, que en caso de existir, se representar√°n con c√≠rculos.

![Partes de un boxplot de una distribuci√≥n normal. Imagen tomada de Byjus.com](img/boxplot.png){fig-align="center" width="622"}

Un boxplot es una excelente forma de visualizar la dispersi√≥n de los datos categ√≥ricos. Para crear un boxplot, utilizamos la funci√≥n `geom_boxplot()`. Por ejemplo, si queremos ver la longitud del pico de los ping√ºinos por especie, podemos hacer lo siguiente:

```{r}
ggplot(data = penguins, aes(x = species, y = bill_length_mm))+
  geom_boxplot()
```

Al igual en los geom anteriores, podemos cambiar el color de relleno de las cajas con el par√°metro `fill =` dentro de `aes()`

```{r}
ggplot(data = penguins, aes(x = species, y = bill_length_mm))+
  geom_boxplot(aes(fill = sex))
```

#### Violin plot

Un gr√°fico de viol√≠n es una extensi√≥n del boxplot que muestra la distribuci√≥n de los datos a trav√©s de una estimaci√≥n de densidad. En lugar de mostrar solo los cuartiles y la mediana, el gr√°fico de viol√≠n tambi√©n muestra la forma de la distribuci√≥n de los datos, lo que permite ver si hay m√∫ltiples picos o si la distribuci√≥n es sim√©trica o asim√©trica.

Para utilizar un gr√°fico de viol√≠n, utilizamos la funci√≥n `geom_violin()`. Por ejemplo, si queremos ver la longitud del pico de los ping√ºinos por especie, podemos hacer lo siguiente:

```{r}
ggplot(data = penguins, aes(x = species, y = bill_length_mm, fill = sex))+
  geom_violin()
```

#### `geom_point()` y `geom_jitter()`

La funci√≥n `geom_point()` es una funci√≥n vers√°til ya que nos permite crear gr√°ficos de dispersi√≥n (mas adelante) o para visualizar la dispersi√≥n de datos categ√≥ricos. Por ejemplo, si queremos ver la longitud del pico de los ping√ºinos por especie y sexo, podemos hacer lo siguiente:

```{r}
ggplot(data = penguins, aes(x = species, y = bill_length_mm, color = sex))+
  geom_point()

```

Esta visualizaci√≥n es poco √∫til ya que todos los puntos se traslapan. Para poder separar cada uno de los grupos (*sexo*) necesitamos incluir el par√°metro `position =` para darle espacio entre cada grupo.

El par√°metro `position =` se puede incluir en cualquier tipo de geoms, no solo en los puntos, y permite ajustar el traslape entre grupos. Tiene varias opciones. Entre las mas √∫tiles que utilizaremos en este curso se encuentra:

-   `position_dodge()`: Esquiva el traslape lado a lado entre objetos
-   `position_jitter()`: Agrega una dispersi√≥n aleatoria en el eje x a los puntos para eviar que se traslape
-   `position_jitterdodge()`: Agrega de forma simultanea un *jitter* y *dodge* a los puntos
-   `position_identity()`: No ajusta la posici√≥n de los puntos

Para evitar el traslape entre los puntos, podemos utilizar el par√°metro `position = position_dodge()`. Por ejemplo:

```{r}
ggplot(data = penguins, aes(x = species, y = bill_length_mm, color = sex))+
  geom_point(position = position_dodge(0.2))
```

o podemos utilizar el par√°metro `position = position_jitter()` que agrega un desplazamiento aleatorio a los puntos en el eje x. Por ejemplo:

```{r}
ggplot(data = penguins, aes(x = species, y = bill_length_mm, color = sex))+
  geom_point(position = position_jitter(0.2))
```

Finalmente, podemos incorporar el par√°metro `position_jitterdodge()` para disminuir el traslape entre los puntos entre y dentro de cada grupo

```{r}
ggplot(data = penguins, aes(x = species, y = bill_length_mm, color = sex))+
  geom_point(position = position_jitterdodge(dodge.width = 0.3, 
                                             jitter.width = 0.1))
```

:::: column-margin
::: callout-note
# ¬øJitter? ü§∑Ô∏è

En dotplots, el *jitter* se refiere al desplazamiento aleatorio de puntos de datos individuales a lo largo del eje para evitar superposiciones, proporcionando una representaci√≥n m√°s clara de la distribuci√≥n de datos.

Dado que el valor es aleatorio, cada que se genere la gr√°fica, el desplazamiento de cada puto puede variar un poco sobre el eje x, pero su valor real (eje y) no se ver√° afectado.
:::
::::

### Visualizaci√≥n de una variable continua + una continua

Este tipo de visualizaciones nos permite ver la relaci√≥n entre dos variables continuas. Hay diversos geoms que podemos implementar, pero el m√°s com√∫n es nuevamente `geom_point()`.

Por ejemplo, si queremos ver la relaci√≥n entre la longitud del pico y la masa corporal de los ping√ºinos, podemos hacer lo siguiente:

```{r}
ggplot(data = penguins, aes(x = body_mass_g, y = bill_length_mm, color = sex))+
  geom_point()
```

### Visualizaci√≥n de resumenes estadisticos: `geom_errorbar()`

Muchas veces queremos mostrar de forma clara y sencilla como se comportan nuestro datos, por lo que podemos mostrar solamente algunos estad√≠sticos b√°sicos, como el promedio y el grado de dispersi√≥n de los datos usando ya sea la desviaci√≥n est√°ndar o el error est√°ndar. Esto lo podemos lograr utilizando funciones como `geom_point()` en conjunto con barras de dispersi√≥n con la funci√≥n `geom_errorbar()`.

Al igual que otros geoms, `geom_errorbar()` requiere que indiquemos su posici√≥n en el eje x, pero tambi√©n requiere que indiquemos sus limites superior e inferior sobre el eje y con los par√°metros `ymax =` y `ymin =`, respectivamente.

Para esto, primero necesitamos calcular estos estad√≠sticos antes de gr√°ficarlos.

Por ejemplo, calculemos el promedio y la desviaci√≥n est√°ndar de la longitud del pico para cada especie de ping√ºinos, por sexo.

```{r}
penguins_estat <- penguins %>% 
  group_by(species) %>% 
  summarise(promedio = mean(bill_length_mm, na.rm = TRUE),
            desvest = sd(bill_length_mm, na.rm = TRUE)) %>% 
  ungroup()

ggplot(penguins_estat, aes(x = species, y = promedio))+
  geom_point() +
  geom_errorbar(aes(ymin = promedio - desvest, ymax = promedio + desvest))

```

En este caso utilizamos un punto para indicar el promedio, pero tambi√©n podemos utilizar un gr√°fico de barras.

```{r}
ggplot(penguins_estat, aes(x = species, y = promedio))+
  geom_col() +
  geom_errorbar(aes(ymin = promedio - desvest, 
                    ymax = promedio + desvest), 
                width = 0.5)
```

::: callout-tip
# Estadisticos f√°ciles con Rstatix

`rstatix` es un paquete que nos permite calcular estad√≠sticos b√°sicos de forma sencilla y que se integra en la sintaxis de Tidiyverse.

Una de las herramientas de este paquete es la funci√≥n `get_summary_stats()` que nos permite calcular en un paso todos los estadisticos b√°sicos.

```{r}
#| message: false
#| warning: false


#install.packages(rstatix)
library(rstatix)

penguins_estat <- penguins %>% 
  group_by(species, sex) %>% 
  get_summary_stats(bill_length_mm)

penguins_estat
```


:::

::: {.callout-caution icon="false"}
# Desafio ping√ºinos

Realiza una gr√°fica de barras donde se muestre el promedio $\pm$ desviaci√≥n est√°ndar de la longitud del pico de cada especie y sexo. Distingue los sexos por el color de relleno de las barras.

Recuerda que puedes incluir el par√°metros `position = position_dodge()` para separar las barras entre grupos

```{r}
#| include: true
#| code-fold: true
#| code-summary: "ver codigo"
#| eval: false

penguins %>% 
  group_by(species, sex) %>% 
  summarise(promedio = mean(bill_length_mm, na.rm = TRUE),
            desvest = sd(bill_length_mm, na.rm= TRUE), 
            .groups = "drop") %>% 
  ggplot(., aes(x = species, y = promedio, fill = sex)) +
  geom_col(position = position_dodge(), color = "black")+
  geom_errorbar(aes(ymin = promedio - desvest, ymax = promedio + desvest),
                width = 0.5, position = position_dodge(0.9))
```
:::

:::: callout-warning
::: column-margin
![](img/friends_dont_barcharts.jpg){fig-align="center" width="316"}
:::

# Los amigos no permiten que sus amigos hagan gr√°ficas de barras

Muchas veces al presentar los datos de una investigaci√≥n nos vamos directamente a mostrar el promedio $\pm$ desviaci√≥n est√°ndar o alg√∫n otro valor de dispersi√≥n pero puede que esto no muestre toda la verdad sobre la distribuci√≥n de los datos. Como demostraci√≥n haz el siguiente ejercicio:

1.  Abre la tabla `datos_demo.csv` que se encuentra en la carpeta de datos
2.  Sin hacer ning√∫n tipo de observaci√≥n previa, haz una gr√°fica donde se muestre el promedio $\pm$ desviaci√≥n est√°ndar. Para ello, utiliza las funciones `group_by()` y `summarise()` que hemos visto anteriormente.
3.  Ahora, utilizando el set de datos completo, gr√°fica la dispersi√≥n de los datos con `geom_point()` y a√±ade un boxplot con `geom_boxplot()`.

```{r}
#| include: true
#| code-fold: true
#| code-summary: "ver codigo"
#| eval: false

demo <- read_csv("data/datos_demo.csv")


# promedios
demo %>% 
  group_by(grupo) %>% 
  summarise(promedio = mean(valor),
            desvest = sd(valor)) %>% 
  ggplot(.,aes(x = grupo, y = promedio, fill = grupo))+
  geom_col()+
  geom_errorbar(aes(ymin = promedio - desvest, ymax = promedio + desvest),
                width = 0.3)

# datos completos
demo %>% 
  ggplot(.,aes(x = grupo, y = valor, color = grupo))+
  geom_boxplot()+
  geom_point(position = position_jitterdodge(0.2))

```

**¬øQue conclusiones puedes sacar de ambas gr√°ficas?**

El uso de histogramas, densidades o gr√°ficas de dispersi√≥n nos permite hacer un an√°lisis exploratorio de los datos, permitiendo tomar mejores decisiones sobre el tipo de estad√≠sticos o procesamiento que se van a utilizar.

Puedes encontrar una discusi√≥n mas profunda sobra la importancia de la correcta presentaci√≥n e interpretaci√≥n de datos en publicaciones cient√≠ficas [aqu√≠](https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.1002128){page="_blank"}.
::::



:::: {.callout-caution icon="false"}
# **Ejercicio**


Recrea el gr√°fico de dispersi√≥n de los ping√ºinos que se muestra al inicio de esta secci√≥n, donde se muestre la longitud del pico en el eje x y la profundidad del pico en el eje y. Utiliza el color para distinguir las especies y agrega un punto con el valor promedio de la longitud y profundidad del pico de cada especie en color gris.

Ahora, agrega barras de error que representen la desviaci√≥n est√°ndar de la longitud y profundidad del pico de cada especie.




```{r}
#| include: true
#| code-fold: true
#| code-summary: "ver codigo"
#| eval: true


#make a dataframe with mean values of bill_depth_mm and bill_length_mm
promedios <- penguins %>% 
  group_by(species) %>% 
  summarise(mean_bill_length = mean(bill_length_mm, na.rm = TRUE),
            mean_bill_depth = mean(bill_depth_mm, na.rm = TRUE),
            desvest_bill_lenght = sd(bill_length_mm, na.rm = TRUE),
            desvest_bill_depth = sd(bill_depth_mm, na.rm = TRUE))


ggplot()+
  geom_point(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) +
  geom_point(data = promedios, aes(x = mean_bill_length, y = mean_bill_depth), 
             size = 5, color = "grey") +
  geom_errorbar(data = promedios, aes(x = mean_bill_length,
                                      ymax = mean_bill_depth + desvest_bill_depth , 
                                      ymin = mean_bill_depth - desvest_bill_depth))+
    geom_errorbar(data = promedios, aes(y = mean_bill_depth,
                                      xmax = mean_bill_length + desvest_bill_lenght , 
                                      xmin = mean_bill_length - desvest_bill_lenght))
```

:::





### Visualizaci√≥n de series de tiempo; geom_line()

Un gr√°fico de l√≠neas es una representaci√≥n visual de datos que muestra la relaci√≥n entre dos variables, donde una variable se representa en el eje x y la otra en el eje y. Los puntos de datos se conectan mediante l√≠neas para mostrar tendencias o patrones a lo largo del tiempo o de otra variable continua.

En ggplot `geom_line()` permite graficar l√≠neas conectando puntos, donde el _aesthetics_ `group` nos permite definir que observaciones estan conectadas. 


Para entender mejor esta geometr√≠a, utilizaremos el archivo `respiracion.csv`dentro de la carpeta `data` el cual contiene valores de consumo de ox√≠geno diario en un molusco marino bajo dos condiciones experimentales: **Control** y **Tratamiento**.

Por el momento, vamos a filtrar los datos para quedarnos con la experimento **Control**

```{r}
#| warning: false
#| message: false

respiracion <- read_csv("data/respiracion_long.csv")

# echamos un vistazo a los datos
glimpse(respiracion)

# Filtrar condici√≥n Control
respiracion_control <- respiracion %>% 
  filter(experimento == "Control")

```
Para graficar los datos de consumo de ox√≠geno diario, podemos utilizar `geom_line()` para conectar los puntos de datos. Para esto, necesitamos definir el eje x y el eje y, as√≠ como el grupo al que pertenece cada observaci√≥n, es decir, a cada individuo. 


Observa que pasa cuando no definimos el grupo:
```{r}
ggplot(respiracion_control, aes(x = dia, y = mo2)) +
  geom_line()
```

Ahora con el _aesthetic_ `group = individuo`:

```{r}
ggplot(respiracion_control, aes(x = dia, y = mo2, group = individuo)) +
  geom_line()
```

Si queremos distinguir los individuos por color, podemos agregar el _aesthetic_ `color = individuo`:

```{r}
ggplot(respiracion_control, aes(x = dia, y = mo2, group = individuo, color = individuo)) +
  geom_line()
```


Si queremos distinguir los individuos por color y adem√°s agregar puntos en cada observaci√≥n, podemos agregar `geom_point()`:
```{r}
ggplot(respiracion_control, aes(x = dia, y = mo2, group = individuo, color = individuo)) +
  geom_line() +
  geom_point()
```


**¬øComo podrias agregar una l√≠nea con los valores promedio de cada individuo?**





Podemos calcular el promedio de cada individuo y luego agregarlo al gr√°fico utilizando `geom_line()` nuevamente. Primero, calculamos el promedio de `mo2` por `dia`, y luego lo graficamos.

```{r}
#| include: true
#| code-fold: true
#| code-summary: "ver codigo"
#| eval: true


promedios_mo2 <- respiracion_control %>% 
  group_by(dia) %>% 
  summarise(promedio_mo2 = mean(mo2, na.rm = TRUE), .groups = "drop") 

ggplot(respiracion_control) +
  geom_line(aes(x = dia, y = mo2, group = individuo, color = individuo)) +
  geom_line(data = promedios_mo2, aes(x = dia, y = promedio_mo2, group = 1), 
            color = "black")


```


